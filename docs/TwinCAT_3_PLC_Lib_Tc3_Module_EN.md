---
title: "TE1000 Twin CAT 3"
product: "TwinCAT"
category: "PLC"
tags: ["CAT", "PLC", "TWIN"]
language: "EN"
document_type: "Library"
version: "1.4.1"
source_pdf: "https://download.beckhoff.com/download/Document/automation/twincat3/TwinCAT_3_PLC_Lib_Tc3_Module_EN.pdf"
release_date: "2025-08-14"
---
Manual | EN TE1000 Twin CAT 3 | PLC Library: Tc3_Module 2025-08-14 | Version: 1.4.1
## Page 3

Table of contents Table of contents 1 Foreword.................................................................................................................................................... 5 1.1 Notes on the documentation............................................................................................................. 5 1.2 For your safety.................................................................................................................................. 5 1.3 Notes on information security............................................................................................................ 7 2 Introduction............................................................................................................................................... 8 3 Function blocks......................................................................................................................................... 9 3.1 Tc Base Module Registered................................................................................................................. 9 3.1.1 Tc Add Ref........................................................................................................................... 9 3.1.2 Tc Get Object Id.................................................................................................................. 10 3.1.3 Tc Get Object Name........................................................................................................... 10 3.1.4 Tc Get Obj Para.................................................................................................................. 11 3.1.5 Tc Get Obj State................................................................................................................. 11 3.1.6 Tc Query Interface............................................................................................................. 12 3.1.7 Tc Release........................................................................................................................ 13 3.1.8 Tc Set Obj Id....................................................................................................................... 13 3.1.9 Tc Set Object Name............................................................................................................ 14 3.1.10 Tc Set Obj Para................................................................................................................... 14 3.1.11 Tc Set Obj State.................................................................................................................. 15 3.2 Tc Base Module Registered2............................................................................................................. 15 3.2.1 Tc Add Ref......................................................................................................................... 16 3.2.2 Tc Get Object Id.................................................................................................................. 16 3.2.3 Tc Get Object Name........................................................................................................... 17 3.2.4 Tc Get Obj Para.................................................................................................................. 18 3.2.5 Tc Get Obj State................................................................................................................. 18 3.2.6 Tc Query Interface............................................................................................................. 19 3.2.7 Tc Release........................................................................................................................ 20 3.2.8 Tc Set Obj Id....................................................................................................................... 20 3.2.9 Tc Set Object Name............................................................................................................ 21 3.2.10 Tc Set Obj Para................................................................................................................... 21 3.2.11 Tc Set Obj State.................................................................................................................. 22 4 Functions................................................................................................................................................. 23 4.1 FW_Obj Mgr_Create And Init Instance............................................................................................... 23 4.2 FW_Obj Mgr_Create Instance.......................................................................................................... 24 4.3 FW_Obj Mgr_Delete Instance........................................................................................................... 25 4.4 FW_Obj Mgr_Get Object Instance..................................................................................................... 25 4.5 FW_Safe Release............................................................................................................................ 26 4.6 FAILED............................................................................................................................................ 27 4.7 SUCCEEDED.................................................................................................................................. 28 4.8 ITCUNKNOWN_TO_PVOID........................................................................................................... 28 4.9 PVOID_TO_ITCUNKNOWN........................................................................................................... 29 4.10 Guids Equal...................................................................................................................................... 29 5 Global Constants..................................................................................................................................... 31 5.1 GVL................................................................................................................................................. 31 TE1000 Version: 1.4.1 3
## Page 4

Table of contents 5.2 Global_Version................................................................................................................................ 31 6 Error Codes............................................................................................................................................. 32 6.1 ADS Return Codes.......................................................................................................................... 32 7 Samples................................................................................................................................................... 37 7.1 Tc COM_Sample01_Plc To Plc......................................................................................................... 37 7.1.1 Creating an FB in the first PLC which provides its functionality globally.......................... 38 7.1.2 Creating an FB which likewise offers this functionality there as a simple proxy in the sec- ond PLC, ......................................................................................................................... 42 7.1.3 Execution of the sample project....................................................................................... 45 7.2 Tc COM_Sample02_Plc To Cpp........................................................................................................ 47 7.2.1 Instantiating a Twin CAT++ class as a Twin CAT Tc COM Object..................................... 47 7.2.2 Creating an FB in the PLC that, as a simple proxy, offers the functionality of the C++ ob- ject.................................................................................................................................... 48 7.2.3 Execution of the sample project....................................................................................... 50 7.3 Tc COM_Sample03_Plc Creates Cpp............................................................................................... 51 7.3.1 Provision of the binary C++ project (TMX) and its classes.............................................. 52 7.3.2 Creating an FB in the PLC that creates the C++ object and offers its functionality......... 53 7.3.3 Execution of the sample project....................................................................................... 55 7.4 Tc COM_Sample13_Cpp To Plc........................................................................................................ 55 7.4.1 Implementation of the sample.......................................................................................... 56 8 Appendix.................................................................................................................................................. 59 8.1 Tc COM Technology........................................................................................................................ 59 8.1.1 The Twin CAT Component Object Model (Tc COM) concept............................................ 59 8.2 Interfaces........................................................................................................................................ 70 8.2.1 Interface ITCom Object..................................................................................................... 70 8.2.2 Interface ITc Unknown...................................................................................................... 74 4 Version: 1.4.1 TE1000
## Page 5

Foreword 1 Foreword 1.1 Notes on the documentation This description is intended exclusively for trained specialists in control and automation technology who are familiar with the applicable national standards. The documentation and the following notes and explanations must be complied with when installing and commissioning the components. The trained specialists must always use the current valid documentation. The trained specialists must ensure that the application and use of the products described is in line with all safety requirements, including all relevant laws, regulations, guidelines, and standards. Disclaimer The documentation has been compiled with care. The products described are, however, constantly under development. We reserve the right to revise and change the documentation at any time and without notice. Claims to modify products that have already been supplied may not be made on the basis of the data, diagrams, and descriptions in this documentation. Trademarks Beckhoff®, ATRO® , Ether CAT®, Ether CAT G®, Ether CAT G10®, Ether CAT P®, MX-System®, Safety over Ether CAT®, TC/BSD®, Twin CAT®, Twin CAT/BSD®, Twin SAFE®, XFC®, XPlanar®, and XTS® are registered and licensed trademarks of Beckhoff Automation Gmb H. If third parties make use of the designations or trademarks contained in this publication for their own purposes, this could infringe upon the rights of the owners of the said designations. Ether CAT® is a registered trademark and patented technology, licensed by Beckhoff Automation Gmb H, Germany. Copyright © Beckhoff Automation Gmb H & Co. KG, Germany. The distribution and reproduction of this document, as well as the use and communication of its contents without express authorization, are prohibited. Offenders will be held liable for the payment of damages. All rights reserved in the event that a patent, utility model, or design are registered. Third-party trademarks Trademarks of third parties may be used in this documentation. You can find the trademark notices here: https://www.beckhoff.com/trademarks. 1.2 For your safety Safety regulations Read the following explanations for your safety. Always observe and follow product-specific safety instructions, which you may find at the appropriate places in this document. Exclusion of liability All the components are supplied in particular hardware and software configurations which are appropriate for the application. Modifications to hardware or software configurations other than those described in the documentation are not permitted, and nullify the liability of Beckhoff Automation Gmb H & Co. KG. TE1000 Version: 1.4.1 5
## Page 6

Foreword Personnel qualification This description is only intended for trained specialists in control, automation, and drive technology who are familiar with the applicable national standards. Signal words The signal words used in the documentation are classified below. In order to prevent injury and damage to persons and property, read and follow the safety and warning notices. Personal injury warnings DANGER Hazard with high risk of death or serious injury. WARNING Hazard with medium risk of death or serious injury. CAUTION There is a low-risk hazard that could result in medium or minor injury. Warning of damage to property or environment NOTICE The environment, equipment, or data may be damaged. Information on handling the product This information includes, for example: recommendations for action, assistance or further information on the product. 6 Version: 1.4.1 TE1000
## Page 7

Foreword 1.3 Notes on information security The products of Beckhoff Automation Gmb H & Co. KG (Beckhoff), insofar as they can be accessed online, are equipped with security functions that support the secure operation of plants, systems, machines and networks. Despite the security functions, the creation, implementation and constant updating of a holistic security concept for the operation are necessary to protect the respective plant, system, machine and networks against cyber threats. The products sold by Beckhoff are only part of the overall security concept. The customer is responsible for preventing unauthorized access by third parties to its equipment, systems, machines and networks. The latter should be connected to the corporate network or the Internet only if appropriate protective measures have been set up. In addition, the recommendations from Beckhoff regarding appropriate protective measures should be observed. Further information regarding information security and industrial security can be found in our https://www.beckhoff.com/secguide. Beckhoff products and solutions undergo continuous further development. This also applies to security functions. In light of this continuous further development, Beckhoff expressly recommends that the products are kept up to date at all times and that updates are installed for the products once they have been made available. Using outdated or unsupported product versions can increase the risk of cyber threats. To stay informed about information security for Beckhoff products, subscribe to the RSS feed at https:// www.beckhoff.com/secinfo. TE1000 Version: 1.4.1 7
## Page 8

Introduction 2 Introduction The PLC library Tc3_Module is used for Tc COM communication. System requirements Target System Windows 10, IPC or CX, (x86, x64, Arm®) Min. Twin CAT version 3.1.4020.0 Min. Twin CAT level TC1200 TC3 PLC 8 Version: 1.4.1 TE1000
## Page 9

Function blocks 3 Function blocks The PLC library Tc3_Module offers function blocks in order to communicate from module to module via Tc COM. The module can be a Twin CAT system component, a C++ object, a Matlab object or also objects in the PLC. 3.1 Tc Base Module Registered FUNCTION_BLOCK Tc Base Module Registered EXTENDS Tc Base Module VAR END_VAR Description If something is inherited from this object, a Tc COM object can be created from a function block. The object is automatically registered at the object server and ramped up to OP state. The own object ID is provided as a process image variable. Methods which are additionally implemented and are to be offered via this object must have a return value of the type HRESULT and must be implemented in a thread-safe manner. For more information, refer to the chapter 'Multi-task data access synchronization in the PLC'. How to create this Tc COM object and use it globally in the Twin CAT system is explained in detail in an example [} 37]. The Tc Base Module base class implements the ITCom Object interface, which in turn expands the ITc Unknown interface. ITCom Object Interface The ITCom Object interface is implemented by every Twin CAT module. It makes functionalities available regarding the state machine and Information from/to the Twin CAT system. Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 3.1.1 Tc Add Ref The Tc Add Ref() method increments the reference counter and returns the new value. Return value VAR_OUTPUT Tc Add Ref : UDINT; END_VAR Name Type Description Tc Add Ref UDINT The resulting reference count value is returned. Inputs VAR_INPUT (*none*) END_VAR Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module TE1000 Version: 1.4.1 9
## Page 10

Function blocks 3.1.2 Tc Get Object Id The method Tc Get Object Id saves the object ID with the help of the given OTCID reference. Return value VAR_OUTPUT Tc Get Object Id : HRESULT; END_VAR Name Type Description Tc Get Object Id HRESULT Gives information about success of the OTCID query. Inputs VAR_INPUT obj Id : REFERENCE TO OTCID; END_VAR Name Type Description obj Id REFERENCE TO Reference to OTCID value OTCID Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 3.1.3 Tc Get Object Name The method Tc Get Object Name saves the object names in the buffer with the given length. Return value VAR_OUTPUT Tc Get Object Name: DINT; END_VAR Name Type Description Tc Get Object Name DINT Gives information about success of the name query. Inputs VAR_INPUT obj Name : POINTER TO SINT; name Len : UDINT; END_VAR Name Type Description obj Name POINTER TO SI The name to be set NT name Len UDINT The maximum length of the name to be written 10 Version: 1.4.1 TE1000
## Page 11

Function blocks Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 3.1.4 Tc Get Obj Para The Tc Get Obj Para method queries an object parameter identified by means of its PTCID. Return value VAR_OUTPUT Tc Get Obj Para : HRESULT; END_VAR Name Type Description Tc Get Obj P HRESULT Gives information about success of the object parameter query. ara Inputs VAR_INPUT pid : PTCID; n Data : REFERENCE TO UDINT; p Data : REFERENCE TO PVOID; pgp : PTCGP; END_VAR Name Type Description pid PTCID Parameter-ID of the object parameter n Data REFERENCE TO UDINT Maximum length of the data p Data REFERENCE TO PVOID Pointer to the data Pgp PTCGP Reserved for future expansion. Pass NULL. Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 3.1.5 Tc Get Obj State The Tc Get Obj State method queries the current state of the object. Return value VAR_OUTPUT Tc Get Obj State : HRESULT; END_VAR TE1000 Version: 1.4.1 11
## Page 12

Function blocks Name Type Description Tc Get Obj State HRESULT Gives information about success of the state query. Inputs VAR_INPUT p State : POINTER TO TCOM_STATE; END_VAR Name Type Description p State POINTER TO TCOM_STA Pointer to the state TE Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 3.1.6 Tc Query Interface The method queries the reference at an implemented interface over the ID. Return value VAR_OUTPUT Tc Query Interface : HRESULT; END_VAR Name Type Description Tc Query Interface HRESULT Informs about success of the interface query. If the requested interface is not available, the method returns ADS_E_NOINTERFACE. Inputs VAR_INPUT iid : REFERENCE TO IID; pip Itf : POINTER TO PVOID; END_VAR Name Type Description iid REFERENCE TO IID Interface ID pip Itf POINTER TO PVOID Pointer to interface pointer. Is set when the requested interface type is available from the corresponding instance. Necessary release of the interface pointers You must explicitly release all references again. We recommend to use FW_Safe Release [} 26] in order to perform a release of the interface pointer after use. Frequently the release of the references is implemented in the destructor of the object. Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 12 Version: 1.4.1 TE1000
## Page 13

Function blocks 3.1.7 Tc Release The Tc Release() method decrements the reference counter and returns the new value. If the reference counter is 0, the object deletes itself. Return value VAR_OUTPUT Tc Release : UDINT; END_VAR Name Type Description Tc Release UDINT The resulting reference count value is returned. Inputs VAR_INPUT (*none*) END_VAR Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 3.1.8 Tc Set Obj Id The Tc Set Object Id method sets the object ID of the object to the given OTCID. Return value VAR_OUTPUT Tc Set Obj Id : HRESULT; END_VAR Name Type Description Tc Set Obj Id HRESULT Gives information about success of the ID change. Inputs VAR_INPUT obj Id : OTCID; END_VAR Name Type Description obj Id OTCID The OTCID to be set Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module TE1000 Version: 1.4.1 13
## Page 14

Function blocks 3.1.9 Tc Set Object Name The Tc Set Object Name method sets the object name of the object. Return value VAR_OUTPUT Tc Set Object Name : HRESULT; END_VAR Name Type Description Tc Set Object Nam HRESULT Gives information about the success of the name change. e Inputs VAR_INPUT obj Name : POINTER TO SINT; END_VAR Name Type Description obj Name POINTER TO SINT The name to be set of the object Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 3.1.10 Tc Set Obj Para The Tc Set Obj Para method sets an object parameter identified by means of its PTCID. Return value VAR_OUTPUT Tc Set Obj Para : HRESULT; END_VAR Name Type Description Tc Set Obj Para HRESULT Gives information about success of the parameter change. Inputs VAR_INPUT pid : PTCID; n Data : UDINT; p Data : PVOID; pgp : PTCGP; END_VAR 14 Version: 1.4.1 TE1000
## Page 15

Function blocks Name Type Description pid PTCID Parameter-ID of the object parameter n Data UDINT Maximum length of the data p Data PVOID Pointer to the data pgp PTCGPkl Reserved for future expansion, pass NULL. Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 3.1.11 Tc Set Obj State The Tc Set Obj State method initializes a transition to the given state. Return value VAR_OUTPUT Tc Set Obj State : HRESULT; END_VAR Name Type Description Tc Set Obj State HRESULT Gives information about success of the state change. Inputs VAR_INPUT state : TCOM_STATE; ip Srv : ITCom Obj Server; p Init Data : POINTER TO TCom Init Data Hdr; END_VAR Name Type Description state TCOM_STATE Displays the new state. ip Srv ITCom Obj Server Object description p Init Data POINTER TO TCom Init Data H Points to a list of parameters (optional). dr Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 3.2 Tc Base Module Registered2 FUNCTION_BLOCK Tc Base Module Registered2 EXTENDS Tc Base Module VAR_OUTPUT obj ID : OTCID; END_VAR TE1000 Version: 1.4.1 15
## Page 16

Function blocks Description If something is inherited from this object, a Tc COM object can be created from a function block. The object is automatically registered at the object server and ramped up to OP state. The own object ID is provided at the output. Methods which are additionally implemented and are to be offered via this object must have a return value of the type HRESULT and must be implemented in a thread-safe manner. For more information, refer to chapter 'Multi-task data access synchronization in the PLC'. How to create this Tc COM object and use it globally in the Twin CAT system is explained in detail in an example for Tc Base Module Registered [} 37]. The Tc Base Module base class implements the ITCom Object interface, which in turn expands the ITc Unknown interface. ITCom Object Interface The ITCom Object interface is implemented by every Twin CAT module. It makes functionalities available regarding the state machine and Information from/to the Twin CAT system. Requirements Twin CAT version Hardware Libraries to be integrated Twin CAT 3.1, Build 4024 x86, x64, ARM Tc3_Module >= v3.3.23.0 3.2.1 Tc Add Ref The Tc Add Ref() method increments the reference counter and returns the new value. Return value VAR_OUTPUT Tc Add Ref : UDINT; END_VAR Name Type Description Tc Add Ref UDINT The resulting reference count value is returned. Inputs VAR_INPUT (*none*) END_VAR Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 3.2.2 Tc Get Object Id The method Tc Get Object Id saves the object ID with the help of the given OTCID reference. 16 Version: 1.4.1 TE1000
## Page 17

Function blocks Return value VAR_OUTPUT Tc Get Object Id : HRESULT; END_VAR Name Type Description Tc Get Object Id HRESULT Gives information about success of the OTCID query. Inputs VAR_INPUT obj Id : REFERENCE TO OTCID; END_VAR Name Type Description obj Id REFERENCE TO Reference to OTCID value OTCID Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 3.2.3 Tc Get Object Name The method Tc Get Object Name saves the object names in the buffer with the given length. Return value VAR_OUTPUT Tc Get Object Name: DINT; END_VAR Name Type Description Tc Get Object Name DINT Gives information about success of the name query. Inputs VAR_INPUT obj Name : POINTER TO SINT; name Len : UDINT; END_VAR Name Type Description obj Name POINTER TO SI The name to be set NT name Len UDINT The maximum length of the name to be written Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module TE1000 Version: 1.4.1 17
## Page 18

Function blocks 3.2.4 Tc Get Obj Para The Tc Get Obj Para method queries an object parameter identified by means of its PTCID. Return value VAR_OUTPUT Tc Get Obj Para : HRESULT; END_VAR Name Type Description Tc Get Obj P HRESULT Gives information about success of the object parameter query. ara Inputs VAR_INPUT pid : PTCID; n Data : REFERENCE TO UDINT; p Data : REFERENCE TO PVOID; pgp : PTCGP; END_VAR Name Type Description pid PTCID Parameter-ID of the object parameter n Data REFERENCE TO UDINT Maximum length of the data p Data REFERENCE TO PVOID Pointer to the data Pgp PTCGP Reserved for future expansion. Pass NULL. Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 3.2.5 Tc Get Obj State The Tc Get Obj State method queries the current state of the object. Return value VAR_OUTPUT Tc Get Obj State : HRESULT; END_VAR Name Type Description Tc Get Obj State HRESULT Gives information about success of the state query. 18 Version: 1.4.1 TE1000
## Page 19

Function blocks Inputs VAR_INPUT p State : POINTER TO TCOM_STATE; END_VAR Name Type Description p State POINTER TO TCOM_STA Pointer to the state TE Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 3.2.6 Tc Query Interface The method queries the reference at an implemented interface over the ID. Return value VAR_OUTPUT Tc Query Interface : HRESULT; END_VAR Name Type Description Tc Query Interface HRESULT Informs about success of the interface query. If the requested interface is not available, the method returns ADS_E_NOINTERFACE. Inputs VAR_INPUT iid : REFERENCE TO IID; pip Itf : POINTER TO PVOID; END_VAR Name Type Description iid REFERENCE TO IID Interface ID pip Itf POINTER TO PVOID Pointer to interface pointer. Is set when the requested interface type is available from the corresponding instance. Necessary release of the interface pointers You must explicitly release all references again. We recommend to use FW_Safe Release [} 26] in order to perform a release of the interface pointer after use. Frequently the release of the references is implemented in the destructor of the object. Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module TE1000 Version: 1.4.1 19
## Page 20

Function blocks 3.2.7 Tc Release The Tc Release() method decrements the reference counter and returns the new value. If the reference counter is 0, the object deletes itself. Return value VAR_OUTPUT Tc Release : UDINT; END_VAR Name Type Description Tc Release UDINT The resulting reference count value is returned. Inputs VAR_INPUT (*none*) END_VAR Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 3.2.8 Tc Set Obj Id The Tc Set Object Id method sets the object ID of the object to the given OTCID. Return value VAR_OUTPUT Tc Set Obj Id : HRESULT; END_VAR Name Type Description Tc Set Obj Id HRESULT Gives information about success of the ID change. Inputs VAR_INPUT obj Id : OTCID; END_VAR Name Type Description obj Id OTCID The OTCID to be set Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 20 Version: 1.4.1 TE1000
## Page 21

Function blocks 3.2.9 Tc Set Object Name The Tc Set Object Name method sets the object name of the object. Return value VAR_OUTPUT Tc Set Object Name : HRESULT; END_VAR Name Type Description Tc Set Object Nam HRESULT Gives information about the success of the name change. e Inputs VAR_INPUT obj Name : POINTER TO SINT; END_VAR Name Type Description obj Name POINTER TO SINT The name to be set of the object Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 3.2.10 Tc Set Obj Para The Tc Set Obj Para method sets an object parameter identified by means of its PTCID. Return value VAR_OUTPUT Tc Set Obj Para : HRESULT; END_VAR Name Type Description Tc Set Obj Para HRESULT Gives information about success of the parameter change. Inputs VAR_INPUT pid : PTCID; n Data : UDINT; p Data : PVOID; pgp : PTCGP; END_VAR TE1000 Version: 1.4.1 21
## Page 22

Function blocks Name Type Description pid PTCID Parameter-ID of the object parameter n Data UDINT Maximum length of the data p Data PVOID Pointer to the data pgp PTCGPkl Reserved for future expansion, pass NULL. Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 3.2.11 Tc Set Obj State The Tc Set Obj State method initializes a transition to the given state. Return value VAR_OUTPUT Tc Set Obj State : HRESULT; END_VAR Name Type Description Tc Set Obj State HRESULT Gives information about success of the state change. Inputs VAR_INPUT state : TCOM_STATE; ip Srv : ITCom Obj Server; p Init Data : POINTER TO TCom Init Data Hdr; END_VAR Name Type Description state TCOM_STATE Displays the new state. ip Srv ITCom Obj Server Object description p Init Data POINTER TO TCom Init Data H Points to a list of parameters (optional). dr Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 22 Version: 1.4.1 TE1000
## Page 23

Functions 4 Functions The PLC library Tc3_Module offers functions, in order to communicate from module to module via Tc COM. The module can be a Twin CAT system component, a C++ object, a Matlab object or also objects in the PLC. 4.1 FW_Obj Mgr_Create And Init Instance This function generates an instance of the class specified by means of Class-ID and at the same time returns an interface pointer to this object. In addition the object name and state into which the object is to be put, as well as optionally also initialization parameters can be specified. Return value FW_Obj Mgr_Create And Init Instance : HRESULT; Name Type Description FW_Obj Mgr_Cre HRESULT Returns S_OK if the function call was successful. ate And Init Instanc e Inputs VAR_INPUT cls Id : CLSID; iid : IID; pip Unk : POINTER TO ITc Unknown; obj Id : UDINT; parent Id : UDINT; name : REFERENCE TO STRING; state : UDINT; p Init Data : POINTER TO TCom Init Data Hdr; END_VAR TE1000 Version: 1.4.1 23
## Page 24

Functions Name Type Description cls Id CLSID Specifies the class from which an object should be created. iid IID Specifies the interface ID to which an interface pointer should be referenced. pip Unk POINTER TO ITc Unknown Returns the interface pointer to the created object. obj Id UDINT Specifies the object ID for the newly created object. If the global constant OTCID_Create New Id is entered here a new object ID is generated internally. parent Id UDINT Object ID of the parent object (optional) Here the object ID of the PLC instance can be specified from which this function is called. (Twin CAT_System Info Var List._App Info. Obj Id). name REFERENCE TO STRING Specifies the object name which should be assigned for the newly created object. State UDINT Specifies the state into which the newly created object should be put. Typically Operational (TCOM_STATE. TCOM_STATE_OP) is specified. p Init Data POINTER TO TCom Init Data H Pointer to initialization parameter (optional) dr Necessary deletion of an object A generated object must be explicitly deleted again. There is no Garbage-Collector as in . Net. We recommend to use FW_Obj Mgr_Delete Instance [} 25], in order to delete the generated instance at the latest in the destructor of the object which created the instance. Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 4.2 FW_Obj Mgr_Create Instance This function generates an instance of the class specified by means of Class-ID and at the same time returns an interface pointer to this object. Return value FW_Obj Mgr_Create Instance : HRESULT; Name Type Description FW_Obj Mgr_Cre HRESULT Returns S_OK if the function call was successful. ate Instance Inputs VAR_INPUT cls Id : CLSID; iid : IID; pip Unk : POINTER TO ITc Unknown; END_VAR 24 Version: 1.4.1 TE1000
## Page 25

Functions Name Type Description cls Id CLSID Specifies the class from which an object should be created. iid IID Specifies the interface ID to which an interface pointer should be referenced. pip Unk POINTER TO ITc Unknown Returns the interface pointer to the created object. Necessary deletion of an object A generated object must be explicitly deleted again. There is no Garbage-Collector as in . Net. We recommend to use FW_Obj Mgr_Delete Instance [} 25], in order to delete the generated instance at the latest in the destructor of the object which created the instance. Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 4.3 FW_Obj Mgr_Delete Instance This function puts the object in the Init state. After that the reference counter of the object is decremented, analogous to ITc Unknown. Tc Release(), and the interface pointer is set to zero at the same time. Return value FW_Obj Mgr_Delete Instance : HRESULT; Name Type Description FW_Obj Mgr_Del HRESULT Returns S_OK if the function call was successful. ete Instance Inputs VAR_INPUT pip Unk : POINTER TO ITc Unknown; END_VAR Name Type Description pip Unk POINTER TO ITc Unknown Specifies the address of the interface pointer to the object. The interface pointer is checked internally for null pointers. Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 4.4 FW_Obj Mgr_Get Object Instance This function returns an interface pointer to an object instance specified by means of object ID. TE1000 Version: 1.4.1 25
## Page 26

Functions Return value FW_Obj Mgr_Get Object Instance : HRESULT; Name Type Description FW_Obj Mgr_Get HRESULT Returns S_OK if the function call was successful. Object Instance Inputs VAR_INPUT oid : OTCID; (*OID of object*) iid : IID; (*requested interface*) pip Unk : POINTER TO ITc Unknown; END_VAR Name Type Description oid OTCID Object ID iid IID Specifies the interface ID to which an interface pointer should be referenced. pip Unk POINTER TO ITc Unknown Returns the interface pointer to the created object. Necessary release of the interface pointers You must explicitly release all references again. We recommend to use FW_Safe Release [} 26] in order to perform a release of the interface pointer after use. Frequently the release of the references is implemented in the destructor of the object. Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 4.5 FW_Safe Release This function decrements the reference counter of the object, analogous to ITc Unknown. Tc Release(), and at the same time sets the interface pointer to zero. Return value FW_Safe Release : HRESULT; Name Type Description FW_Safe Release HRESULT Returns S_OK if the function call was successful. Inputs VAR_INPUT pip Unk : POINTER TO ITc Uknown; END_VAR Name Type Description pip Unk POINTER TO ITc Uknown Specifies the address of the interface pointer to the object. The interface pointer is checked internally for null pointers. 26 Version: 1.4.1 TE1000
## Page 27

Functions Example This function can for example be called in the destructor of the object family, which holds an interface pointer to another object. METHOD FB_exit : BOOL VAR_INPUT b In Copy Code : BOOL; // if TRUE, the exit method is called for exiting an instance that is copied afterwards (online change). END_VAR ----------------------------------------------------------------------- IF NOT b In Copy Code THEN // no online change FW_Safe Release(ADR(ip Itf)); END_IF Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 4.6 FAILED Error codes or status codes of the type HRESULT are checked with this function for invalidity. Return value FAILED : BOOL; Name Type Description FAILED BOOL Returns TRUE if an error is present. Inputs VAR_INPUT hr : DINT; END_VAR Name Type Description hr DINT Specification of the error code or status code of type HRESULT to be checked. HRESULT The type HRESULT has the special feature that errors are represented by negative values. Warnings or information can optionally be output by means of positive values. Declaration Error range No error Message/info Check functions hr Error Code : <0 >=0 >0 IF SUCCEEDED(hr Error Code) HRESULT; THEN ... END_IF IF FAILED(hr Error Code) THEN ... END_IF TE1000 Version: 1.4.1 27
## Page 28

Functions Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 4.7 SUCCEEDED Error codes or status codes of the type HRESULT are checked with this function for validity. Return value SUCCEEDED : BOOL; Name Type Description SUCCEEDED BOOL Returns TRUE if no error. Inputs VAR_INPUT hr : DINT; END_VAR Name Type Description hr DINT Specification of the error code or status code of type HRESULT to be checked. HRESULT The type HRESULT has the special feature that errors are represented by negative values. Warnings or information can optionally be output by means of positive values. Declaration Error range No error Message/info Check functions hr Error Code : <0 >=0 >0 IF SUCCEEDED(hr Error Code) HRESULT; THEN ... END_IF IF FAILED(hr Error Code) THEN ... END_IF Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 4.8 ITCUNKNOWN_TO_PVOID This conversion function converts an interface pointer of the type ITc Unknown to a pointer to VOID. 28 Version: 1.4.1 TE1000
## Page 29

Functions Return value ITCUNKNOWN_TO_PVOID : PVOID Inputs VAR_INPUT itc Unknown : ITc Uknown; END_VAR Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 4.9 PVOID_TO_ITCUNKNOWN This conversion function converts a pointer to VOID to an interface pointer of the type ITc Unknown. Return value PVOID_TO_ITCUNKNOWN : ITc Unknown; Inputs VAR_INPUT p Void : PVOID; END_VAR Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 4.10 Guids Equal The function Guids Equal checks two GUID objects for their equality to one another. Return value: Guids Equal : BOOL; Name Type Description Guids Equal BOOL The method returns TRUE when both arguments are equal. Inputs VAR_INPUT p Guid A : POINTER TO GUID; p Guid B : POINTER TO GUID; END_VAR TE1000 Version: 1.4.1 29
## Page 30

Functions Name Type Description p Guid A POINTER TO GUID Pointer to GUID object p Guid B POINTER TO GUID Pointer to GUID object Requirements Twin CAT Version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 30 Version: 1.4.1 TE1000
## Page 31

Global Constants 5 Global Constants 5.1 GVL VAR_GLOBAL CONSTANT GVL S_OK : HRESULT := 0; S_FALSE : HRESULT := 1; S_PENDING : HRESULT := 16#203; S_WATCHDOG_TIMEOUT : HRESULT := 16#256; OTCID_Create New Id : OTCID := 16#FFFFFFFF; OTCID_First Free Id : OTCID := 16#71010000; OTCID_Last Free Id : OTCID := 16#710FFFFF; NULL : PVOID := 0; END_VAR Name Type Value Use Meaning S_OK HRESUL 0 This constant can be used, to T designate error-free processing in an HRESULT status code. S_FALSE HRESUL 1 This constant indicates T successful processing, although the result was negative or incomplete. S_PENDING HRESUL 16#203 This constant indicates T successful processing, although no result is available yet. S_WATCHDOG_TIME HRESUL 16#256 This constant indicates OUT T successful processing, although a timeout occurred. Depending on the function, the desired processing was aborted. OTCID_Create New Id OTCID 16#FFFFFFFF FW_Obj Mgr_Create A This constant is used to generate a new object ID. nd Init Instance [} 23] OTCID_First Free Id OTCID 16#71010000 OTCID_Last Free Id OTCID 16#710FFFFF NULL PVOID 0 NULL pointer 5.2 Global_Version All libraries have a certain version. The version is indicated in the PLC library repository, for example. A global constant contains the information about the library version: VAR_GLOBAL CONSTANT st Lib Version_Tc3_Module : ST_Lib Version; END_VAR Name Type Description st Lib Version_Tc3 ST_Lib Version Version information of the Tc3_Module library _Module To check whether the version you have is the version you need, use the function F_Cmp Lib Version (defined in the Tc2_System PLC library). TE1000 Version: 1.4.1 31
## Page 32

Error Codes 6 Error Codes The return values of the functions and methods are output by the type HRESULT. High Word of HRESULT Group of error codes 16#9811 Ads Error codes 6.1 ADS Return Codes Grouping of error codes: Global error codes: 0x0000 [} 32]... (0x9811_0000 ...) Router error codes: 0x500 [} 32]... (0x9811_0500 ...) General ADS errors: 0x700 [} 33]... (0x9811_0700 ...) RTime error codes: 0x1000 [} 35]... (0x9811_1000 ...) Global error codes Hex Dec HRESULT Name Description 0x0 0 0x98110000 ERR_NOERROR No error. 0x1 1 0x98110001 ERR_INTERNAL Internal error. 0x2 2 0x98110002 ERR_NORTIME No real time. 0x3 3 0x98110003 ERR_ALLOCLOCKEDMEM Allocation locked – memory error. 0x4 4 0x98110004 ERR_INSERTMAILBOX Mailbox full – the ADS message could not be sent. Reducing the number of ADS messages per cycle will help. 0x5 5 0x98110005 ERR_WRONGRECEIVEHMSG Wrong HMSG. 0x6 6 0x98110006 ERR_TARGETPORTNOTFOUND Target port not found – ADS server is not started, not reachable or not installed. 0x7 7 0x98110007 ERR_TARGETMACHINENOTFOUND Target computer not found – AMS route was not found. 0x8 8 0x98110008 ERR_UNKNOWNCMDID Unknown command ID. 0x9 9 0x98110009 ERR_BADTASKID Invalid task ID. 0x A 10 0x9811000A ERR_NOIO No IO. 0x B 11 0x9811000B ERR_UNKNOWNAMSCMD Unknown AMS command. 0x C 12 0x9811000C ERR_WIN32ERROR Win32 error. 0x D 13 0x9811000D ERR_PORTNOTCONNECTED Port not connected. 0x E 14 0x9811000E ERR_INVALIDAMSLENGTH Invalid AMS length. 0x F 15 0x9811000F ERR_INVALIDAMSNETID Invalid AMS Net ID. 0x10 16 0x98110010 ERR_LOWINSTLEVEL Installation level is too low –Twin CAT 2 license error. 0x11 17 0x98110011 ERR_NODEBUGINTAVAILABLE No debugging available. 0x12 18 0x98110012 ERR_PORTDISABLED Port disabled – Twin CAT system service not started. 0x13 19 0x98110013 ERR_PORTALREADYCONNECTED Port already connected. 0x14 20 0x98110014 ERR_AMSSYNC_W32ERROR AMS Sync Win32 error. 0x15 21 0x98110015 ERR_AMSSYNC_TIMEOUT AMS Sync Timeout. 0x16 22 0x98110016 ERR_AMSSYNC_AMSERROR AMS Sync error. 0x17 23 0x98110017 ERR_AMSSYNC_NOINDEXINMAP No index map for AMS Sync available. 0x18 24 0x98110018 ERR_INVALIDAMSPORT Invalid AMS port. 0x19 25 0x98110019 ERR_NOMEMORY No memory. 0x1A 26 0x9811001A ERR_TCPSEND TCP send error. 0x1B 27 0x9811001B ERR_HOSTUNREACHABLE Host unreachable. 0x1C 28 0x9811001C ERR_INVALIDAMSFRAGMENT Invalid AMS fragment. 0x1D 29 0x9811001D ERR_TLSSEND TLS send error – secure ADS connection failed. 0x1E 30 0x9811001E ERR_ACCESSDENIED Access denied – secure ADS access denied. Router error codes 32 Version: 1.4.1 TE1000
## Page 33

Error Codes Hex Dec HRESULT Name Description 0x500 1280 0x98110500 ROUTERERR_NOLOCKEDMEMORY Locked memory cannot be allocated. 0x501 1281 0x98110501 ROUTERERR_RESIZEMEMORY The router memory size could not be changed. 0x502 1282 0x98110502 ROUTERERR_MAILBOXFULL The mailbox has reached the maximum number of possible messages. 0x503 1283 0x98110503 ROUTERERR_DEBUGBOXFULL The Debug mailbox has reached the maximum number of possible messages. 0x504 1284 0x98110504 ROUTERERR_UNKNOWNPORTTYPE The port type is unknown. 0x505 1285 0x98110505 ROUTERERR_NOTINITIALIZED The router is not initialized. 0x506 1286 0x98110506 ROUTERERR_PORTALREADYINUSE The port number is already assigned. 0x507 1287 0x98110507 ROUTERERR_NOTREGISTERED The port is not registered. 0x508 1288 0x98110508 ROUTERERR_NOMOREQUEUES The maximum number of ports has been reached. 0x509 1289 0x98110509 ROUTERERR_INVALIDPORT The port is invalid. 0x50A 1290 0x9811050A ROUTERERR_NOTACTIVATED The router is not active. 0x50B 1291 0x9811050B ROUTERERR_FRAGMENTBOXFULL The mailbox has reached the maximum number for fragmented messages. 0x50C 1292 0x9811050C ROUTERERR_FRAGMENTTIMEOUT A fragment timeout has occurred. 0x50D 1293 0x9811050D ROUTERERR_TOBEREMOVED The port is removed. General ADS error codes TE1000 Version: 1.4.1 33
## Page 34

Error Codes Hex Dec HRESULT Name Description 0x700 1792 0x98110700 ADSERR_DEVICE_ERROR General device error. 0x701 1793 0x98110701 ADSERR_DEVICE_SRVNOTSUPP Service is not supported by the server. 0x702 1794 0x98110702 ADSERR_DEVICE_INVALIDGRP Invalid index group. 0x703 1795 0x98110703 ADSERR_DEVICE_INVALIDOFFSET Invalid index offset. 0x704 1796 0x98110704 ADSERR_DEVICE_INVALIDACCESS Reading or writing not permitted. Several causes are possible. For example, an incorrect password was entered when creating routes. 0x705 1797 0x98110705 ADSERR_DEVICE_INVALIDSIZE Parameter size not correct. 0x706 1798 0x98110706 ADSERR_DEVICE_INVALIDDATA Invalid data values. 0x707 1799 0x98110707 ADSERR_DEVICE_NOTREADY Device is not ready to operate. 0x708 1800 0x98110708 ADSERR_DEVICE_BUSY Device is busy. 0x709 1801 0x98110709 ADSERR_DEVICE_INVALIDCONTEXT Invalid operating system context. This can result from use of ADS blocks in different tasks. It may be possible to resolve this through multitasking synchronization in the PLC. 0x70A 1802 0x9811070A ADSERR_DEVICE_NOMEMORY Insufficient memory. 0x70B 1803 0x9811070B ADSERR_DEVICE_INVALIDPARM Invalid parameter values. 0x70C 1804 0x9811070C ADSERR_DEVICE_NOTFOUND Not found (files, ...). 0x70D 1805 0x9811070D ADSERR_DEVICE_SYNTAX Syntax error in file or command. 0x70E 1806 0x9811070E ADSERR_DEVICE_INCOMPATIBLE Objects do not match. 0x70F 1807 0x9811070F ADSERR_DEVICE_EXISTS Object already exists. 0x710 1808 0x98110710 ADSERR_DEVICE_SYMBOLNOTFOUND Symbol not found. 0x711 1809 0x98110711 ADSERR_DEVICE_SYMBOLVERSIONINVALID Invalid symbol version. This can occur due to an online change. Create a new handle. 0x712 1810 0x98110712 ADSERR_DEVICE_INVALIDSTATE Device (server) is in invalid state. 0x713 1811 0x98110713 ADSERR_DEVICE_TRANSMODENOTSUPP Ads Trans Mode not supported. 0x714 1812 0x98110714 ADSERR_DEVICE_NOTIFYHNDINVALID Notification handle is invalid. 0x715 1813 0x98110715 ADSERR_DEVICE_CLIENTUNKNOWN Notification client not registered. 0x716 1814 0x98110716 ADSERR_DEVICE_NOMOREHDLS No further handle available. 0x717 1815 0x98110717 ADSERR_DEVICE_INVALIDWATCHSIZE Notification size too large. 0x718 1816 0x98110718 ADSERR_DEVICE_NOTINIT Device not initialized. 0x719 1817 0x98110719 ADSERR_DEVICE_TIMEOUT Device has a timeout. 0x71A 1818 0x9811071A ADSERR_DEVICE_NOINTERFACE Interface query failed. 0x71B 1819 0x9811071B ADSERR_DEVICE_INVALIDINTERFACE Wrong interface requested. 0x71C 1820 0x9811071C ADSERR_DEVICE_INVALIDCLSID Class ID is invalid. 0x71D 1821 0x9811071D ADSERR_DEVICE_INVALIDOBJID Object ID is invalid. 0x71E 1822 0x9811071E ADSERR_DEVICE_PENDING Request pending. 0x71F 1823 0x9811071F ADSERR_DEVICE_ABORTED Request is aborted. 0x720 1824 0x98110720 ADSERR_DEVICE_WARNING Signal warning. 0x721 1825 0x98110721 ADSERR_DEVICE_INVALIDARRAYIDX Invalid array index. 0x722 1826 0x98110722 ADSERR_DEVICE_SYMBOLNOTACTIVE Symbol not active. 0x723 1827 0x98110723 ADSERR_DEVICE_ACCESSDENIED Access denied. Several causes are possible. For example, a unidirectional ADS route is used in the opposite direction. 0x724 1828 0x98110724 ADSERR_DEVICE_LICENSENOTFOUND Missing license. 0x725 1829 0x98110725 ADSERR_DEVICE_LICENSEEXPIRED License expired. 0x726 1830 0x98110726 ADSERR_DEVICE_LICENSEEXCEEDED License exceeded. 0x727 1831 0x98110727 ADSERR_DEVICE_LICENSEINVALID Invalid license. 0x728 1832 0x98110728 ADSERR_DEVICE_LICENSESYSTEMID License problem: System ID is invalid. 0x729 1833 0x98110729 ADSERR_DEVICE_LICENSENOTIMELIMIT License not limited in time. 0x72A 1834 0x9811072A ADSERR_DEVICE_LICENSEFUTUREISSUE Licensing problem: time in the future. 0x72B 1835 0x9811072B ADSERR_DEVICE_LICENSETIMETOLONG License period too long. 0x72C 1836 0x9811072C ADSERR_DEVICE_EXCEPTION Exception at system startup. 0x72D 1837 0x9811072D ADSERR_DEVICE_LICENSEDUPLICATED License file read twice. 0x72E 1838 0x9811072E ADSERR_DEVICE_SIGNATUREINVALID Invalid signature. 0x72F 1839 0x9811072F ADSERR_DEVICE_CERTIFICATEINVALID Invalid certificate. 0x730 1840 0x98110730 ADSERR_DEVICE_LICENSEOEMNOTFOUND Public key not known from OEM. 0x731 1841 0x98110731 ADSERR_DEVICE_LICENSERESTRICTED License not valid for this system ID. 34 Version: 1.4.1 TE1000
## Page 35

Error Codes Hex Dec HRESULT Name Description 0x732 1842 0x98110732 ADSERR_DEVICE_LICENSEDEMODENIED Demo license prohibited. 0x733 1843 0x98110733 ADSERR_DEVICE_INVALIDFNCID Invalid function ID. 0x734 1844 0x98110734 ADSERR_DEVICE_OUTOFRANGE Outside the valid range. 0x735 1845 0x98110735 ADSERR_DEVICE_INVALIDALIGNMENT Invalid alignment. 0x736 1846 0x98110736 ADSERR_DEVICE_LICENSEPLATFORM Invalid platform level. 0x737 1847 0x98110737 ADSERR_DEVICE_FORWARD_PL Context – forward to passive level. 0x738 1848 0x98110738 ADSERR_DEVICE_FORWARD_DL Context – forward to dispatch level. 0x739 1849 0x98110739 ADSERR_DEVICE_FORWARD_RT Context – forward to real-time. 0x740 1856 0x98110740 ADSERR_CLIENT_ERROR Client error. 0x741 1857 0x98110741 ADSERR_CLIENT_INVALIDPARM Service contains an invalid parameter. 0x742 1858 0x98110742 ADSERR_CLIENT_LISTEMPTY Polling list is empty. 0x743 1859 0x98110743 ADSERR_CLIENT_VARUSED Var connection already in use. 0x744 1860 0x98110744 ADSERR_CLIENT_DUPLINVOKEID The called ID is already in use. 0x745 1861 0x98110745 ADSERR_CLIENT_SYNCTIMEOUT Timeout has occurred – the remote terminal is not responding in the specified ADS timeout. The route setting of the remote terminal may be configured incorrectly. 0x746 1862 0x98110746 ADSERR_CLIENT_W32ERROR Error in Win32 subsystem. 0x747 1863 0x98110747 ADSERR_CLIENT_TIMEOUTINVALID Invalid client timeout value. 0x748 1864 0x98110748 ADSERR_CLIENT_PORTNOTOPEN Port not open. 0x749 1865 0x98110749 ADSERR_CLIENT_NOAMSADDR No AMS address. 0x750 1872 0x98110750 ADSERR_CLIENT_SYNCINTERNAL Internal error in Ads sync. 0x751 1873 0x98110751 ADSERR_CLIENT_ADDHASH Hash table overflow. 0x752 1874 0x98110752 ADSERR_CLIENT_REMOVEHASH Key not found in the table. 0x753 1875 0x98110753 ADSERR_CLIENT_NOMORESYM No symbols in the cache. 0x754 1876 0x98110754 ADSERR_CLIENT_SYNCRESINVALID Invalid response received. 0x755 1877 0x98110755 ADSERR_CLIENT_SYNCPORTLOCKED Sync Port is locked. 0x756 1878 0x98110756 ADSERR_CLIENT_REQUESTCANCELLED The request was canceled. RTime error codes Hex Dec HRESULT Name Description 0x1000 4096 0x98111000 RTERR_INTERNAL Internal error in the real-time system. 0x1001 4097 0x98111001 RTERR_BADTIMERPERIODS Timer value is not valid. 0x1002 4098 0x98111002 RTERR_INVALIDTASKPTR Task pointer has the invalid value 0 (zero). 0x1003 4099 0x98111003 RTERR_INVALIDSTACKPTR Stack pointer has the invalid value 0 (zero). 0x1004 4100 0x98111004 RTERR_PRIOEXISTS The request task priority is already assigned. 0x1005 4101 0x98111005 RTERR_NOMORETCB No free TCB (Task Control Block) available. The maximum number of TCBs is 64. 0x1006 4102 0x98111006 RTERR_NOMORESEMAS No free semaphores available. The maximum number of semaphores is 64. 0x1007 4103 0x98111007 RTERR_NOMOREQUEUES No free space available in the queue. The maximum number of positions in the queue is 64. 0x100D 4109 0x9811100D RTERR_EXTIRQALREADYDEF An external synchronization interrupt is already applied. 0x100E 4110 0x9811100E RTERR_EXTIRQNOTDEF No external sync interrupt applied. 0x100F 4111 0x9811100F RTERR_EXTIRQINSTALLFAILED Application of the external synchronization interrupt has failed. 0x1010 4112 0x98111010 RTERR_IRQLNOTLESSOREQUAL Call of a service function in the wrong context 0x1017 4119 0x98111017 RTERR_VMXNOTSUPPORTED Intel VT-x extension is not supported. 0x1018 4120 0x98111018 RTERR_VMXDISABLED Intel VT-x extension is not enabled in the BIOS. 0x1019 4121 0x98111019 RTERR_VMXCONTROLSMISSING Missing function in Intel VT-x extension. 0x101A 4122 0x9811101A RTERR_VMXENABLEFAILS Activation of Intel VT-x fails. Specific positive HRESULT Return Codes: TE1000 Version: 1.4.1 35
## Page 36

Error Codes HRESULT Name Description 0x0000_0000 S_OK No error. 0x0000_0001 S_FALSE No error. Example: successful processing, but with a negative or incomplete result. 0x0000_0203 S_PENDING No error. Example: successful processing, but no result is available yet. 0x0000_0256 S_WATCHDOG_TIMEOUT No error. Example: successful processing, but a timeout occurred. TCP Winsock error codes Hex Dec Name Description 0x274C 10060 WSAETIMEDOUT A connection timeout has occurred - error while establishing the connection, because the remote terminal did not respond properly after a certain period of time, or the established connection could not be maintained because the connected host did not respond. 0x274D 10061 WSAECONNREFUSED Connection refused - no connection could be established because the target computer has explicitly rejected it. This error usually results from an attempt to connect to a service that is inactive on the external host, that is, a service for which no server application is running. 0x2751 10065 WSAEHOSTUNREACH No route to host - a socket operation referred to an unavailable host. More Winsock error codes: Win32 error codes 36 Version: 1.4.1 TE1000
## Page 37

Samples 7 Samples The Tc COM_Sample01 sample [} 37] shows how Tc COM communication can take place between two PLCs. In the process functionalities from one PLC are directly called up from the other PLC. The Tc COM_Sample02 sample [} 47] shows how a PLC application can use functionalities of an existing instance of a Twin CAT C++ class. In this way separate algorithms written C++ (or Matlab) can be used easily in the PLC. Although in the event of the use of an existing Twin CAT C++ module the Twin CAT C++ license is required on the target system, a C++ development environment is not necessary on the target system or on the development computer. The Tc COM_Sample03 sample [} 51] shows how a PLC application uses functionalities of a Twin CAT C++ class by generating an instance of C++ class at the same time. In comparison to the previous sample this can offer increased flexibility. You will find additional programming examples in the documentation of Twin CAT 3 C++. For example, it describes an additional option for calling an algorithm written in C++ from a PLC program (Sample11). In contrast to Tc COM_Sample02, here a wrapper module is programmed that each interface method implements itself. Therefore this variant is more complex. However, if you have to forego interface pointers calling the functionalities in the PLC application due to users, this variant offers an option for doing this. Another example in the documentation of Twin CAT 3 C++ shows how a Twin CAT C++ Module calls up a method of a function block of the PLC by Tc COM interface (Sample13). 7.1 Tc COM_Sample01_Plc To Plc This sample describes a Tc COM communication between two PLCs. Functionalities provided by a function block in the first PLC (also called "provider" in the sample), are called from the second PLC (also called "caller" in the sample). To this end it is not necessary for the function block or its program code to be copied. Instead the program works directly with the object instance in the first PLC. Both PLCs must be in a Twin CAT runtime. In this connection a function block offers its methods system-wide via a globally defined interface and represents itself a Tc COM object. As is the case with every Tc COM object, such a function block is also listed at runtime in the Tc COM Objects node. The procedure is explained in the following sub-chapters: • Creating an FB in the first PLC that provides its functionality globally [} 38] • Creating an FB in the second PLC that, as a simple proxy, also offers this functionality there [} 42] TE1000 Version: 1.4.1 37
## Page 38

Samples • Execution of the sample project [} 45] Downloading the sample: https://infosys.beckhoff.com/content/1033/Tc Plc Lib_Tc3_Module/Resources/ 2343046667.zip Race Conditions in the case of Multi-Tasking (Multi-Threading) use The function block that provides its functionality globally is instantiated in the first PLC. It can be used there like any function block. In addition, if it is used from a different PLC (or, for example, from a C++ module), make sure that the methods offered are thread-safe, as the various calls could take place simultaneously from different task contexts or mutually interrupt one another, depending on the system configuration. In this case the methods must not access member variables of the function block or global variables of the first PLC. If this should be absolutely necessary, prevent simultaneous access. Observe the function Test And Set() from the Tc2_System library. System requirements Twin CAT version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 7.1.1 Creating an FB in the first PLC which provides its functionality globally 1. Create a PLC and a new function block (FB) (in this case: FB_Calculation). Derive the function block from the Tc Base Module Registered [} 9] class so that an instance of the function block is available not only in the same PLC but also in a second one. As an alternative, you can modify an FB in an existing PLC. 2. The function block must provide its functionality through methods. These are defined in a global interface whose type is known system-wide and regardless of the programming language. To create a global interface, open the context menu in the “Interface” tab of System Properties and select “New”. ð The TMC Editor opens to help create a global interface. 38 Version: 1.4.1 TE1000
## Page 39

Samples 3. Enter the name (in this case: I_Calculation) and append the desired methods. The interface is automatically derived from ITc Unknown to comply with the Twin CAT Tc COM module concept. 4. Enter the names of the methods (in this case: Addition() and Subtraction()) and select HRESULT as return data type. This return type is mandatory if this type of Tc COM communication is to be implemented. 5. Finally, specify the method parameters and close the TMC Editor. TE1000 Version: 1.4.1 39
## Page 40

Samples 6. Now implement the I_Calculation interface in the FB_Calculation function block and append the “c+ +_compatible” attribute. 7. Choose the “Implement interfaces...” option in the context menu of the function block in order to obtain the methods belonging to this interface. 40 Version: 1.4.1 TE1000
## Page 41

Samples 8. Delete the two methods Tc Add Ref() and Tc Release() because the existing implementation of the base class is to be used. 9. Create the FB_reinit() method for the FB_Calculation function block and call the basic implementation. This ensures that the FB_reinit() method of the base class will run during the online change. This is imperative. TE1000 Version: 1.4.1 41
## Page 42

Samples 10. Implement the Tc Query Interface() method of the Interface ITc Unknown [} 74]. This method enables other Twin CAT components to obtain an interface pointer to an instance of this function block, allowing them to perform method calls. Calling Tc Query Interface is successful if the function block or its base class provides the interface requested by means of iid (Interface ID). In this case, the interface pointer that was handed over is allocated an address to the function block with its type changed and the reference counter is also incremented using Tc Add Ref(). 11. Add the corresponding code to the Addition() and Subtraction() methods to provide the functionality: n Res := n In1 + n In2 and n Res := n In1 - n In2 12. Add one or more instances of this function block to the MAIN program block or to a global variable list. ð The implementation in the first PLC is complete. ð After compiling the PLC, the object ID of the Tc COM object representing the FB_Calculation instance is available as an outlet in the process image. 7.1.2 Creating an FB which likewise offers this functionality there as a simple proxy in the second PLC, 1. Create a PLC and append a new function block there. ð This proxy function block should provide the functionality which was programmed in the first PLC. It does this via an interface pointer of the type of the global interface I_Calculation. 42 Version: 1.4.1 TE1000
## Page 43

Samples 2. In the declaration part of the function block declare as an output an interface pointer to the global interface which later provides the functionality outward. 3. In addition create the object ID and the interface ID as local member variables. While the interface ID is already available via a global list, the object ID is assigned via a link in the process image. TE1000 Version: 1.4.1 43
## Page 44

Samples 4. Implement the PLC proxy function block. First add the Get Interface Pointer() method to the function block. The interface pointer is fetched to the specified interface of the specified Tc COM object with the help of the FW_Obj Mgr_Get Object Instance() [} 25] function. This will only be executed if the object ID is valid and the interface pointer has not already been allocated. The object itself increments a reference counter. 5. It is imperative to release the used reference again. To this end call the FW_Safe Release() function in the FB_exit destructor of the function block. ð This completes the implementation of the Proxy function block. 6. Instantiate the Proxy function block FB_Calculation Proxy in the application and call its method Get Interface Pointer() to get a valid interface pointer. An instance of the proxy block is declared in the application to call the methods provided via the interface. The calls themselves take all place over the interface pointer defined as output of the function block. As is typical for pointers a prior null check must be made. Then the methods can be called directly, also via Intellisense. 44 Version: 1.4.1 TE1000
## Page 45

Samples ð The sample is ready for testing. Order irrelevant The sequence in which the two PLCs start later is irrelevant in this implementation. 7.1.3 Execution of the sample project 1. Select the destination system and compile the project. 2. Enable the Twin CAT configuration and execute a log-in and start both PLCs. ð In the online view of the PLC application “Provider” the generated object ID of the C++ object can be seen in the PLC function block FB_Calculation. The project node “Tc COM Objects” keeps the generated object with its object ID and the selected name in its list. TE1000 Version: 1.4.1 45
## Page 46

Samples ð In the online view of the PLC application “Caller” the Proxy function block has been allocated the same object ID via the process image. The interface pointer has a valid value and the methods are executed. 46 Version: 1.4.1 TE1000
## Page 47

Samples 7.2 Tc COM_Sample02_Plc To Cpp This sample describes a Tc COM communication between PLC and C++. In this connection a PLC application uses functionalities of an existing instance of a Twin CAT C++ class. In this way own algorithms written in C++ can be used easily in the PLC. Although in the event of the use of an existing Twin CAT C++ module the Twin CAT C++ license is required on the target system, a C++ development environment is not necessary on the target system or on the development computer. An already built C++ module provides one or more classes whose interfaces are deposited in the TMC description file and thus are known in the PLC. The procedure is explained in the following sub-chapters: 1. Instantiating a Twin CAT C++ class as a Twin CAT Tc COM Object [} 47] 2. Creating an FB in the PLC, which as a simple wrapper offers the functionality of the C++ object [} 48] 3. Execution of the sample project [} 50] Download the sample: https://infosys.beckhoff.com/content/1033/Tc Plc Lib_Tc3_Module/Resources/ 2343048971.zip System requirements Twin CAT version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64 Tc3_Module 7.2.1 Instantiating a Twin CAT++ class as a Twin CAT Tc COM Object The binary Twin CAT C++ project must be available on the engineering system so that it can be transferred to the target system together with the PLC project during activation. Twin CAT offers a deployment mechanism for the distribution between engineering systems, which is described at Versioned C++ projects. (This sample includes in the download the corresponding TMX, because Twin CAT places them automatically in the archive, if the Class Factory is used.) 1. Open a Twin CAT project or create a new project. 2. Add an instance of Class CIncrement Module in the solution under the Tc COM Objects node. Creation of the C++ modules In the documentation for Twin CAT C++ there is a detailed explanation on how C++ modules for Twin CAT are created. TE1000 Version: 1.4.1 47
## Page 48

Samples 7.2.2 Creating an FB in the PLC that, as a simple proxy, offers the functionality of the C++ object 1. Create a PLC and append a new function block there. This Proxy function block should provide the functionality that was programmed in C++. It is able to do this via an interface pointer that was defined from the C++ class and is known in the PLC due to the TMC description file. 2. In the declaration part of the function block declare as an output an interface pointer to the interface which later provides the functionality outward. 3. Create the object ID and the interface ID as local member variables. While the interface ID is already available via a global list, the object ID is allocated via the Twin CAT symbol initialization. The Tc Init Symbol attribute ensures that the variable appears in a list for external symbol initialization. The object ID of the created C++ object should be allocated. 48 Version: 1.4.1 TE1000
## Page 49

Samples ð The object ID is displayed upon selection of the object under the Tc COM Objects node. Provided the Tc Init Symbol attribute was used, the list of symbol initializations is located in the node of the PLC instance in the Symbol Initialization tab. 4. Here, assign an existing object ID to the symbol name of the variable by drop-down. This value is assigned when the PLC is downloaded so it can be defined prior to the PLC run-time. New symbol initializations or changes are accordingly entered with a new download of the PLC. As an alternative, the passing of the object ID could also be implemented by means of process image linking as implemented in the first sample (Tc COM_Sample01_Plc To Plc [} 37]). 5. Implement the PLC Proxy function block. First the FB_init constructor method is added to the function block. For the case that it is no longer an Online Change but rather the initialization of the function block, the interface pointer to the specified interface of the specified Tc COM object is obtained with the help of the function TE1000 Version: 1.4.1 49
## Page 50

Samples FW_Obj Mgr_Get Object Instance() [} 25]. In this connection the object itself increments a reference counter. 6. It is imperative to release the used reference again. To this end call the FW_Safe Release() function [} 26] in the FB_exit destructor of the function block. ð This completes the implementation of the Proxy function block. 7. Declare an instance of the Proxy function block to call the methods provided via the interface in the application. The calls themselves take all place over the interface pointer defined as output of the function block. As is typical for pointers a prior null check must be made. Then the methods can be called directly, also via Intellisense. ð The sample is ready for testing. 7.2.3 Execution of the sample project 1. Select the target system and compile the project. 2. Enable the Twin CAT configuration, then log in and start the PLC. 50 Version: 1.4.1 TE1000
## Page 51

Samples 3. This C++ Tc COM module requires Windows Test Mode. Activate this to use the module and thus the example. 4. When activating the Twin CAT configuration for the first time, the test certificate must be accepted: ð In the online view of the PLC application, the assigned object ID of the C++ object is indicated in the PLC Proxy function block. The interface pointer has a valid value and the method will be executed. 7.3 Tc COM_Sample03_Plc Creates Cpp Just like Sample02, this sample describes a Tc COM communication between PLC and C++. To this end a PLC application uses functionalities of a Twin CAT C++ class. The required instances of this C++ class will be created by the PLC itself in this sample. In this way own algorithms written in C++ can be used easily in the PLC. Although in the event of the use of an existing Twin CAT C++ driver the Twin CAT C++ license is required on the destination system, a C++ development environment is not necessary on the destination system or on the development computer. An already built C++ driver provides one or more classes whose interfaces are deposited in the TMC description file and thus are known in the PLC. The procedure is explained in the following sub-chapters: TE1000 Version: 1.4.1 51
## Page 52

Samples 1. Provision of a Twin CAT C++ driver and its classes [} 52] 2. Creating an FB in the PLC that creates the C++ object and offers its functionality [} 53] 3. Execution of the sample project [} 55] Downloading the sample: https://infosys.beckhoff.com/content/1033/Tc Plc Lib_Tc3_Module/Resources/ 2343051531.zip System requirements Twin CAT version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64 Tc3_Module 7.3.1 Provision of the binary C++ project (TMX) and its classes The binary Twin CAT C++ project must be available on the engineering system so that it can be transferred to the target system together with the PLC project during activation. Twin CAT offers a deployment mechanism for distribution between engineering systems, which is described at Versioned C++ Projects. (This sample includes in the download the corresponding TMX, because Twin CAT places them automatically in the archive, if the Class Factory is used.) Open a Twin CAT project or create a new project. 1. Select the required C++ driver in the solution under the Tc COM Objects node in the Class Factories tab. The checkbox can also be set automatically by Twin CAT if you implement this accordingly (as in the sample here). ð This ensures that the driver is transferred and loaded on the target system when Twin CAT is started. Creation of the binary C++ project The documentation for Twin CAT C++ explains in detail how to create the TMX. For Sample03 it should be noted that Twin CAT C++ modules whose classes are to be dynamically instantiated must be defined as "Twin CAT Module Class for RT Context". The C++ wizard offers a special template for this purpose. Furthermore, this sample uses a Twin CAT C++ class that does without Tc COM initialization data and without Tc COM parameters. 52 Version: 1.4.1 TE1000
## Page 53

Samples 7.3.2 Creating an FB in the PLC that creates the C++ object and offers its functionality 1. Create a PLC and append a new function block there. This Proxy function block should provide the functionality that was programmed in C++. It manages this via an interface pointer that was defined by C++ and is known in the PLC due to the TMC description file. 2. In the declaration part of the function block declare as an output an interface pointer to the interface (IIncrement) which later provides the functionality outward. 3. Create a library ID, class ID, and the interface ID as member variables, as shown in the previous step. While the interface ID is already available via a global list, the library ID and the class ID, provided they are not yet supposed to be known, are determined by other means. One possible way to do this is to create an instance temporarily and take the information from the dialog before it can be deleted again: TE1000 Version: 1.4.1 53
## Page 54

Samples 4. Add the FB_init constructor method to the PLC Proxy function block. For the case, that it is not an online change but rather the initialization of the function block, a new Tc COM object (Class instance of the specified class) is created and the interface pointer to the specified interface is obtained. First, the versioned class ID is calculated from the library ID and the class ID using the F_Get Class Id Versioned() method. Then the used FW_Obj Mgr_Create And Init Instance() function [} 23] is also given the name and the target state of the Tc COM object. These two parameters are declared here as input parameters of the FB_init method, whereby they are to be specified in the instantiation of the Proxy function block. The Twin CAT C++ class to be instantiated does without Tc COM initialization data and without Tc COM parameters. With this function call the object itself counts up a reference counter. 5. It is imperative to release the used reference again and to delete the object, provided it is no longer being used. To this end call the FW_Obj Mgr_Delete Instance() function [} 25] in the FB_exit destructor of the function block. ð This completes the implementation of the Proxy function block. 6. Declare an instance of the Proxy function block to call the methods provided via the interface in the application. The calls themselves take all place over the interface pointer defined as output of the function block. As is typical for pointers a prior null check must be made. Then the methods can be called directly, also via Intellisense. ð The sample is ready for testing. 54 Version: 1.4.1 TE1000
## Page 55

Samples 7.3.3 Execution of the sample project 1. Select the target system and compile the project. 2. Enable the Twin CAT configuration, then log in and start the PLC. 3. This C++ Tc COM module requires Windows Test Mode. Activate this to use the module and thus the example. 4. When activating the Twin CAT configuration for the first time, the test certificate must be accepted: ð In the online view of the PLC application, the desired Tc COM object name is indicated in the PLC Proxy function block. The project node Tc COM objects contains the generated object with the generated ID and the desired name in its list. The interface pointer has a valid value and the method will be executed. 7.4 Tc COM_Sample13_Cpp To Plc Description This sample provides for communication from a C++ module to a function block of a PLC by means of method call. To this end a Tc COM interface is defined that is offered by the PLC and used by the C++ module. The PLC page as a provider in the process corresponds to the corresponding project of the Tc COM Sample 01 [} 37], where an PLC is considered after PLC communication. Here a Caller is now provided in C++, which uses the same interface. TE1000 Version: 1.4.1 55
## Page 56

Samples You can find the explanation of the sample in the sub-chapter “Implementation of the sample”. Downloading the sample: Tc COM_Sample13_Cpp To Plc.zip System requirements Twin CAT version Hardware PLC libraries to be linked Twin CAT 3.1, Build 4020 x86, x64 Tc3_Module 7.4.1 Implementation of the sample The PLC page adopted by Tc COM Sample 01 [} 37]. The function block registered there as Tc COM module offers the object ID allocated to it as an output variable. It is the C++ module’s task to make the offered interface of this function block accessible. ü A C++ project with a Cycle IO module is assumed. 1. In the TMC editor, create an interface pointer of the type I_Calculation with the name Calculationn). Later access occurs via this. 56 Version: 1.4.1 TE1000
## Page 57

Samples 2. The Data Area Inputs have already been created by the module wizard with the type Input-Destination. Here in the TMC editor you create an input of the type OTCID with the name oid Provider, via which the Object ID will be linked from the PLC later. 3. All other symbols are irrelevant for the sample and can be deleted. ð The TMC-Code-Generator prepares the code accordingly. In the header of the module some variables are created in order to carry out the methods calls later. In the actual code of the module in Cycle Update() the interface pointer is set using the object ID transmitted from the PLC. It is important that this happens in the Cycle Update() and thus in real-time context, since the PLC must first provide the function block. When this has taken place once, the methods can be called. TE1000 Version: 1.4.1 57
## Page 58

Samples In addition, as can be seen above, the interface pointer is cleared when the program shuts down. This happens in the Set Obj State OS method. 4. Now build the C++ project. 5. Create an instance of the module. 6. Connect the input of the C++ module to the output of the PLC. ð The project can be started. When the PLC is running, the OID is made known through the mapping to the C++ instance. Once this has occurred, the method can be called. 58 Version: 1.4.1 TE1000
## Page 59

Appendix 8 Appendix 8.1 Tc COM Technology The Twin CAT module concept is one of the core elements for the modularization of modern machines. This chapter describes the modular concept and working with modules. 8.1.1 The Twin CAT Component Object Model (Tc COM) concept The Twin CAT Component Object Model defines the characteristics and the behavior of the modules. The model derived from the "Component Object Model" COM from Microsoft Windows describes the way in which various independently developed and compiled software components can co-operate with one another. To make that possible, a precisely defined mode of behavior and the observation of interfaces of the module must be defined, so that they can interact. Such an interface is also ideal for facilitating interaction between modules from different manufacturers, for example. To some degree Tc COM is based on COM (Component Object Model of the Microsoft Windows world), although only a subset of COM is used. In comparison with COM, however, Tc COM contains additional definitions that go beyond COM, for example the state machine module. Overview and application of Tc COM modules This introductory overview is intended to make the individual topics easier to understand. One or several Tc COM modules are consolidated in a driver. This driver is created by Twin CAT Engineering using the MSVC compiler. The modules and interfaces are described in a TMC (Twin CAT Module Class) file. The drivers and their TMC file can now be exchanged and combined between the engineering systems. Instances of these modules are now created using the engineering facility. They are associated with a TMI file. The instances can be parameterized and linked with each other and with other modules to form the IO. A corresponding configuration is transferred to the target system, where it is executed. Corresponding modules are started, which register with the Twin CAT Object Server. The Twin CAT XAR also provides the process images. Modules can query the Twin CAT Object Server for a reference to another object with regard to a particular interface. If such a reference is available, the interface methods can be called on the module instance. The following sections substantiate the individual topics. ID Management Different types of ID are used for the interaction of the modules with each other and also within the modules. Tc COM uses GUIDs (128 bit) and 32 bit long integers. TE1000 Version: 1.4.1 59
## Page 60

Appendix Tc COM uses • GUIDs for: Modul IDs, Class IDs and Interface IDs. • 32 bit long integers are used for: Parameter IDs, Object IDs, Context IDs, Category ID. Interfaces An important component of COM, and therefore of Tc COM too, is interfaces. Interfaces define a set of methods that are combined in order to perform a certain task. An interface is referenced with a unique ID (Interface ID), which must never be modified as long as the interface does not change. This ID enables modules to determine whether they can cooperate with other modules. At the same time the development process can take place independently, if the interfaces are clearly defined. Modifications of interfaces therefore lead to different IDs. The Tc COM concept is designed such that Interface IDs can superpose other (older) Interface IDs ( "Hides" in the TMC description / TMC editor). In this way, both versions of the interface are available, while on the other hand it is always clear which is the latest Interface ID. The same concept also exists for the data types. Tc COM itself already defines a whole series of interfaces that are prescribed in some cases (e.g. ITCom Object), but are optional in most. Many interfaces only make sense in certain application areas. Other interfaces are so general that they can often be re-used. Provision is made for customer-defined interfaces, so that two third-party modules can interact with each other, for example. • All interfaces are derived from the basic interface Itc Unknown which, like the corresponding interface of COM, provides the basic services for querying other interfaces of the module (Tc Query Interface) and for controlling the lifetime of the module (Tc Add Ref and Tc Release). • The ITCom Object interface, which must be implemented by each module, contains methods for accessing the name, Object ID, Object ID of the parent, parameters and state machine of the module. Several general interfaces are used by many modules: • ITc Cyclic is implemented by modules, which are called cyclically ("Cycle Update"). The module can register via the ITc Cyclic Caller interface of a Twin CAT task to obtain cyclic calls. • The ITc ADI interface can be used to access data areas of a module. • ITc Watch Source is implemented by default; it facilitates ADS device notifications and other features. • The ITc Task interface, which is implemented by the tasks of the real-time system, provides information about the cycle time, the priority and other task information. • The ITCom Object Server interface is implemented by the Object Server and referenced by all modules. A whole series of general interfaces has already been defined. General interfaces have the advantage that their use supports the exchange and recycling of modules. User-defined interfaces should only be defined if no suitable general interfaces are available. Class Factories "Class Factories" are used for creating modules in C++. All modules contained in a driver have a common Class Factory. The Class Factory registers once with the Object Server and offers its services for the development of certain module classes. The module classes are identified by the unique Class ID of the module. When the Object Server requests a new module (based on the initialization data of the configurator or through other modules at runtime), the module selects the right Class Factory based on the Class ID and triggers creation of the module via its ITc Class Factory interface. Module service life Similar to COM, the service life of a module is determined via a reference counter (Ref Counter). The reference counter is incremented whenever a module interface is queried. The counter is decremented when the interface is released. An interface is also queried when a module logs into the Object Server (the ITCom Object interface), so that the reference counter is at least 1. The counter is decremented on logout. When the counter reaches 0, the module deletes itself automatically, usually after logout from the Object Server. If another module already maintains a reference (has an interface pointer), the module continues to exist, and the interface pointer remains valid, until this pointer is released. 60 Version: 1.4.1 TE1000
## Page 61

Appendix 8.1.1.1 Twin CAT module properties A Tc COM module has a number of formally defined, prescribed and optional properties. The properties are sufficiently formalized to enable interchangeable application. Each module has a module description, which describes the module properties. They are used for configuring the modules and their relationships with each other. If a module is instantiated in the Twin CAT runtime, it registers itself with a central system instance, the Object Server. This makes it reachable and parameterizable for other modules and also for general tools. Modules can be compiled independently and can therefore also be developed, tested and updated independently. Modules can be very simple, e.g. they may only contain a basic function such as low-pass filter. Or they may be very complex internally and contain the whole control system for a machine subassembly. There are a great many applications for modules; all tasks of an automation system can be specified in modules. Accordingly, no distinction is made between modules, which primarily represent the basic functions of an automation system, such as real-time tasks, fieldbus drivers or a PLC runtime system, and user- or application-specific algorithms for controlling a machine unit. The diagram below shows a common Twin CAT module with his main properties. The dark blue blocks define prescribed properties, the light blue blocks optional properties. TE1000 Version: 1.4.1 61
## Page 62

Appendix Module description Each Tc COM module has some general description parameters. These include a Class ID, which unambiguously references the module class. It is instantiated by the corresponding Class Factory. Each module instance has an Object ID, which is unique in the Twin CAT runtime. In addition there is a parent Object ID, which refers to a possible logical parent. The description, state machine and parameters of the module described below can be reached via the ITCom Object interface (see "Interfaces"). Class description files (*.tmc) The module classes are described in class description files (Twin CAT Module Class; *.tmc). These files are used by developers to describe the module properties and interfaces, so that others can use and embed the module. In addition to general information (vendor data, module class ID etc.), optional module properties are described. 62 Version: 1.4.1 TE1000
## Page 63

Appendix • Supported categories • Implemented interfaces • Data areas with corresponding symbols • Parameter • Interface pointers • Data pointers, which can be set The system configurator uses the class description files mainly as a basis for the integration of a module instance in the configuration, for specifying the parameters and for configuring the links with other modules. They also include the description of all data types in the modules, which are then adopted by the configurator in its general data type system. In this way, all interfaces of the TMC descriptions present in the system can be used by all modules. More complex configurations involving several modules can also be described in the class description files, which are preconfigured and linked for a specific application. Accordingly, a module for a complex machine unit, which internally consists of a number of submodules, can be defined and preconfigured as an entity during the development phase. Instance description files (*.tmi) An instance of a certain module is described in the instance description file (Twin CAT Module Instance; *.tmi). The instance descriptions are based on a similar format, although in contrast to the class description files they already contain concrete specifications for the parameters, interface pointers etc. for the special module instance within a project. The instance description files are created by Twin CAT Engineering (XAE), when an instance of a class description is created for a specific project. They are mainly used for the exchange of data between all tools involved in the configuration. However, the instance descriptions can also be used cross-project, for example if a specially parameterized module is to be used again in a new project. State machine Each module contains a state machine, which describes the initialization state of the module and the means with which this state can be modified from outside. The state machine describes the states, which occur during starting and stopping of the module. This relates to module creation, parameterization and production in conjunction with the other modules. Application-specific states (e.g. of the fieldbus or driver) can be described in their own state machines. The state machine of the Tc COM modules defines the states INIT, PREOP, SAFEOP and OP. Although the state designations are the same as under Ether CAT fieldbus, the actual states differ. When the Tc COM module implements a fieldbus driver for Ether CAT, it has two state machines (module and fieldbus state machine), which are passed through sequentially. The module state machine must have reached the operating state (OP) before the fieldbus state machine can start. The state machine is described [} 68] in detail separately. TE1000 Version: 1.4.1 63
## Page 64

Appendix Parameter Modules can have parameters, which can be read or written during initialization or later at runtime (OP state). Each parameter is designated by a parameter ID. The uniqueness of the parameter ID can be global, limited global or module-specific. Further details can be found in the "ID Management" section. In addition to the parameter ID, the parameter contains the current data; the data type depends on the parameter and is defined unambiguously for the respective parameter ID. Interfaces 64 Version: 1.4.1 TE1000
## Page 65

Appendix Interfaces consist of a defined set of methods (functions), which offer modules through which they can be contacted by other modules. Interfaces are characterized by a unique ID, as described above. A module must support at least the ITCom Object interface and may in addition contain as many interfaces as required. An interface reference can be queried by calling the method "Tc Query Interface" with specification of the corresponding interface ID. Interface pointers Interface pointers behave like the counterpart of interfaces. If a module wants to use an interface of another module, it must have an interface pointer of the corresponding interface type and ensure that it points to the other module. The methods of the other module can then be used. Interface pointers are usually set on startup of the state machine. During the transition from INIT to PREOP (IP), the module receives the object ID of the other modules with the corresponding interface; during the transition from PREOP to SAFEOP (PS) or SAFEOP to OP (SO), the instance of the other modules is searched with the Object Server, and the corresponding interface is set with the Method Query interface. During the state transition in the opposite direction, i.e. from SAFEOP to PREOP (SP) or OP to SAFEOP (OS), the interface must be enabled again. Data areas Modules can contain data areas, which can be used by the environment (e.g. by other modules or the IO area of Twin CAT). These data areas can contain any data. They are often used for process image data (inputs and outputs). The structure of the data areas is defined in the device description of the module. If a module has data areas, which it wants to make accessible for other modules, it implements the ITc ADI interface to enable access to the data. Data areas can contain symbol information, which describes the structure of the respective data area in more detail. TE1000 Version: 1.4.1 65
## Page 66

Appendix Data area pointer If a module wants to access the data area of other modules, it can contain data area pointers. These are normally set during initialization of the state machine to data areas or data area sections of other modules. The access is directly to the memory area, so that corresponding protection mechanisms for competing access operations have to be implemented, if necessary. In many cases it is preferable to use a corresponding interface. Context The context should be regarded as real-time task context. Context is required for the configuration of the modules, for example. Simple modules usually operate in a single time context, which therefore requires no detailed specification. Other modules may partly be active in several contexts (e.g. an Ether CAT master can support several independent real-time tasks, or a control loop can process control loops of the layer below in another cycle time). If a module has more than one time-dependent context, this must be specified the in the module description. 66 Version: 1.4.1 TE1000
## Page 67

Appendix Categories Modules can offer categories by implementing the interface ITCom Object Category. Categories are enumerated by the Object Server, and objects, which use this to associated themselves with categories, can be queried by the Object Server (ITCom Object Enum Ptr). ADS Each module that is entered in the Object Server can be reached via ADS. The Object Server uses the ITCom Object interface of the modules in order to read or write parameters or to access the state machine, for example. In addition, a dedicated ADS port can be implemented, through which dedicated ADS commands can be received. TE1000 Version: 1.4.1 67
## Page 68

Appendix System module In addition, the Twin CAT runtime provides a number of system modules, which make the basic runtime services available for other modules. These system modules have a fixed, constant Object ID, through which the other modules can access it. An example for such a system module is the real-time system, which makes the basic real-time system services, i.e. generation of real-time tasks, available via the ITc RTime interface. The ADS router is also implemented as a system module, so that other modules can register their ADS port here. Creation of modules Modules can be created both in C++ and in IEC 61131-3. The object-oriented extensions of the Twin CAT PLC are used for this purpose. Modules from both worlds can interact via interfaces in the same way as pure C++ modules. The object-oriented extension makes the same interfaces available as in C++. The PLC modules also register via the Object Server and can therefore be reached through it. PLC modules vary in terms of complexity. It makes no difference whether only a small filter module is generated or a complete PLC program is packed into a module. Due to the automation, each PLC program is a module within the meaning of Twin CAT modules. Each conventional PLC program is automatically packed into a module and registers itself with the Object Server and one or several task modules. Access to the process data of a PLC module (e.g. mapping with regard to a fieldbus driver) is also controlled via the defined data areas and ITc ADI. This behavior remains transparent and invisible for PLC programmers, as long as they decide to explicitly define parts of the PLC program as Twin CAT modules, so that they can be used with suitable flexibility. 8.1.1.2 Twin CAT module state machine In addition to the states (INIT, PREOP, SAFEOP and OP), there are corresponding state transitions, within which general or module-specific actions have to be executed or can be executed. The design of the state machine is very simple. In any case, there are only transitions to the next or previous step. This results in the state transitions: INIT to PREOP (IP), PREOP to SAFEOP (PS) and SAFEOP to OP (SO). In the opposite direction, the following state transitions exist: OP to SAFEOP (OS), SAFEOP to PREOP (SP) and PREOP to INIT (PI). Up to and including the SAFEOP state, all states and state transitions take place within the non-real-time context. Only the transition from SAFEOP to OP, the OP state and the transition from OP to SAFEOP take place in the real-time context. This differentiation is relevant when resources are allocated or enabled, or when modules register or deregister with other modules. 68 Version: 1.4.1 TE1000
## Page 69

Appendix State: INIT The INIT state is only a virtual state. Immediately after creation of a module, the module changes from INIT to PREOP, i.e. the IP state transition is executed. The instantiation and the IP state transition always take place together, so that the module never remains in INIT state. Only when the module is removed does it remain in INIT state for a short time. Transition: INIT to PREOP (IP) During the IP state transition, the module registers with the Object Server with its unique Object ID. The initialization parameters, which are also allocated during object creation, are transferred to the module. During this transition the module cannot establish connections to other modules, because it is not clear whether the other modules already exist and are registered with the Object Server. When the module requires system resources (e.g. memory), these can be allocated during the state transition. All allocated resources have to be released again during the transition from PREOP to INIT (PI). State: PREOP In PREOP state, module creation is complete and the module is usually fully parameterized, even if further parameters may be added during the transition from PREOP to SAFEOP. The module is registered in the Object Server, although no connections with other modules have been created yet. Transition: PREOP to SAFEOP (PS) In this state transition the module can establish connections with other modules. To this end it has usually received, among other things, Object IDs of other modules with the initialization data, which are now converted to actual connections with these modules via the Object Server. The transition can generally be triggered by the system according to the configurator, or by another module (e.g. the parent module). During this state transition further parameters can be transferred. For example, the parent module can transfer its own parameters to the child module. State: SAFEOP The module is still in the non-real-time context and is waiting to be switched to OP state by the system or by other modules. Transition: SAFEOP to OP (SO) The state transition from SAFEOP to OP, the state OP, and the transition from OP to SAFEOP take place in the real-time context. System resources may no longer be allocated. On the other hand, resources can now be requested by other modules, and modules can register with other modules, e.g. in order to obtain a cyclic call during tasks. This transition should not be used for long-running tasks. For example, file operations should be executed during PS. State: OP In OP state the module starts working and is fully active in the meaning of the Twin CAT system. Transition: OP to SAFEOP (OS) This state transition takes place in the real-time context. All actions from the SO transition are reversed, and all resources requested during the SO transition are released again. Transition: SAFEOP to PREOP (SP) All actions from the PS transition are reversed, and all resources requested during the PS transition are released again. TE1000 Version: 1.4.1 69
## Page 70

Appendix Transition: PREOP to INIT (PI) All actions from the IP transition are reversed, and all resources requested during the IP transition are released again. The module signs off from the Object Server and usually deletes itself (see "Service life"). 8.2 Interfaces 8.2.1 Interface ITCom Object The ITCom Object interface is implemented by every Twin CAT module. It makes basic functionalities available. Syntax TCOM_DECL_INTERFACE("00000012-0000-0000-e000-000000000064", ITCom Object) struct__declspec(novtable) ITCom Object: public ITc Unknown Methods Name Description Tc Get Object Id(OTCID& obj Id) Saves the object ID using the given OTCID reference. [} 70] Tc Set Object Id [} 71] Sets the object ID of the object to the given OTCID. Tc Get Object Name [} 71] Saves the object names in the buffer with the given length. Tc Set Object Name [} 71] Sets the object name of the object to given CHAR*. Tc Set Obj State [} 72] Initializes a transition to a predefined state. Tc Get Obj State [} 72] Queries the current state of the object. Tc Get Obj Para [} 73] Queries an object parameter identified with its PTCID. Tc Set Obj Para [} 73] Sets an object parameter identified with its PTCID. Tc Get Parent Obj Id [} 74] Saves the parent object ID with the help of the given OTCID reference. Tc Set Parent Object [} 74] Sets the parent object ID to the given OTCID. Comments The ITCom Object interface is implemented by every Twin CAT module. It makes functionalities available regarding the state machine and Information from/to the Twin CAT system. 8.2.1.1 Method ITc Com Object:Tc Get Object Id(OTCID& obj Id) The method saves the object ID with the help of the given OTCID reference. Syntax HRESULT Tc Get Object Id( OTCID& obj Id ) Parameter obj Id: (type: OTCID&) reference to OTCID value. Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 32]. 70 Version: 1.4.1 TE1000
## Page 71

Appendix Description The method stores Object ID using given OTCID reference. 8.2.1.2 Method ITc Com Object:Tc Set Object Id The method Tc Set Object Id sets object’s object ID to the given OTCID. Syntax HRESULT Tc Set Object Id( OTCID obj Id ) Parameters obj Id: (type: OTCID) The OTCID, which should be set. Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 32]. At present, the return value is ignored by the Twin CAT tasks. Description Indicates the success of the ID change. 8.2.1.3 Method ITc Com Object:Tc Get Object Name The method Tc Get Object Name stores the Object name into buffer with given length. Syntax HRESULT Tc Get Object Name( CHAR* obj Name, ULONG name Len ); Parameters obj Name: (type: CHAR*) the name, which should be set. name Len: (type: ULONG) the maximum length to write. Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 32]. Description The method Tc Get Object Name stores the Object name into buffer with given length. 8.2.1.4 Method ITc Com Object:Tc Set Object Name The method Tc Set Object Name sets objects’s Object Name to the given CHAR*. Syntax HRESULT Tc Set Object Name( CHAR* obj Name ) TE1000 Version: 1.4.1 71
## Page 72

Appendix Parameter obj Name: (type: CHAR*) the name of the object to be set. Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 32]. Description The method Tc Set Object Name sets objects’s Object Name to the given CHAR*. 8.2.1.5 Method ITc Com Object:Tc Set Obj State The method Tc Set Obj State initializes a transition to given state. Syntax HRESULT Tc Set Obj State(TCOM_STATE state, ITCom Object Server* ip Srv, PTCom Init Data Hdr p Init Data); Parameter state: (type: TCOM_STATE) displays the new state. ip Srv: (type: ITCom Object Server*) Obj Server that handles the object. p Init Data: (type: PTCom Init Data Hdr) points to a list of parameters (optional), see macro IMPLEMENT_ITCOMOBJECT_EVALUATE_INITDATA as an example of how the list can be iterated. Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 32]. Description The method Tc Set Obj State initializes a transition to given state. 8.2.1.6 Method ITc Com Object:Tc Get Obj State The method Tc Get Obj State retrieves the current state of the object. Syntax HRESULT Tc Get Obj State(TCOM_STATE* p State) Parameter p State: (type: TCOM_STATE*) pointer to the state. Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 32]. 72 Version: 1.4.1 TE1000
## Page 73

Appendix Description The Tc Get Obj State method queries the current state of the object. 8.2.1.7 Method ITc Com Object:Tc Get Obj Para The method Tc Get Obj Para retrieves a object parameter identified by its PTCID. Syntax HRESULT Tc Get Obj Para(PTCID pid, ULONG& n Data, PVOID& p Data, PTCGP pgp=0) Parameter pid: (type: PTCID) parameter ID of the object parameter. n Data: (type: ULONG&) max. length of the data. p Data: (type: PVOID&) pointer to the data. pgp: (type: PTCGP) reserved for future extension, NULL forwarded. Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 32]. Description The method Tc Get Obj Para retrieves a object parameter identified by its PTCID. 8.2.1.8 Method ITc Com Object:Tc Set Obj Para The method Tc Set Obj Para sets a object parameter identified by its PTCID. Syntax HRESULT Tc Set Obj Para(PTCID pid, ULONG n Data, PVOID p Data, PTCGP pgp=0) Parameter pid: (type: PTCID) parameter ID of the object parameter. n Data: (type: ULONG) max. length of the data. p Data: (type: PVOID) pointer to the data. pgp: (type: PTCGP) reserved for future extension, NULL forwarded. Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 32]. Description The method Tc Set Obj Para sets a object parameter identified by its PTCID. TE1000 Version: 1.4.1 73
## Page 74

Appendix 8.2.1.9 Method ITc Com Object:Tc Get Parent Obj Id The method Tc Get Parent Obj Id stores Parent Object ID using given OTCID reference. Syntax HRESULT Tc Get Parent Obj Id( OTCID& obj Id ) Parameter obj Id: (type: OTCID&) reference to OTCID value. Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 32]. Description The method Tc Get Parent Obj Id stores Parent Object ID using given OTCID reference. 8.2.1.10 Method ITc Com Object:Tc Set Parent Obj Id The method Tc Set Parent Obj Id sets Parent Object ID using given OTCID reference. Syntax HRESULT Tc Set Parent Obj Id( OTCID obj Id ) Parameter obj Id: (type: OTCID) reference to OTCID value. Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 32]. At present, the return value is ignored by the Twin CAT tasks. Description The method Tc Set Parent Obj Id sets Parent Object ID using given OTCID reference. 8.2.2 Interface ITc Unknown ITc Unknown defines the reference counting as well as querying a reference to a more specific interface. Syntax TCOM_DECL_INTERFACE("00000001-0000-0000-e000-000000000064", ITc Unknown) Declared in: Tc Interfaces.h Required include: - 74 Version: 1.4.1 TE1000
## Page 75

Appendix Methods Name Description Tc Add Ref [} 75] Increments the reference counter. Tc Query Interface [} 75] Query of the reference to an implemented interface via the IID. Tc Release [} 76] Decrements the reference counter. Remarks Every Tc COM interface is directly or indirectly derived from ITc Unknown. As a consequence every Tc COM module class implements ITc Unknown, because it is derived from ITCom Object. The default implementation for ITc Unknown will delete the object if its last reference is released. Therefore an interface pointer must not be dereferenced after Tc Release() has been called. 8.2.2.1 Method ITc Unknown:Tc Add Ref This method increments the reference counter. Syntax ULONG Tc Add Ref( ) Return Value Resulting reference count value. Description Increments the reference counter and returns the new value.. 8.2.2.2 Method ITc Unknown:Tc Query Interface Query of an interface pointer with regard to an interface that is given by interface ID (IID). Syntax HRESULT Tc Query Interface(RITCID iid, PPVOID pip Itf ) iid: (Type: RITCID) Interface IID. pip Itf: (PPVOID Type) pointer to interface pointer. Is set when the requested interface type is available from the corresponding instance. Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 32]. If the demanded interface is not available, the method returns ADSERR_DEVICE_NOINTERFACE. Description Query reference to an implemented interface by the IID. It is recommended to use smart pointers to initialize and hold interface pointers. Variant 1: HRESULT Get Trace Level(ITc Unkown* ip, Tc Trace Level& tl) { HRESULT hr = S_OK; if (ip != NULL) { ITCom Object Ptr sp Obj; TE1000 Version: 1.4.1 75
## Page 76

Appendix hr = ip->Tc Query Interface(sp Obj. Get IID(), &sp Obj); if (SUCCEEDED(hr)) { hr = sp Obj->Tc Get Obj Para(PID_Tc Trace Level, &tl, sizeof(tl)); } return hr; } } The interface id associated with the smart pointer can be used as parameter in Tc Query Interface. The operator “&” will return pointer to internal interface pointer member of the smart pointer. Variant 1 assumes that interface pointer is initialized if Tc Query Interface indicates success. If scope is left the destructor of the smart pointer sp Obj releases the reference. Variant 2: HRESULT Get Trace Level(ITc Unkown* ip, Tc Trace Level& tl) { HRESULT hr = S_OK; ITCom Object Ptr sp Obj = ip; if (sp Obj != NULL) { sp Obj->Tc Get Obj Param(PID_Tc Trace Level, &tl); } else { hr = ADS_E_NOINTERFACE; } return hr; } When assigning interface pointer ip to smart pointer sp Obj method Tc Query Interface is implicitly called with IID_ITCom Object on the instance ip refers to. This results in shorter code, however it loses the original return code of Tc Query Interface. 8.2.2.3 Method ITc Unknown:Tc Release This method decrements the reference counter. Syntax ULONG Tc Release( ) Return Value Resulting reference count value. Description Decrements the reference counter and returns the new value. If reference counter gets zero, object deletes itself. 76 Version: 1.4.1 TE1000
## Page 77

Trademark statements Beckhoff®, ATRO®, Ether CAT®, Ether CAT G®, Ether CAT G10®, Ether CAT P®, MX-System®, Safety over Ether CAT®, TC/BSD®, Twin CAT®, Twin CAT/BSD®, Twin SAFE®, XFC®, XPlanar® and XTS® are registered and licensed trademarks of Beckhoff Automation Gmb H. Third-party trademark statements Arm, Arm9 and Cortex are trademarks or registered trademarks of Arm Limited (or its subsidiaries or affiliates) in the US and/or elsewhere. Intel, the Intel logo, Intel Core, Xeon, Intel Atom, Celeron and Pentium are trademarks of Intel Corporation or its subsidiaries. Microsoft, Microsoft Azure, Microsoft Edge, Power Shell, Visual Studio, Windows and Xbox are trademarks of the Microsoft group of companies.
## Page 78

More Information: www.beckhoff.com/te1000 Beckhoff Automation Gmb H & Co. KG Hülshorstweg 20 33415 Verl Germany Phone: +49 5246 9630 info@beckhoff.com www.beckhoff.com
