---
title: "TF6311 Twin CAT 3"
product: "TF6311"
category: "Communication"
tags: ["CAT", "TWIN"]
language: "EN"
document_type: "Manual"
version: "1.8.1"
source_pdf: "https://download.beckhoff.com/download/Document/automation/twincat3/TF6311_TC3_TCP_UDP_Realtime_EN.pdf"
release_date: "2024-06-18"
---
Manual | EN TF6311 Twin CAT 3 | TCP/UDP Realtime 2024-06-18 | Version: 1.8.1
## Page 3

Table of contents Table of contents 1 Foreword.................................................................................................................................................... 5 1.1 Notes on the documentation............................................................................................................. 5 1.2 For your safety.................................................................................................................................. 5 1.3 Notes on information security............................................................................................................ 7 2 Overview.................................................................................................................................................... 8 2.1 Comparison TF6310 TF6311............................................................................................................ 8 2.2 Restrictions....................................................................................................................................... 9 3 Installation / Licensing........................................................................................................................... 10 4 Quick Starts............................................................................................................................................. 11 4.1 Quick Start (PLC / UDP)................................................................................................................. 11 4.2 Quick Start (C++ / UDP).................................................................................................................. 16 4.3 Quick Start (C++ / TCP Client)........................................................................................................ 22 5 Configuration........................................................................................................................................... 33 5.1 Multiple network cards.................................................................................................................... 35 5.2 Multitask access to a network card................................................................................................. 36 6 Examples................................................................................................................................................. 38 6.1 S01: Simple TCP Client (PLC / C++).............................................................................................. 38 6.1.1 S01: Simple TCP Client (C++)......................................................................................... 38 6.1.2 S01: Simple TCP Client (PLC)......................................................................................... 39 6.2 S02: UDP Client Server (PLC/C++)................................................................................................ 40 6.2.1 S02: UDP Demo (PLC).................................................................................................... 40 6.2.2 S02: UDP Demo (C++).................................................................................................... 43 6.2.3 Test client......................................................................................................................... 44 6.3 S03: ARP PING Demo (C++).......................................................................................................... 45 6.4 S04: TCP Echo Server (PLC / C++)................................................................................................ 46 6.4.1 S04: TCP Server Demo (PLC)......................................................................................... 47 6.4.2 S04: TCP Server Demo (C++)......................................................................................... 49 7 Programmer's reference......................................................................................................................... 51 7.1 UDP/IP: ITc Io Udp Protocol(Recv).................................................................................................... 52 7.1.1 Method ITc Io Udp Protocol Recv:Receive Data................................................................... 53 7.1.2 Method ITc Io Udp Protocol:Send Data............................................................................... 53 7.1.3 Method ITc Io Udp Protocol:Check Received...................................................................... 54 7.1.4 Method ITc Io Udp Protocol:Register Receiver.................................................................... 54 7.1.5 Method ITc Io Udp Protocol:Unregister Receiver................................................................. 55 7.2 TCP/UDP RT Tc Com Parameter.................................................................................................... 55 7.3 TCP/UDP RT Tc Com diagnostics................................................................................................... 57 7.4 TCP/IP: ITc Io Tcp Protocol(Recv)..................................................................................................... 58 7.4.1 Method ITc Io Tcp Protocol Recv:Receive Data................................................................... 59 7.4.2 Method ITc Io Tcp Protocol Recv:Receive Event.................................................................. 60 7.4.3 Method ITc Io Tcp Protocol:Alloc Socket............................................................................. 60 7.4.4 Method ITc Io Tcp Protocol:Free Socket.............................................................................. 61 7.4.5 Method ITc Io Tcp Protocol:Connect................................................................................... 61 7.4.6 Method ITc Io Tcp Protocol:Is Connected............................................................................ 61 TF6311 Version: 1.8.1 3
## Page 4

Table of contents 7.4.7 Method ITc Io Tcp Protocol:Close....................................................................................... 62 7.4.8 Method ITc Io Tcp Protocol:Listen...................................................................................... 62 7.4.9 Method ITc Io Tcp Protocol:Accept..................................................................................... 62 7.4.10 Method ITc Io Tcp Protocol:Send Data................................................................................ 63 7.4.11 Method ITc Io Tcp Protocol:Check Received....................................................................... 63 7.4.12 Method ITc Io Tcp Protocol:Get Remote Ip Addr................................................................... 63 7.4.13 Method ITc Io Tcp Protocol:Get Free Send Data Size............................................................ 64 7.5 ARP/Ping: ITc Io Arp Ping Protocol(Recv).......................................................................................... 64 7.5.1 Method ITc Io Arp Ping Protocol Recv:Ping Reply................................................................. 65 7.5.2 Method ITc Io Arp Ping Protocol Recv:Arp Reply.................................................................. 65 7.5.3 Method ITc Io Arp Ping Protocol:Ping Request..................................................................... 66 7.5.4 Method ITc Io Arp Ping Protocol:Arp Request...................................................................... 66 7.5.5 Method ITc Io Arp Ping Protocol:Register Receiver.............................................................. 67 7.5.6 Method ITc Io Arp Ping Protocol:Unregister Receiver.......................................................... 67 7.5.7 Method ITc Io Arp Ping Protocol:Check Received................................................................ 68 7.6 Return values.................................................................................................................................. 68 8 Fault analysis.......................................................................................................................................... 69 8.1 Start-up: Ip Stack ADS 1823 / 0x71f............................................................................................... 69 9 Appendix.................................................................................................................................................. 70 9.1 ADS Return Codes.......................................................................................................................... 70 4 Version: 1.8.1 TF6311
## Page 5

Foreword 1 Foreword 1.1 Notes on the documentation This description is intended exclusively for trained specialists in control and automation technology who are familiar with the applicable national standards. For installation and commissioning of the components, it is absolutely necessary to observe the documentation and the following notes and explanations. The qualified personnel is obliged to always use the currently valid documentation. The responsible staff must ensure that the application or use of the products described satisfies all requirements for safety, including all the relevant laws, regulations, guidelines, and standards. Disclaimer The documentation has been prepared with care. The products described are, however, constantly under development. We reserve the right to revise and change the documentation at any time and without notice. No claims to modify products that have already been supplied may be made on the basis of the data, diagrams, and descriptions in this documentation. Trademarks Beckhoff®, Twin CAT®, Twin CAT/BSD®, TC/BSD®, Ether CAT®, Ether CAT G®, Ether CAT G10®, Ether CAT P®, Safety over Ether CAT®, Twin SAFE®, XFC®, XTS® and XPlanar® are registered and licensed trademarks of Beckhoff Automation Gmb H. If third parties make use of designations or trademarks used in this publication for their own purposes, this could infringe upon the rights of the owners of the said designations. Patents The Ether CAT Technology is covered, including but not limited to the following patent applications and patents: EP1590927, EP1789857, EP1456722, EP2137893, DE102015105702 and similar applications and registrations in several other countries. Ether CAT® is registered trademark and patented technology, licensed by Beckhoff Automation Gmb H, Germany Copyright © Beckhoff Automation Gmb H & Co. KG, Germany. The distribution and reproduction of this document as well as the use and communication of its contents without express authorization are prohibited. Offenders will be held liable for the payment of damages. All rights reserved in the event that a patent, utility model, or design are registered. 1.2 For your safety Safety regulations Read the following explanations for your safety. Always observe and follow product-specific safety instructions, which you may find at the appropriate places in this document. TF6311 Version: 1.8.1 5
## Page 6

Foreword Exclusion of liability All the components are supplied in particular hardware and software configurations which are appropriate for the application. Modifications to hardware or software configurations other than those described in the documentation are not permitted, and nullify the liability of Beckhoff Automation Gmb H & Co. KG. Personnel qualification This description is only intended for trained specialists in control, automation, and drive technology who are familiar with the applicable national standards. Signal words The signal words used in the documentation are classified below. In order to prevent injury and damage to persons and property, read and follow the safety and warning notices. Personal injury warnings DANGER Hazard with high risk of death or serious injury. WARNING Hazard with medium risk of death or serious injury. CAUTION There is a low-risk hazard that could result in medium or minor injury. Warning of damage to property or environment NOTICE The environment, equipment, or data may be damaged. Information on handling the product This information includes, for example: recommendations for action, assistance or further information on the product. 6 Version: 1.8.1 TF6311
## Page 7

Foreword 1.3 Notes on information security The products of Beckhoff Automation Gmb H & Co. KG (Beckhoff), insofar as they can be accessed online, are equipped with security functions that support the secure operation of plants, systems, machines and networks. Despite the security functions, the creation, implementation and constant updating of a holistic security concept for the operation are necessary to protect the respective plant, system, machine and networks against cyber threats. The products sold by Beckhoff are only part of the overall security concept. The customer is responsible for preventing unauthorized access by third parties to its equipment, systems, machines and networks. The latter should be connected to the corporate network or the Internet only if appropriate protective measures have been set up. In addition, the recommendations from Beckhoff regarding appropriate protective measures should be observed. Further information regarding information security and industrial security can be found in our https://www.beckhoff.com/secguide. Beckhoff products and solutions undergo continuous further development. This also applies to security functions. In light of this continuous further development, Beckhoff expressly recommends that the products are kept up to date at all times and that updates are installed for the products once they have been made available. Using outdated or unsupported product versions can increase the risk of cyber threats. To stay informed about information security for Beckhoff products, subscribe to the RSS feed at https:// www.beckhoff.com/secinfo. TF6311 Version: 1.8.1 7
## Page 8

Overview 2 Overview The “TCP/UDP Realtime” Function (TF6311) offers direct access to network cards from the real-time environment. Access can be either from the PLC (61131-3) or C++. The following protocols are supported: • TCP/IP • UDP/IP • ARP / Ping This section describes the concept of interfaces as API [} 51]. An introduction is provided by means of sample programs [} 38]. Regardless of the protocol, the communication between the project using the protocol and Twin CAT is realized with a pair of interfaces: • An Interface Pointer provides support for sending data and establishing connections etc. • The implementation of a receiver interface provides feedback for the project in the form of events or data, based on callbacks. The communication partner of these interface pairs is a “TCP/UDP RT” Tc Com object, which is instantiated and configured with the network card. • Depending on the protocol, the Quickstarts [} 11] provide a good introduction. • The configuration process is documented under Configuration [} 33]. • The interfaces are described in the Programmer’s reference [} 51] and illustrated through samples [} 38]. 2.1 Comparison TF6310 TF6311 The products TF6310 "TCP/IP" and TF6311 "TCP/UDP Realtime" offer similar functionality. This page provides an overview of similarities and differences of the products: 8 Version: 1.8.1 TF6311
## Page 9

Overview TF 6310 TF 6311 Twin CAT Twin CAT 2 / 3 Twin CAT 3 Client/Server Both Both Large / unknown networks ++ + Determinism + ++ High-volume data transfer ++ + Programming languages PLC PLC and C++ Operating system Win32/64, CE5/6/7 Win32/64, CE7 UDP-Mutlicast Yes No Trial license Yes Yes Protocols TCP, UDP TCP, UDP, Arp/Ping Hardware requirements Variable Twin CAT-compatible network card Socket configuration See operating system (Win Sock) TCP/UDP RT Tc Com Parameter [} 55] The Windows firewall cannot be used, since the TF6311 is directly integrated in the Twin CAT system. In larger / unknown networks we recommend using the TF6310. 2.2 Restrictions The following limitations exist for the product: • No local communication in real-time or between real-time and Windows operating system. (Alternative: communication via a second network interface.) • Multicast is not supported. • The EL6601 and EL6614 cannot be used for TF6311 TCP/UDP real-time. • If breakpoints are used, we strongly advise to use different network interfaces, since a breakpoint stops parts of the Twin CAT systems, which may be relevant for the communication with Engineering. TF6311 Version: 1.8.1 9
## Page 10

Installation / Licensing 3 Installation / Licensing The Function TF6311 requires no separate installation; all software components are available once Twin CAT 3 has been installed. • A “TC3 TCP UDP RT” license is required. The dependence is entered by adding the “TCP/UDP RT” object to the project as a license. It can also be specified manually. • A trial license can be created and used. 10 Version: 1.8.1 TF6311
## Page 11

Quick Starts 4 Quick Starts This section contains detailed step-by-step instructions for some protocols. They illustrate the use of the product in a simple manner. The samples are intended to facilitate understanding; they do not provide comprehensive implementation instructions. At the application level, the handling must be programmed in detail (e.g. the behavior on arrival of corresponding TCP events). The function TF6311 “TCP/UDP real-time” has extensive capabilities: • different protocols (TCP, UDP, ARP/Ping) • different programming languages (PLC / C++) and • communication directions (client / server) Step-by-step instructions are not available for all combinations. Once the basic concept [} 8] has been understood, further implementations can be derived in conjunction with the existing step-by-step instructions and samples [} 38]. 4.1 Quick Start (PLC / UDP) The sample implements an “echo service”: A UDP server is started on a port (default: 10000). If this server receives a UDP packet, it returns the content to the sender (with same IP and same port). The sample is also available for download under Sample 02 [} 40]. In addition to the Quick Start, the download contains extended code, which does not affect the basic functionality. Implementation of the UDP echo server in a PLC project ü A Twin CAT solution was generated 1. If no PLC project exists in the Twin CAT solution, you have to create one. 2. A function block is generated, which implements the interface "Itc Io Udp Protocol Recv". This creates a method, which is called when UDP packets arrive. By right-clicking on the node "POU" in the PLC project you can allocate names in the Popup window, TF6311 Version: 1.8.1 11
## Page 12

Quick Starts activate "Sample Udp Echo Server" and "Implements" by ticking, and select the interface mentioned with the button "…": The declaration part of the function block contains several variables in the declaration: • Oid: Configurable reference to the TCP/UDP RT module • ip Udp: Interface pointer to the Udp Protocol, which is implemented by the TCP/UDP RT module • udp Port: Port used for receiving 3. The declaration part is created in this way: {attribute 'c++_compatible'} FUNCTION_BLOCK Sample Udp Echo Server IMPLEMENTS ITc Io Udp Protocol Recv VAR_INPUT END_VAR VAR_OUTPUT END_VAR VAR {attribute 'Tc Init Symbol'} oid: OTCID; ip Udp: ITc Io Udp Protocol; n Udp Port: UINT := 10000; n Received Pakets: UINT; hr Init : HRESULT; hr Send : HRESULT; END_VAR The Check Receive() method of the TCP/UDP RT module must be called in the body of the function block. 4. The body is created in this way: IF ip Udp <> 0 THEN ip Udp. Check Received(); END_IF The method "Receive Data", which was created through implementation of the interface, will be called repeatedly via "Check Received": one call for each packet received in the meantime. 12 Version: 1.8.1 TF6311
## Page 13

Quick Starts 5. The method has both sender information and data as input parameters. In this sample, the "Send Data" method returns an incoming packet as response (with sender/receiver reversed). The implementation is done as follows: n Received Pakets := n Received Pakets+1; IF ip Udp <> 0 THEN hr Send := ip Udp. Send Data(ip Addr, udp Src Port, udp Dest Port, n Data, p Data, TRUE, 0); // send data back END_IF During start and finish, a reference to the "Udp Protocol" interface must be set from the configured OID; corresponding approvals should be taken care of during shutdown. 6. The function block requires the methods "FB_init", "FB_reinit" and "FB_exit", which can be created by right-clicking on the function block "Add…" method: TF6311 Version: 1.8.1 13
## Page 14

Quick Starts Appropriate signatures are generated automatically, so that only the actual body has to be realized. Of particular significance is the "Register Receiver" call, which opens a UDP port for reception. 7. The "FB_init" method requires two local variables: VAR ip Srv: ITCom Object Server; END_VAR 8. The "FB_init" method is implemented as follows: IF NOT b In Copy Code THEN // no online change IF ip Udp = 0 AND oid <> 0 THEN hr Init := FW_Obj Mgr_Get Object Instance(oid:=oid, iid:=TC_GLOBAL_IID_LIST. IID_ITc Io Udp Protocol, pip Unk:=ADR(ip Udp) ); IF SUCCEEDED(hr Init) THEN IF SUCCEEDED(ip Udp. Register Receiver(n Udp Port, THIS^)) THEN //open port FB_init := TRUE; ELSE FB_init := FALSE; FW_Safe Release(ADR(ip Udp)); END_IF END_IF ELSIF oid = 0 THEN FB_init := FALSE; hr Init := ERR_INVALID_PARAM; END_IF END_IF In the "FB_reinit" method, which is executed during an Online Change, the TCP/UDP RT object must be supplied with the new address for the callbacks. 9. The "FB_reinit" method is implemented as follows: IF (ip Udp <> 0) THEN ip Udp. Register Receiver(n Upd Port, THIS^); FB_reinit := TRUE: END_IF The port must be closed again during shutdown (but not during Online Change, cf. b In Copy Code). 10. The "FB_exit" method is implemented as follows: IF (NOT b In Copy Code AND ip Udp <> 0) THEN //Shutdown ip Udp. Unregister Receiver(n Upd Port); FW_Safe Release(ADR(ip Udp)); FB_exit := TRUE; ELSE FB_exit := FALSE; END_IF 11. Finally, the function block must be called: PROGRAM MAIN VAR udp1 : Sample Udp Echo Server; END_VAR udp1(); “TCP/UDP RT” module configuration Notice Variable names relating to TCP are used here. They have to be substituted accordingly. 14 Version: 1.8.1 TF6311
## Page 15

Quick Starts 1. Create the “TCP/UDP RT” module under the RT Ethernet adapter by selecting “Add Object(s)…” in the context menu. 2. Then select the “TCP/UDP RT” module: ð The TCP/UDP RT object is created under the adapter. 3. Parameterize the previously created instance of the module (here: Module1) under “Interface Pointer” “Tcp Prot” with the OID of the created “TCP/UDP RT” object: TF6311 Version: 1.8.1 15
## Page 16

Quick Starts 4. For PLC projects this configuration is also done at the instance, under the tab “Symbol Initialization”: ð The configuration is thus completed Disconnection by the operating system in Promiscuous mode If Promiscuous mode is active at the RT Ethernet adapter in the “Adapter” tab, any TCP connection attempts are blocked by the operating system, since it does not recognize a port opened in the TCP/UDP RT object. Testing Once the configuration has been activated, a UDP packet can be sent to the PLC via the UDP Sample Client [} 44]. It can be observed that each call increments the counter. The client displays the returned packets at the top. No local communication The UDP sample client must run on a different computer than the PLC with the TCP/UDP RT object, because no local communication between the Windows operating system and the real-time is available. Alternatively, a so-called "loop cable" can be used to connect two network ports. The UDP sample client can be forced to use a specific port by selecting the source (dropdown menu "Source"). 4.2 Quick Start (C++ / UDP) The example implements an "echo service": A UDP server is started on a port (default: 10000). If this server receives a UDP packet, it returns the content to the sender (with same IP and same port). The engineering system must meet the requirements for Twin CAT 3 C++. 16 Version: 1.8.1 TF6311
## Page 17

Quick Starts The example is also available for download under Sample 02 [} 40]. Implementation of the UDP echo server in a C++ project ü A Twin CAT solution was generated 1. If no C++ project exists in the Twin CAT solution, you have to create one. Please use the template for “Twin CAT Module Class with Cyclic IO”. 2. Create a task. Under System / Tasks right-click and select “Add new Item…” A normal task (without image) is sufficient. 3. In the C++ project, open the TMC editor by double-clicking on the TMC file. The module must implement the ITc Io Udp Protocol Recv. This creates a method, which is called when UDP packets arrive. TF6311 Version: 1.8.1 17
## Page 18

Quick Starts 4. In the TMC editor select “Implemented interfaces” and create them with “+”. A dialog appears, in which the type ITc Io Udp Protocol Recv is selected: The module requires an interface pointer to ITc Io Udp Protocol, which contains the reference to the TCP/UDP RT object. 5. In the TMC editor select “Interface Pointer” and press “+”. An interface is created, which can be opened by double-clicking. Assign a name “Udp Prot” and set the pointer type with “..:” and the selection in the dialog: 6. The TMC code generator is started once. Right-click on the C++ project and select “TMC Code Generator” in the context menu. The Check Received() method of the TCP/UDP RT module must be called in the Cycle Update() method in the CPP file of the module (Module1.cpp). As a result, arriving UDP packets are transferred to the implemented method Receive Data() via callback. 18 Version: 1.8.1 TF6311
## Page 19

Quick Starts 7. The Cycle Update() method is implemented as follows ///<Auto Generated Content id="Implementation Of_ITc Cyclic"> HRESULT CModule1::Cycle Update(ITc Task* ip Task, ITc Unknown* ip Caller, ULONG_PTR context) { HRESULT hr = S_OK; m_counter+=m_Inputs. Value; m_Outputs. Value=m_counter; m_sp Udp Prot->Check Received(); // ADDED return hr; } The method “Receive Data”, which was created through implementation of the interface, will be called repeatedly via Check Received(): one call for each packet received in the meantime. 8. The method Receive Data has both sender information and data as input parameters. In this sample, the Send Data method returns an incoming packet as response (with sender/receiver reversed). The implementation is done as follows: ///<Auto Generated Content id="Implementation Of_ITc Io Udp Protocol Recv"> HRESULT CModule1::Receive Data(ULONG ip Addr, USHORT udp Dest Port, USHORT udp Src Port, ULONG n Data, PVOID p Data, ETYPE_VLAN_HEADER* p Vlan) { HRESULT hr = S_OK; // mirror incomming data hr = m_sp Udp Prot->Send Data(ip Addr, udp Src Port, udp Dest Port, n Data, p Data, true); m_Trace. Log(tl Info, FLEAVEA "UDP Receive Data: IP: %d.%d.%d.%d udp Src Port: %d Data Size: %d (hr2=%x) \n", ((PBYTE)&ip Addr)[3], ((PBYTE)&ip Addr)[2], ((PBYTE)&ip Addr)[1], ((PBYTE)&ip Addr)[0], udp Src Port, n Data, hr); return hr; } ///</Auto Generated Content> During start and finish, a reference to the “Udp Protocol” interface must be set from the configured OID; corresponding approvals should be taken care of during shutdown. 9. The start is triggered in the transition from Safe Op to Op. During this process, Register Receiver is of particular interest: It opens a UDP port for reception. HRESULT CModule1::Set Obj State SO() { HRESULT hr = S_OK; //START EDITING if (SUCCEEDED(hr) && m_sp Udp Prot. Has OID()) { m_Trace. Log(tl Info, FLEAVEA "Register Udp Prot"); if (SUCCEEDED_DBG(hr = m_sp Srv->Tc Query Smart Object Interface(m_sp Udp Prot))) { m_Trace. Log(tl Info, FLEAVEA "Server: Udp Prot listen to Port: %d", 10000); if (FAILED(hr = m_sp Udp Prot->Register Receiver(10000, THIS_CAST(ITc Io Udp Protocol Recv)))) { m_Trace. Log(tl Error, FLEAVEA "Server: Udp Prot Register Receiver failed on Port: %d", 10000); m_sp Udp Prot = NULL; } } } // If following call is successful the Cycle Update method will be called, // eventually even before method has been left. hr = FAILED(hr) ? hr : Add Module To Caller(); // Cleanup if transition failed at some stage if ( FAILED(hr) ) { if (m_sp Udp Prot != NULL) m_sp Udp Prot->Unregister Receiver(10000); m_sp Udp Prot = NULL; Remove Module From Caller(); } //END EDITING m_Trace. Log(tl Verbose, FLEAVEA "hr=0x%08x", hr); return hr; } 10. The stop takes place in the Op to Safe Op transition. The UDP port is closed again: TF6311 Version: 1.8.1 19
## Page 20

Quick Starts HRESULT CModule1::Set Obj State OS() { m_Trace. Log(tl Verbose, FENTERA); HRESULT hr = S_OK; if (m_sp Udp Prot != NULL) m_sp Udp Prot->Unregister Receiver(10000); m_sp Udp Prot = NULL; m_Trace. Log(tl Verbose, FLEAVEA "hr=0x%08x", hr); return hr; } Finally, the module has to be instantiated and configured 11. Build the project once. Right-click on the module select “Build” 12. Creating an instance of the module. Right-click on the project to open “Add new item…”. Select the appropriate module here. 13. Double-click on the module instance to enable parameterization. First select the task in the “Context” tab. “TCP/UDP RT” module configuration Notice Variable names relating to TCP are used here. They have to be substituted accordingly. 1. Create the “TCP/UDP RT” module under the RT Ethernet adapter by selecting “Add Object(s)…” in the context menu. 20 Version: 1.8.1 TF6311
## Page 21

Quick Starts 2. Then select the “TCP/UDP RT” module: ð The TCP/UDP RT object is created under the adapter. 3. Parameterize the previously created instance of the module (here: Module1) under “Interface Pointer” “Tcp Prot” with the OID of the created “TCP/UDP RT” object: 4. For PLC projects this configuration is also done at the instance, under the tab “Symbol Initialization”: ð The configuration is thus completed Disconnection by the operating system in Promiscuous mode If Promiscuous mode is active at the RT Ethernet adapter in the “Adapter” tab, any TCP connection attempts are blocked by the operating system, since it does not recognize a port opened in the TCP/UDP RT object. TF6311 Version: 1.8.1 21
## Page 22

Quick Starts Testing Once the configuration has been enabled, a UDP packet can be sent to the C++ module via the UDP Sample Client [} 44]. By activating the corresponding Trace Level (here at least tl Info; see C++ Tracing), an output can be generated in the Visual Studio log. The client displays the returned packets at the top. No local communication The UDP sample client must run on a different computer than the PLC with the TCP/UDP RT object, because no local communication between the Windows operating system and the real-time is available. Alternatively, a so-called "loop cable" can be used to connect two network ports. The UDP sample client can be forced to use a specific port by selecting the source (dropdown menu "Source"). 4.3 Quick Start (C++ / TCP Client) This Quick Start shows the implementation of a TCP client as a Twin CAT 3 C++ project. The engineering system must meet the requirements for Twin CAT 3 C++. The example is also available for download under Sample 01 [} 38]. Creating a Twin CAT C++ project In this step, a new Twin CAT 3 C++ project is created. 22 Version: 1.8.1 TF6311
## Page 23

Quick Starts 1. Create a new Twin CAT project 2. Add a Twin CAT C++ project TF6311 Version: 1.8.1 23
## Page 24

Quick Starts 3. Select a Driver project 4. Use the wizard for a module class with "Cyclic IO" as the basis for the TCP client. 24 Version: 1.8.1 TF6311
## Page 25

Quick Starts ð The result is a complete Twin CAT C++ project. TMC editor for creating interfaces, pointers and parameters After creating the project, the next step involves implementation of the C++ TCP client. 1. The module created by the wizard must implement the interface "ITc Io Tcp Protocol Recv". Open the TMC editor by double-clicking on the TMC file for the project. Add the interface to the module under "Implemented Interfaces". Under "Implemented Interfaces" open a selection of the available interfaces by clicking on the "+" button. Select "ITc Io Tcp Protocol Recv". 2. In addition, an "ITc IOTcp Protocol" interface pointer is required. TF6311 Version: 1.8.1 25
## Page 26

Quick Starts 3. By creating a parameter the server IP address to be contacted and the port become configurable. 4. Now use the TMC code generator to prepare the code of the C++ module. Start the TMC code generator by selecting the appropriate menu item in the context menu (right-click) of the C++ project. ð All steps in the TMC editor are now completed. 26 Version: 1.8.1 TF6311
## Page 27

Quick Starts Implement TCP client 1. Create two member variables in the module header file (here: Modul1.h). ULONG m_Sock Id; BOOL m_b Send Request; //set by debugger for sending a http command ULONG m_connections; //count number of connection attempts HRESULT m_hr Send; //Last hr of Send Data 2. These are initialized in the Constructor (Module1.cpp). CModule1::CModule1() : m_Trace(m_Trace Level Max, m_sp Srv) , m_Trace Level Max(tl Always) , m_hr Send(0) { m_Sock Id = 0; //added m_b Send Request = true; //added m_connections = 0; //added } 3. The interface pointer m_sp Tcp Prot is now initialized in the Transition SO (i.e. in method Set Obj State SO). HRESULT CTcp Client::Set Obj State SO() { m_Trace. Log(tl Verbose, FENTERA); RESULT hr = S_OK; if (SUCCEEDED(hr) && m_sp Tcp Prot. Has OID()) //added { //added hr = m_sp Srv->Tc Query Smart Object Interface(m_sp Tcp Prot); //added } //added hr = FAILED(hr) ? hr : Add Module To Caller(); 4. In the Transition OS (i.e. method Set Obj State OS) a connection that may exist is closed, and the socket is released. /////////////////////////////////////////////////////////////////////////////// // State transition from OP to SAFEOP HRESULT CTcp Client::Set Obj State OS() { //start added code m_Trace. Log(tl Verbose, FENTERA); HRESULT hr = S_OK; if ( m_Sock Id != 0 ) { if (m_sp Tcp Prot->Is Connected(m_Sock Id) == S_OK) { m_sp Tcp Prot->Close(m_Sock Id); m_sp Tcp Prot->Check Received(); } m_sp Tcp Prot->Free Socket(m_Sock Id); m_Sock Id = 0; } Remove Module From Caller(); m_Trace. Log(tl Verbose, FLEAVEA "hr=0x%08x", hr); return hr; //end added code } 5. The actual process is implemented in the "Cycle Update" method, which is called cyclically. Establishes a TCP connection to a server (address is provided in parameters "m_Tcp Server Ip Address" and "m_Tcp Server Port"). The connection handle is stored in the member variable "m_Sock Id". The connection is used to issue a simple http GET request. HRESULT CTcp Client::Cycle Update(ITc Task* ip Task, ITc Unknown* ip Caller, ULONG_PTR context) { HRESULT hr = S_OK; //start added code if ( m_Sock Id == 0 ) { if (SUCCEEDED_DBG(hr = m_sp Tcp Prot->Alloc Socket(THIS_CAST(ITc Io Tcp Protocol Recv), m_Sock Id))) { if (FAILED(hr = m_sp Tcp Prot->Connect(m_Sock Id, ((PULONG)&m_Tcp Server Ip Address)[0], m_Tcp Server Port))) { TF6311 Version: 1.8.1 27
## Page 28

Quick Starts m_sp Tcp Prot->Free Socket(m_Sock Id); m_Sock Id = 0; } else { m_connections++; //count number of connections } } } else { if ( m_b Send Request && m_sp Tcp Prot->Is Connected(m_Sock Id) == S_OK ) { PCHAR p Request = "GET / HTTP/1.1\r\n HOST: beckhoff.com\r\n\r\n "; ULONG n Send Data = 0; m_hr Send = m_sp Tcp Prot->Send Data(m_Sock Id, strlen(p Request), p Request, n Send Data); m_b Send Request = false; } } m_sp Tcp Prot->Check Received(); //end added code return hr; } 6. The module implements the interface "ITc Io Tcp Protocol Recv", as a result of which the TMC code generator created a "Receive Event" method. This is called when an event is received and must therefore be able to deal with a wide range of event types. HRESULT CTcp Client::Receive Event(ULONG socket Id, TCPIP_EVENT tcp Event) { //start added code m_Trace. Log(tl Info, FLEAVEA "Receive TCP Event: Socket Id: %d Event: %d \n", socket Id, tcp Event); switch (tcp Event) { case TCPIP_EVENT_ERROR: case TCPIP_EVENT_RESET: case TCPIP_EVENT_TIMEOUT: m_Trace. Log(tl Info, FLEAVEA "Connection to remote server failed!\n"); m_Sock Id = 0; break; case TCPIP_EVENT_CONN_CLOSED: m_Trace. Log(tl Info, FLEAVEA "Close connection: Socket Id: %d \n", socket Id); m_Sock Id = 0; break; case TCPIP_EVENT_CONN_INCOMING: case TCPIP_EVENT_KEEP_ALIVE: case TCPIP_EVENT_CONN_IDLE: case TCPIP_EVENT_DATA_SENT: case TCPIP_EVENT_DATA_RECEIVED: break; default: break; } return S_OK; //end added code } 7. Analogous to the "Receive Event" method, a "Receive Data" method was created from the "ITc Io Tcp Protocol Recv" interface. It is responsible for receiving the data and is implemented as follows: HRESULT CTcp Client::Receive Data(ULONG socket Id, ULONG n Data, PVOID p Data) { //start added code HRESULT hr = S_OK; PCHAR p Response = new CHAR[100]; memset(p Response, 0, 100); memcpy(p Response, p Data, min(100, n Data)); m_Trace. Log(tl Info, FLEAVEA "Receive answer w/ length %d : first 100 chars:'%s'", n Data, p Response); return hr; //end added code } 8. The module is now ready and can be compiled. (Right-click on "Build" project). 28 Version: 1.8.1 TF6311
## Page 29

Quick Starts 9. An instance of the module is created: Right-click on the C++ project and select the module ð The instance is associated with a task, so that the "Cycle Update" method is called. Preparing the network card For the TCP/UDP RT module, make sure that the RT Ethernet adapter in the Twin CAT solution is connected with the correct network card (with Twin CAT driver). Local configuration only Installation of the driver on compatible network cards via the button "Compatible Devices" always takes place locally. On a controller with Twin CAT XAR, the program Tc Rte Install.exe can be used. It is included in the installation (usually under C:Twin CAT\3.1\System). TF6311 Version: 1.8.1 29
## Page 30

Quick Starts “TCP/UDP RT” module configuration Notice Variable names relating to TCP are used here. They have to be substituted accordingly. 1. Create the “TCP/UDP RT” module under the RT Ethernet adapter by selecting “Add Object(s)…” in the context menu. 30 Version: 1.8.1 TF6311
## Page 31

Quick Starts 2. Then select the “TCP/UDP RT” module: ð The TCP/UDP RT object is created under the adapter. 3. Parameterize the previously created instance of the module (here: Module1) under “Interface Pointer” “Tcp Prot” with the OID of the created “TCP/UDP RT” object: 4. For PLC projects this configuration is also done at the instance, under the tab “Symbol Initialization”: ð The configuration is thus completed Disconnection by the operating system in Promiscuous mode If Promiscuous mode is active at the RT Ethernet adapter in the “Adapter” tab, any TCP connection attempts are blocked by the operating system, since it does not recognize a port opened in the TCP/UDP RT object. TF6311 Version: 1.8.1 31
## Page 32

Quick Starts Handling 1. The sample is ready to use once you have configured both the Tcp Server Ip Address and the Tcp Server Port at the module instance: Notice Possible source of error: A test web server 62.159.14.51 is queried in the sample. A corresponding HTTP command is stored in the source code. IP address, port, and this HTTP command may have to be adjusted. 2. After activating the configuration you can see log messages (see source code) and the first 100 bytes of the response from the server in the output: 3. To output these messages the “Tracelevel” can be configured (via Info): The procedure is carried out once when the program starts. A new request is sent if “m_b Send Request” is set to TRUE (e.g. through Twin CAT Live Watch). The return of the Send Data method is stored in hr Send. For the sample it can be monitored via the debugger. 32 Version: 1.8.1 TF6311
## Page 33

Configuration 5 Configuration The integration and configuration of the "TCP/UDP RT" object is described here, starting from an existing Twin CAT project. The "TCP/UDP RT" object is instantiated and configured. The configuration essentially consists of assigning the network card to be used. Windows Firewall The Windows firewall cannot be used, since the TF6311 is directly integrated in the Twin CAT system. The "TCP/UDP RT" object also contributes some parameters, which are documented here [} 55]. “TCP/UDP RT” module configuration Notice Variable names relating to TCP are used here. They have to be substituted accordingly. 1. Create the “TCP/UDP RT” module under the RT Ethernet adapter by selecting “Add Object(s)…” in the context menu. TF6311 Version: 1.8.1 33
## Page 34

Configuration 2. Then select the “TCP/UDP RT” module: ð The TCP/UDP RT object is created under the adapter. 3. Parameterize the previously created instance of the module (here: Module1) under “Interface Pointer” “Tcp Prot” with the OID of the created “TCP/UDP RT” object: 4. For PLC projects this configuration is also done at the instance, under the tab “Symbol Initialization”: ð The configuration is thus completed Disconnection by the operating system in Promiscuous mode If Promiscuous mode is active at the RT Ethernet adapter in the “Adapter” tab, any TCP connection attempts are blocked by the operating system, since it does not recognize a port opened in the TCP/UDP RT object. 34 Version: 1.8.1 TF6311
## Page 35

Configuration 5.1 Multiple network cards A TCP/UDP RT object is assigned to an RT Ethernet adapter by instantiating it under the objects, for example. A TCP/UDP RT object therefore always addresses precisely one network port of the controller via the RT Ethernet adapter. If several network ports are to be used, a TCP/UDP RT object is created for each RT Ethernet adapter: The TCP/UDP RT objects relate to the higher-level RT Ethernet adapter, if no other configuration was specified manually: These objects have different object IDs: This object ID is used for referencing, as described above: PLC: TF6311 Version: 1.8.1 35
## Page 36

Configuration Or for a C++ module: The use is highly dependent on the application. Some sample scenarios are provided below: • A C++ module can be instantiated more than once. Each module can then communicate via a particular network card, based on the configuration with the corresponding object ID. • Different PLC programs can be assigned separate TCP/UDP RT objects and thus act independently. • A PLC or C++ program can address several TCP/UDP RT objects (and therefore several network cards), based on corresponding symbols (C++ is used as an example here): Object management must be implemented to suit the application. For example, the Check Received() calls must be applied to all objects. This also applies to calls for Send Data() / Register Receiver() etc. 5.2 Multitask access to a network card If a network card is to be used from several real-time contexts (tasks), it must be implemented as described here. • A TCP/UDP RT object must be created for each real-time context (e.g. task) from which data is to be received or sent. • The Passive Mode parameter on all TCP/UDP RT objects specifies whether or not these objects should fetch frames received from the RT Ethernet adapter. By default, Passive Mode is set to FALSE so that packets are fetched. For multitask access, only one TCP/UDP RT object should fetch the data and all other objects should be configured with Passive Mode to TRUE. Typically, this can be the object that receives packets in the fastest cycle. Where appropriate, a lower 36 Version: 1.8.1 TF6311
## Page 37

Configuration priority can be used for this in order to make the real-time processes of other tasks more independent of the incoming frames. • The function block must call the Register Receiver() / Open() method in the same context as it calls the Check Received() method in the cyclic process. • The callbacks via Receive Data()/... Event() are called in the same context as the Check Received() from the function block of the application previously. TF6311 Version: 1.8.1 37
## Page 38

Examples 6 Examples These examples provide easy-to-follow demonstrations for dealing with the TCP/UDP RT module. Sample code and configurations for this product can be obtained from the corresponding repository on Git Hub: https://github.com/Beckhoff/TF6311_Samples. There you have the option to clone the repository or download a ZIP file containing the sample. 6.1 S01: Simple TCP Client (PLC / C++) This sample shows the application of a TCP connection as client. In this sample illustrates opening of a TCP connection with an IP address via port 80. The Beckhoff web server is used. The sample uses the connection to send an HTTP request to access a test website 62.159.14.51:80. If the website does not fit into the receive buffer, the Receive Data() method is called several times. The client re-establishes a connection, if it was closed by the server, for example. The sample is available for C++ and for the PLC. 6.1.1 S01: Simple TCP Client (C++) This example implements a TCP client that issues a simple HTTP request and receives the response. The download available here is preconfigured to call a test website 62.159.14.51:80. Download Download the sample: https://github.com/Beckhoff/TF6311_Samples/tree/main/S01-Ip Stack Tcp Client 1. Get the sample from Git Hub, unzip the downloaded ZIP file if necessary 2. Open the project with Twin CAT XAE 3. Select your target system 38 Version: 1.8.1 TF6311
## Page 39

Examples 4. Configure the network card (see below) for the target system 5. Build the sample on your local machine (e.g. Build->Build Solution) 6. Activate the configuration Description The example is described in detail on the Quick Start [} 22] page. Preparing the network card For the TCP/UDP RT module, make sure that the RT Ethernet adapter in the Twin CAT solution is connected with the correct network card (with Twin CAT driver). Local configuration only Installation of the driver on compatible network cards via the button "Compatible Devices" always takes place locally. On a controller with Twin CAT XAR, the program Tc Rte Install.exe can be used. It is included in the installation (usually under C:Twin CAT\3.1\System). 6.1.2 S01: Simple TCP Client (PLC) This sample implements a TCP client that issues a simple HTTP request and receives the response. The download available here is preconfigured to call a test website 62.159.14.51:80. Download Download the sample: https://github.com/Beckhoff/TF6311_Samples/tree/main/S01-Ip Stack Tcp Client Plc 1. Get the sample from Git Hub, unzip the downloaded ZIP file if necessary 2. Open the project with Twin CAT XAE 3. Select your target system 4. Configure the network card (see below) for the target system 5. Build the sample on your local machine (e.g. Build->Build Solution) 6. Activate the configuration TF6311 Version: 1.8.1 39
## Page 40

Examples Description After the startup, the PLC program can be used by setting the variable "b Send" to TRUE. The HTTP request (stored in "s Message") is sent to the server, once the connection has been established. The first bytes of the incoming response are provided in "s Last Returned Message". The "s Last Returned Messafe Length" indicates the whole length of the response. The server address is defined in the FB_init method. The same sample is described in detail for C++ on the Quick Start [} 22] page. Preparing the network card For the TCP/UDP RT module, make sure that the RT Ethernet adapter in the Twin CAT solution is connected with the correct network card (with Twin CAT driver). Local configuration only Installation of the driver on compatible network cards via the button "Compatible Devices" always takes place locally. On a controller with Twin CAT XAR, the program Tc Rte Install.exe can be used. It is included in the installation (usually under C:Twin CAT\3.1\System). 6.2 S02: UDP Client Server (PLC/C++) This example describes how a Twin CAT project can act as a UDP server. Thus, values can be delivered to the real-time or from the real-time on request. The example implements an "echo service": A UDP server is started on a port (default: 10000). If this server receives a UDP packet, it returns the content to the sender (with same IP and same port). The example is available in PLC [} 40] and C++ [} 43]. For testing purposes, a UDP client [} 44] (written in . NET) is also available. The samples are also available in more detail as Quick Starts [} 11]. 6.2.1 S02: UDP Demo (PLC) This example describes a UDP server that is implemented in a PLC project. 40 Version: 1.8.1 TF6311
## Page 41

Examples It receives UDP packets and returns them to the sender ("echo server“). Download Download the sample: https://github.com/Beckhoff/TF6311_Samples/tree/main/S02-Udp Demo Plc 1. Get the sample from Git Hub, unzip the downloaded ZIP file if necessary 2. Open the project with Twin CAT XAE 3. Select your target system 4. Configure the network card (see below) for the target system 5. Build the sample on your local machine (e.g. Build->Build Solution) 6. Activate the configuration Description The sample is also available in more detail as Quick Start. The interface ITc Io Udp Protocol Recv [} 52] is implemented and a pointer to a ITc Io Udp Protocol [} 52] is used analogous to the Quick Start [} 22] in this sample. To this end a PLC block is created, which implements the interface ITc Io Udp Protocol Recv [} 52] (“Add POU” with “Implements”). It is important to realize the connection to the TCP/UDP RT object in the “FB_init” and “FB_exit” methods. This procedure is described in more detail in Sample 11 of the C++ documentation. The implementing function block (in sample Udp Receiver) calls the method “Check Received”. In this way the IP stack is enabled to process incoming packets and transmit callbacks on the “Receive Data” method of the function block. The “Receive Data” method uses the “Send Data” method to return the data to the sender (“echo server”). Understanding Two methods are used to establish the communication between the function block and the Tc COM object "TCP/UDP RT": • "FB_init": This is executed automatically when the PLC is started • "FB_exit": This is executed automatically when the PLC is stopped This initialization phase can largely be taken from the sample code. Two methods are responsible for the actual UDP functionality in the PLC code: • The "Receive Data" method in the implemented function block receives the data. • The "Send Data" method in the ITc Io Udp Protocol interface sends data. In the sample, the "Send Data" method is used in the "Receive Data" method to return the received data: TF6311 Version: 1.8.1 41
## Page 42

Examples The Tc Query Interface method must be implemented as follows to ensure that Twin CAT detects that the corresponding interface was implemented: VAR ip Udp Recv : ITc Io Udp Protocol Recv; ip Unknown : ITc Unknown; END_VAR IF Guids Equal(ADR(iid), ADR(TC_GLOBAL_IID_LIST. IID_ITc Io Udp Protocol Recv)) THEN ip Udp Recv := THIS^; // cast to interface pointer pip Itf^ := ITCUNKNOWN_TO_PVOID(ip Udp Recv); Tc Add Ref(); Tc Query Interface := S_OK; ELSIF Guids Equal(ADR(iid), ADR(TC_GLOBAL_IID_LIST. IID_ITc Unknown)) THEN ip Unknown := THIS^; // cast to interface pointer pip Itf^ := ITCUNKNOWN_TO_PVOID(ip Unknown); Tc Add Ref(); Tc Query Interface := S_OK; ELSE Tc Query Interface := E_HRESULTAds Err. NOINTERFACE ; //Call super if this fb extends some other END_IF The additionally created methods • Tc Add Ref / Tc Release are inherited by the ITc Unknown interface and are not relevant in this context. For background information we suggest reading the chapter on the Tc COM module concept in the C++ domain. Preparing the network card For the TCP/UDP RT module, make sure that the RT Ethernet adapter in the Twin CAT solution is connected with the correct network card (with Twin CAT driver). Local configuration only Installation of the driver on compatible network cards via the button "Compatible Devices" always takes place locally. On a controller with Twin CAT XAR, the program Tc Rte Install.exe can be used. It is included in the installation (usually under C:Twin CAT\3.1\System). 42 Version: 1.8.1 TF6311
## Page 43

Examples 6.2.2 S02: UDP Demo (C++) This example describes a UDP server that is implemented in C++. It receives UDP packets and returns them to the sender ("echo server“). Download Download the sample: https://github.com/Beckhoff/TF6311_Samples/tree/main/S02-Udp Demo 1. Get the sample from Git Hub, unzip the downloaded ZIP file if necessary 2. Open the project with Twin CAT XAE 3. Select your target system 4. Configure the network card (see below) for the target system 5. Build the sample on your local machine (e.g. Build->Build Solution) 6. Activate the configuration Description The interface ITc Io Udp Protocol Recv [} 52] is implemented and a pointer to a ITc Io Udp Protocol [} 52] is used analogous to the Quick Start [} 22] in this example. Using "Register Receiver" in the Transition SO ensures that the module is registered for the transmitted port (default: 10000). A corresponding unregistration takes place in the Transition OS. The "Check Received" method is called in the "Cycle Update" method. In this way the TCP/UDP RT module is enabled to process incoming packets and transmit callbacks on the "Receive Data" method to the module. The "Receive Data" method uses the "Send Data" method to return the data to the sender ("echo server"). The sample is also available in more detail as Quick Start [} 16]. Preparing the network card For the TCP/UDP RT module, make sure that the RT Ethernet adapter in the Twin CAT solution is connected with the correct network card (with Twin CAT driver). TF6311 Version: 1.8.1 43
## Page 44

Examples Local configuration only Installation of the driver on compatible network cards via the button "Compatible Devices" always takes place locally. On a controller with Twin CAT XAR, the program Tc Rte Install.exe can be used. It is included in the installation (usually under C:Twin CAT\3.1\System). 6.2.3 Test client The test client is used to send and receive single UDP data packets to and from a UDP server. Download Download the test client. Unpack the ZIP file; the .exe file runs on a Windows system. Description The client itself uses port 11000 for sending. At the same time it opens this port and displays received messages in the upper part of the interface as a log: 44 Version: 1.8.1 TF6311
## Page 45

Examples Together with the PLC / C++ samples, this results in an echo sample: A UDP message is sent from the client port 11000 to the server port 10000, which sends the same data back to the sender. The client can be configured via the interface: • Destination: Destination IP address • Port: The port that is addressed in the target • Source: Sender network card (IP address). "OS-based" operating system deals with selection of the appropriate network card. • Message The TF6311 "TCP/UDP Realtime" does not allow local communication. However, for testing purposes a different network interface can be selected via "Source", so that the UDP packet leaves the computer through one network card and arrives on the other network card ("loop cable"). 6.3 S03: ARP PING Demo (C++) This example describes an ARP and PING client. Download Download the sample: https://github.com/Beckhoff/TF6311_Samples/tree/main/S03-Ping Client 1. Get the sample from Git Hub, unzip the downloaded ZIP file if necessary 2. Open the project with Twin CAT XAE 3. Select your target system 4. Configure the network card (see below) for the target system 5. Build the sample on your local machine (e.g. Build->Build Solution) 6. Activate the configuration Description The interface ARP/Ping: ITc Io Arp Ping Protocol(Recv) [} 64] is implemented and a pointer to a ARP/Ping: ITc Io Arp Ping Protocol(Recv) [} 65] is used analogous to the Quick Start [} 22] in this example. Using "Register Receiver" in the Transition SO ensures that the module is registered for receiving Arp and Ping messages. A corresponding unregistration takes place in the Transition OS. The "Check Received" method is called in the "Cycle Update" method. In this way the TCP/UDP RT module is enabled to process incoming packets and transmit callbacks on the "Arp Reply" und "Ping Reply" methods to the module. Understanding The procedure is carried out once when the program starts. If "m_b Send Request" is set to TRUE (e.g. through Twin CAT Live Watch), a new request (ARP and Ping) is sent to the IP address defined here: The output is in the messages: TF6311 Version: 1.8.1 45
## Page 46

Examples To output these messages the "Tracelevel" can be configured (via Info). Preparing the network card For the TCP/UDP RT module, make sure that the RT Ethernet adapter in the Twin CAT solution is connected with the correct network card (with Twin CAT driver). Local configuration only Installation of the driver on compatible network cards via the button "Compatible Devices" always takes place locally. On a controller with Twin CAT XAR, the program Tc Rte Install.exe can be used. It is included in the installation (usually under C:Twin CAT\3.1\System). 6.4 S04: TCP Echo Server (PLC / C++) This sample describes a TCP server accepting an income connection. Data sent to this server are simply returned as “echo”. The same sample is available for C++ and PLC. By default, the server runs on port 11000. Testing the sample The sample can be tested via "telnet". %>telnet 192.168.1.1 11000 If a character is sent via telnet, it is returned immediately. A picture similar to the following emerges: 46 Version: 1.8.1 TF6311
## Page 47

Examples 6.4.1 S04: TCP Server Demo (PLC) This sample describes a TCP server that is implemented in a PLC project. It accepts a TCP connection, receives TCP packets and returns them to the sender (“echo server”). Download Download the sample: https://github.com/Beckhoff/TF6311_Samples/tree/main/S04-TCPServer Plc 1. Get the sample from Git Hub, unzip the downloaded ZIP file if necessary 2. Open the project with Twin CAT XAE 3. Select your target system 4. Configure the network card (see below) for the target system 5. Build the sample on your local machine (e.g. Build->Build Solution) 6. Activate the configuration Description The interface ITc Io Tcp Protocol Recv [} 58] is implemented and a pointer to a ITc Io Tcp Protocol [} 58] is used analogous to the Quick Start [} 11]s in this sample. To this end a PLC block is created, which implements the interface ITc Io Udp Protocol Recv [} 58] (“Add POU” with “Implements”). It is important to realize the connection to the TCP/UDP RT object in the “FB_init” and “FB_exit” methods. In particular, the Quick Starts illustrate how this Online Change can be implemented securely. The procedure is described in more detail in Sample 11 of the C++ documentation. The implementing function block (in sample TCPServer) calls the method “Check Received”. In this way the IP stack is enabled to process incoming packets and transmit callbacks relating to the “Receive Data” and “Receive Event” methods of the function block. In order to take into account incoming connections, a port is opened in FB_init via “Alloc Socket” and “Listen”. “Accept” is called in the “Receive Event”, if an event to establish a connection has occurred. In this sample the “Receive Data” method uses the “Send Data” method to return the data to the sender (“echo server”). TF6311 Version: 1.8.1 47
## Page 48

Examples Understanding Two methods are used to establish the communication between the function block and the Tc COM object “TCP/UDP RT”: • „FB_init“: This is executed automatically when the PLC is started. • „FB_exit“: This is executed automatically when the PLC is stopped. This initialization phase can largely be taken from the sample code. Two methods are responsible for the actual TCP functionality in the PLC code: • The “Receive Data” method in the implemented function block receives the data. • The “Receive Event” method indicates events occurring at the implemented function block. • The “Send Data” method in the ITc Io Tcp Protocol interface sends data. In the sample, the “Send Data” method is used in the “Receive Data” method to return the received data: The Tc Query Interface method must be implemented as follows to ensure that Twin CAT detects that the corresponding interface was implemented: VAR ip Tcp Recv : ITc Io Tcp Protocol Recv; ip Unknown : ITc Unknown; END_VAR IF Guids Equal(ADR(iid), ADR(TC_GLOBAL_IID_LIST. IID_ITc Io Tcp Protocol Recv)) THEN ip Tcp Recv := THIS^; // cast to interface pointer pip Itf^ := ITCUNKNOWN_TO_PVOID(ip Udp Recv); Tc Add Ref(); Tc Query Interface := S_OK; ELSIF Guids Equal(ADR(iid), ADR(TC_GLOBAL_IID_LIST. IID_ITc Unknown)) THEN ip Unknown := THIS^; // cast to interface pointer pip Itf^ := ITCUNKNOWN_TO_PVOID(ip Unknown); Tc Add Ref(); Tc Query Interface := S_OK; ELSE Tc Query Interface := E_HRESULTAds Err. NOINTERFACE ; //Call super if this fb extends some other END_IF The additionally created methods • Tc Add Ref / Tc Release are inherited by the ITc Unknown interface and are not relevant in this context. For background information we suggest reading the chapter on the Tc COM module concept in the C++ domain. Preparing the network card For the TCP/UDP RT module, make sure that the RT Ethernet adapter in the Twin CAT solution is connected with the correct network card (with Twin CAT driver). Local configuration only Installation of the driver on compatible network cards via the button "Compatible Devices" always takes place locally. On a controller with Twin CAT XAR, the program Tc Rte Install.exe can be used. It is included in the installation (usually under C:Twin CAT\3.1\System). 48 Version: 1.8.1 TF6311
## Page 49

Examples 6.4.2 S04: TCP Server Demo (C++) This sample describes a TCP server that is implemented in C++. It accepts a TCP connection, receives TCP packets and returns them to the sender (“echo server”). Download Download the sample: https://github.com/Beckhoff/TF6311_Samples/tree/main/S04-TCPServer 1. Get the sample from Git Hub, unzip the downloaded ZIP file if necessary 2. Open the project with Twin CAT XAE 3. Select your target system 4. Configure the network card (see below) for the target system 5. Build the sample on your local machine (e.g. Build->Build Solution) 6. Activate the configuration Description The interface ITc Io Tcp Protocol Recv is implemented and a pointer to a ITc Io Tcp Protocol is used analogous to the Quick Starts in this sample. The “Check Received” method is called in the “Cycle Update” method. In this way the TCP/UDP RT module is enabled to process incoming packets and transmit callbacks on the “Receive Event” und “Receive Data” methods to the module. In order to take into account incoming connections, a port is opened in “Cycle Update” via “Alloc Socket” and “Listen”. “Accept” is called in the “Receive Event”, if an event to establish a connection has occurred. In this sample the “Receive Data” method uses the “Send Data” method to return the data to the sender (“echo server”). Preparing the network card For the TCP/UDP RT module, make sure that the RT Ethernet adapter in the Twin CAT solution is connected with the correct network card (with Twin CAT driver). TF6311 Version: 1.8.1 49
## Page 50

Examples Local configuration only Installation of the driver on compatible network cards via the button "Compatible Devices" always takes place locally. On a controller with Twin CAT XAR, the program Tc Rte Install.exe can be used. It is included in the installation (usually under C:Twin CAT\3.1\System). 50 Version: 1.8.1 TF6311
## Page 51

Programmer's reference 7 Programmer's reference The programmer's reference provides an overview of the different parameters, interfaces and their methods. These include: • TCP/UDP RT Tc COM Parameters [} 55]: The parameters of the actual TCP/UDP RT module enable the configuration. The TCP/UDP RT module can be used by different protocols. An Interface Pointer and an interface to be implemented always go hand in hand: • ITc Io Tcp Protocol(Recv): [} 58] TCP/IP protocol • ITc Io Udp Protocol(Recv) [} 52]: UDP/IP protocol • ITc Io Arp Ping Protocol(Recv) [} 64]: ARP/Ping protocol For all uses of IP addresses (e.g. "Ip Addr"), the most significant elements are displayed in the last position. (Example: 192.168.2.1 -> 01 02 A8 C0) Performance The TCP/UDP RT Tc COM object runs in real-time. Thus, the module is also directly dependent on the cycling of the real-time. The frequency with which data can be communicated can therefore be influenced by the cycling of the task used (and therefore also the real-time settings): Communication via the network interface depends on this cycle. A corresponding call to the Check Received() methods (see API documentation [} 51]) must be made in each cycle. TF6311 Version: 1.8.1 51
## Page 52

Programmer's reference Incoming data: Check Received() Context of the incoming data The customer must ensure that the method Check Received is called cyclically. Samples illustrate the procedure in PLC and C++ The Check Reveived() method is called cyclically in order to ensure that the data can be provided in the same context as the client project. The protocol-dependent Receive() methods of the customer project are called within this method call, if data have been received. Disconnection of Engineering connection on breakpoints If breakpoints are used, we strongly advise to use different network interfaces, since a breakpoint stops parts of the Twin CAT systems, which may be relevant for the communication with Engineering. 7.1 UDP/IP: ITc Io Udp Protocol(Recv) The ITc Io Udp Protocol and ITc Io Udp Protocol Recv interfaces enable UDP/IP communication from the real- time environment. A project that uses this interface contains a pointer to an ITc Io Udp Protocol object and implements ITc Io Udp Protocol Recv itself. ITc Io Udp Protocol Recv serves as callback interface for receiving data from the TCP/UDP RT module within the application. Multiple calls of Receive() During the implementation it should be noted that Check Received() will result in the callback to Receive() occurring several times within a cycle, if multiple packets have arrived between the cycles. A buffer in the form a queue may therefore have to be provided. ITc Io Udp Protocol Recv methods: Name Description Receive Data [} 53] Is called by the TCP/UDP RT module as a callback to transfer data ITc Io Udp Protocol methods: Name Description Send Data [} 53] Sends data Check Received [} 54] Must be called cyclically. Receive Data is used as callback in the context of this method (server and client functionality). Register Receiver [} 54] Registering at the TCP/UDP RT module for receiving data. Unregister Receiver [} 55] Unregistering at the TCP/UDP RT module for receiving UDP data. The client and server implementation process is briefly described here. Only an overview is provided; the samples illustrate the application. Implementation of a UDP sender / receiver Name Description Register Receiver [} 54] Opens a port for incoming data packets. Receive Data [} 53] Is called when data packets arrive. Send Data [} 53] Can be used to send data. Unregister Receiver [} 55] For logout from (closing of) the port, e.g. during shutdown. 52 Version: 1.8.1 TF6311
## Page 53

Programmer's reference To receive UDP data, registration is required by calling Register Receiver. This can be done in Set Obj State SO or FB_init. Data is provided by a callback of method Receive Data from ITc Io Udp Protocol Recv. While Twin CAT switches from RUN mode to Config mode, all modules should unregister via Unregister Receiver. This can be done in Set Obj State OS() or FB_exit. NOTICE Online Change security For Online Change security, Register Receiver should be called again. 7.1.1 Method ITc Io Udp Protocol Recv:Receive Data Is called by the TCP/UDP RT module as a callback to transfer data. Syntax HRESULT TCOMAPI Receive Data(ULONG ip Addr, USHORT udp Dest Port, USHORT udp Src Port, ULONG n Data, PVOID p Data, ETYPE_VLAN_HEADER* p Vlan=0) Return value Type Description HRESULT Indicates success and must be provided accordingly by the implemented module. Parameter Name Type Description ip Addr ULONG The IP address of the sender. IP addresses are displayed with the most significant element in the last position. (Example: 192.168.2.1 -> 01 02 A8 C0) udp Dest Port USHORT Port on which the data was received. udp Src Port USHORT Port of the sender. n Data ULONG Number of bytes received. p Data PVOID Pointer to the received data. p Vlan ETYPE_VLAN_HEADER ETYPE_VLAN_HEADER structure - see below. The VLAN header represents information about the VLAN. typedef struct _ETYPE_VLAN_HEADER { USHORT VLan Type; unsigned short VLan Id H : 4; unsigned short reserved1 : 1; unsigned short Priority : 3; unsigned short VLan Id L : 8; } ETYPE_VLAN_HEADER, *PETYPE_VLAN_HEADER; 7.1.2 Method ITc Io Udp Protocol:Send Data Sends data. Syntax HRESULT TCOMAPI Send Data(ULONG ip Addr, USHORT udp Dest Port, USHORT udp Src Port, ULONG n Data, PVOID p Data, bool b Calc Udp Check Sum=0, ETYPE_VLAN_HEADER* p Vlan=0) TF6311 Version: 1.8.1 53
## Page 54

Programmer's reference Return value Type Description HRESULT Indicates success, see Return values [} 68]. Parameter Name Type Description ip Addr ULONG The IP address of the receiver. IP addresses are displayed with the most significant element in the last position. (Example: 192.168.2.1 -> 01 02 A8 C0) udp Dest Port USHORT The port of the receiver. udp Src Port USHORT The port of the sender. n Data ULONG Number of date to be sent in bytes. p Data PVOID Pointer to the data to be sent. b Calc Udp Check Sum BOOL Indicates whether the checksum should be calculated. p Vlan ETYPE_VLAN_HEADER ETYPE_VLAN_HEADER structure, see below. The VLAN header represents information about the VLAN. typedef struct _ETYPE_VLAN_HEADER { USHORT VLan Type; unsigned short VLan Id H : 4; unsigned short reserved1 : 1; unsigned short Priority : 3; unsigned short VLan Id L : 8; } ETYPE_VLAN_HEADER, *PETYPE_VLAN_HEADER; 7.1.3 Method ITc Io Udp Protocol:Check Received Must be called cyclically; Receive Data is used as callback in the context of this method (send and receive). Syntax HRESULT TCOMAPI Check Received() Return value Type Description HRESULT Indicates success, see Return values [} 68]. 7.1.4 Method ITc Io Udp Protocol:Register Receiver Registering at the TCP/UDP RT module for receiving data. Syntax HRESULT TCOMAPI Register Receiver(USHORT udp Port, ITc Io Udp Protocol Recv* ip Recv) Return value Type Description HRESULT Indicates success, see Return values [} 68]. 54 Version: 1.8.1 TF6311
## Page 55

Programmer's reference Parameter Name Type Description udp Port USHORT Port on which the data is to be received. ip Recv ITc Io Udp Protocol Recv* Pointer to the receiver (Recv) interface. 7.1.5 Method ITc Io Udp Protocol:Unregister Receiver Unregistering at the TCP/UDP RT module for receiving data. Syntax HRESULT TCOMAPI Unregister Receiver(USHORT udp Port) Return value Type Description HRESULT Indicates success, see Return values [} 68]. Parameter Name Type Description udp Port USHORT Port at which the data should no longer be received. 7.2 TCP/UDP RT Tc Com Parameter In addition to the interfaces, the Tc COM object "TCP/UDP RT" is the main component of the function. An instantiation usually takes place under the device: Double-click to open the instance, so that the parameters documented below can be used: TF6311 Version: 1.8.1 55
## Page 56

Programmer's reference Name Default Description value Tc Io Ip Settings. Ip Address 0.0.0.0 Own (local) IP address used for communication. Tc Io Ip Settings. Subnet Mask 0.0.0.0 Own subnet mask Tc Io Ip Settings. Gateway 0.0.0.0 Gateway used to reach communication partners outside your own network. Tc Io Ip Settings. Dhcp Enable FALSE Not yet implemented. Tc Io Ip Settings. Manual Settings FALSE Set to FALSE: The operating system uses the current IP configuration of the referenced adapter. Set to TRUE: Parameters of Tc Io Ip Settings* are used. Ip Max Receivers 4 Maximum number of permitted IP-based protocols. Ip Max Pending On Arp 40 Maximum number of entries in the ARP Request Table. Ip Mac Cache Size 64 Number of entries in MAC cache, i.e. IP address to MAC address allocations. Caching is implemented as LRU. Ip MTU 1514 Not yet implemented. (Maximum transport unit size for IP packets) Ip Recv Frame Queue Size 255 Number of entries in the queue for receiving Udp packets. Udp Max Receivers 4 Maximum number of UDP receivers Udp MTU 1514 From Twin CAT 3.1 Build 4026: Maximum Transport Unit size for UDP. Fragmentation is ready. In earlier versions (<= Build 4024) this parameter has no function Udp Check Crc TRUE Set to TRUE means that UDP packets with incorrect checksum are discarded. TTL 0x80 TTL in the IP header of the frames to be sent. Multi Cast TTL 0x01 TTL of the Multi Cast frames to be sent. Passive Mode FALSE If TRUE, no frames are fetched from the RT network adapter frames by this instance. See Multitask access to a network card [} 36] Multicast Ip List [] Multicast addresses for receiving Multi Cast packets. Tcp MTU 1514 Not yet implemented. (Maximum transport unit size for TCP) Tcp Check Crc TRUE Incoming TCP frames are checked for valid checksum and discarded, if the checksum is incorrect. Tcp Max Socket Count 32 Maximum number of sockets that are managed by the IP stack. Tcp Receive Buffer Size 16192 Number of received bytes that can be cached with a TCP connection. Tcp Transmit Buffer Size 16192 Number of bytes to be sent that can be cached in the TCP stack with a connection. Tcp Max Retry 5 Number of retries of TCP packets until the connection is terminated. Tcp Timeout Con 5000 Timeout for TCP connection establishment and disconnection. Tcp Timeout Wait 60000 Timespan for storing handles internally after an unexpected termination of the connection. Tcp Timeout Idle 1000 Time to callback (Reveive Event), if no response. Tcp Round Trip Time 3000 Start value for the timeout of data packets. Is adjusted dynamically depending on the connection quality (depending on the packet round-trip time). Times are given in milliseconds. 56 Version: 1.8.1 TF6311
## Page 57

Programmer's reference 7.3 TCP/UDP RT Tc Com diagnostics The Tc COM object TCP/UDP RT represents the coupling of customer project with the hardware. In addition to parameters, it therefore also contains diagnostic information, which is described here. Once Engineering can communicate with the target system and the program runs smoothly, various information is provided via the received and sent packets: Name Value Description Ip Stack Diagnosis … Diagnostic information of the IP stack .ip.n Send Cnt 18 Number of IP packets sent .ip.n Send Fail Cnt 0 Number of IP packets not sent .ip.n Recv Cnt 20 Number of packets received .ip.n Recv Fail Cnt 0 Number of packets not received .arp Request.n Send Cnt 0 Arp-Requests: Number of packets sent .arp Request.n Send Fail Cnt 0 Arp-Requests: Number of packets not sent .arp Request.n Recv Cnt 12 Arp-Requests: Number of packets received .arp Request.n Recv Fail Cnt 0 Arp-Requests: Number of packets not received .arp Reply.n Send Cnt 12 Arp-Reply: Number of packets sent .arp Reply.n Send Fail Cnt 0 Arp-Reply: Number of packets not sent .arp Reply.n Recv Cnt 0 Arp-Reply: Number of packets received .arp Reply.n Recv Fail Cnt 0 Arp-Reply: Number of packets not received .ping Request.n Send Cnt 0 Ping-Request: Number of packets sent .ping Request.n Send Fail Cnt 0 Ping-Request: Number of packets not sent .ping Request.n Recv Cnt 0 Ping-Request: Number of packets received .ping Request.n Recv Fail Cnt 0 Ping-Request: Number of packets not received .ping Reply.n Send Cnt 0 Ping-Reply: Number of packets sent .ping Reply.n Send Fail Cnt 0 Ping-Reply: Number of packets not sent .ping Reply.n Recv Cnt 0 Ping-Reply: Number of packets received .ping Reply.n Recv Fail Cnt 0 Ping-Reply: Number of packets not received .n Link Status Changed Cnt 1 Number of link changes .n Alloc Fail Cnt 0 Number of failed allocations .n Arp Timeout Frames 0 Number of arp frames in the timeout .n Dropped Frames 0 Number of discarded packages TF6311 Version: 1.8.1 57
## Page 58

Programmer's reference 7.4 TCP/IP: ITc Io Tcp Protocol(Recv) The ITc Io Tcp Protocol and ITc Io Tcp Protocol Recv interfaces enable TCP/IP communication from the real-time environment. A project that uses this interface contains a pointer to an ITc Io Tcp Protocol object and implements ITc Io Tcp Protocol Recv itself. ITc Io Tcp Protocol Recv serves as a callback interface for receiving data and events from the TCP/IP module within the application. The interfaces are based on a socket API. Before a socket can be used, it must be allocated with Alloc Socket(). ITc Io Tcp Protocol Recv methods: Name Description Receive Data [} 59] Is called by the TCP/UDP RT module as a callback to transfer data. Receive Event [} 60] Is called by the TCP/UDP RT module as a callback if an event has occurred. ITc Io Tcp Protocol methods: Name Description Alloc Socket [} 60] Allocates a socket. Free Socket [} 61] Enables a socket. Connect [} 61] Establishes a connection to a remote terminal. Is Connected [} 61] Indicates whether a socket is connected (for inbound and outbound connections). Close [} 62] Closes a socket. Listen [} 62] Opens a TCP port for incoming connections (see remarks). Accept [} 62] For server functionality: Accepts incoming connections (see remarks). Send Data [} 63] Sends data (server and client functionality). Check Received [} 63] Must be called cyclical; Receive Event and Receive Data are used as callback in the context of this method (server and client functionality). Get Remote Ip Addr [} 63] Returns the remote IP address of a communication partner. Get Free Send Data Size [} 64] Returns the number of free bytes in the TCP send buffer. Call Check Received() continuously. Perhaps call Alloc Socket() again in the event of an Online Change, in order to refresh the callback target. The client and server implementation process is described here, independent of programming languages. Only an overview is provided; the samples illustrate the application. 58 Version: 1.8.1 TF6311
## Page 59

Programmer's reference Implementation of an TCP server: Name Description Alloc Socket Opens a socket. [} 60] Listen [} 62] Opens a port on which connections are expected. Accept [} 62] Is called in the Receive Event() method in order to accept a connection. Receive Data Is called when data are received. [} 59] Send Data [} 63] Can be used to send data. Free Socket On the Listen socket and all connection sockets for stopping. [} 61] Code diagram for accepting a connection: HRESULT CIp Stack Demo::Receive Event(ULONG socket Id, TCPIP_EVENT tcp Event)... case TCPIP_EVENT_CONN_INCOMING: m_sp Tcp Prot->Accept(socket Id); break; Implementation of a TCP client: Name Description Alloc Socket Opens a socket. [} 60] Connect [} 61] Starts connection establishment. Is Connected Checks whether the connection was established successfully. [} 61] Receive Data Is called when data are received. [} 59] Send Data [} 63] Can be used to send data. Free Socket On the Listen socket and all connection sockets for stopping. [} 61] Disconnection by the operating system in Promiscuous mode If Promiscuous mode is active at the RT Ethernet adapter in the “Adapter” tab, any TCP connection attempts are blocked by the operating system, since it does not recognize a port opened in the TCP/UDP RT object. 7.4.1 Method ITc Io Tcp Protocol Recv:Receive Data Is called by the TCP/UDP RT module as a callback to transfer data. Syntax HRESULT TCOMAPI Receive Data(ULONG socket Id, ULONG n Data, PVOID p Data) Return value Name Type Description Receive Data HRESULT Indicates success and must be provided accordingly by the implemented module. TF6311 Version: 1.8.1 59
## Page 60

Programmer's reference Parameter Name Type Description socket Id ULONG The socket on which data was received. n Data ULONG Number of data received. p Data PVOID Pointer to the received data. 7.4.2 Method ITc Io Tcp Protocol Recv:Receive Event Is called by the TCP/UDP RT module as a callback if an event has occurred. Syntax HRESULT TCOMAPI Receive Event(ULONG socket Id, TCPIP_EVENT tcp Event) Return value Name Type Description Receive Event HRESULT Indicates success and must be provided accordingly by the implemented module. Parameter Name Type Description socket Id ULONG The socket on which data was received. tcp Event TCP_EVENT An element of the Enum. The enumeration TCP_EVENT refers to different events, which can occur with a TCP connection: enum TCPIP_EVENT : ULONG { TCPIP_EVENT_NONE = 0, TCPIP_EVENT_ERROR = 1, TCPIP_EVENT_RESET = 2, TCPIP_EVENT_TIMEOUT = 3, TCPIP_EVENT_CONN_ESTABLISHED = 4, TCPIP_EVENT_CONN_INCOMING = 5, TCPIP_EVENT_CONN_CLOSED = 6, TCPIP_EVENT_CONN_IDLE = 7, TCPIP_EVENT_DATA_RECEIVED = 8, TCPIP_EVENT_DATA_SENT = 9, TCPIP_EVENT_KEEP_ALIVE = 10, TCPIP_EVENT_LINKCONNECT = 11, TCPIP_EVENT_LINKDISCONNECT = 12 }; An implementation of the method should provide a switch case over all elements, so that the system can respond according to the event. The application of events for a TCP server is described in the interface overview. 7.4.3 Method ITc Io Tcp Protocol:Alloc Socket Allocates a socket. Syntax HRESULT TCOMAPI Alloc Socket(ITc Io Tcp Protocol Recv* ip Recv, ULONG& socket Id) Return value Type Description HRESULT Indicates success, see Return values [} 68]. 60 Version: 1.8.1 TF6311
## Page 61

Programmer's reference Parameter Name Type Description ip Recv ITc Io Tcp Protocol Recv Pointer to the receiver (Recv) interface. socket Id ULONG& The generated socket. 7.4.4 Method ITc Io Tcp Protocol:Free Socket Enables a socket. Syntax HRESULT TCOMAPI Alloc Socket(ULONG socket Id) Return value Type Description HRESULT Indicates success, see Return values [} 68]. Parameter Name Type Description socket Id ULONG The socket to be enabled. 7.4.5 Method ITc Io Tcp Protocol:Connect Establishes a connection to a remote terminal. Syntax HRESULT TCOMAPI Connect(ULONG socket Id, ULONG ip Remote Address, USHORT tcp Port) Return value Type Description HRESULT Indicates success, see Return values [} 68]. Parameter Name Type Description socket Id ULONG The socket to be used. ip Remote Address ULONG IP address of the remote terminal to be contacted. IP addresses are displayed with the most significant element in the last position. (Example: 192.168.2.1 -> 01 02 A8 C0) tcp Port USHORT Port of the remote terminal to be contacted. 7.4.6 Method ITc Io Tcp Protocol:Is Connected Indicates whether a socket is connected (for inbound and outbound connections). Syntax HRESULT TCOMAPI Is Connected(ULONG socket Id) TF6311 Version: 1.8.1 61
## Page 62

Programmer's reference Return value Type Description HRESULT Indicates success, see Return values [} 68]. Parameter Name Type Description socket Id ULONG The socket to be used. 7.4.7 Method ITc Io Tcp Protocol:Close Closes a socket. Syntax HRESULT TCOMAPI Close(ULONG socket Id) Return value Type Description HRESULT Indicates success, see Return values [} 68]. Parameter Name Type Description socket Id ULONG The socket to be closed. 7.4.8 Method ITc Io Tcp Protocol:Listen Opens a TCP port for incoming connections. The application is described in the interface overview. Syntax HRESULT TCOMAPI Listen(ULONG socket Id, USHORT tcp Port) Return value Type Description HRESULT Indicates success, see Return values [} 68]. Parameter Name Type Description socket Id ULONG The socket to be used. tcp Port USHORT The port which is scanned for incoming connections. 7.4.9 Method ITc Io Tcp Protocol:Accept Accepts income connections. The application is described in the interface overview. Syntax HRESULT TCOMAPI Accept(ULONG socket Id) 62 Version: 1.8.1 TF6311
## Page 63

Programmer's reference Return value Type Description HRESULT Indicates success, see Return values [} 68]. Parameter Name Type Description socket Id ULONG The socket to be used. 7.4.10 Method ITc Io Tcp Protocol:Send Data Sends data (server and client functionality). Syntax HRESULT TCOMAPI Send Data(ULONG socket Id, ULONG n Data, PVOID p Data, ULONG& n Send Data) Return value Type Description HRESULT Indicates success, see Return values [} 68]. Parameter Name Type Description socket Id ULONG The socket to be used. n Data ULONG Length of the data to be sent. p Data PVOID Pointer to the data to be sent. n Send Data ULONG& Returns the number of sent bytes. If this is smaller than n Data, the data should be re-sent. 7.4.11 Method ITc Io Tcp Protocol:Check Received Must be called cyclical; Receive Event and Receive Data are used as callback in the context of this method (server and client functionality). Syntax HRESULT TCOMAPI Check Received() Return value Type Description HRESULT Indicates success, see Return values [} 68]. Parameter - 7.4.12 Method ITc Io Tcp Protocol:Get Remote Ip Addr Returns the remote IP address of a communication partner. Syntax HRESULT TCOMAPI Get Remote Ip Addr(ULONG socket Id, ULONG& remote Ip Addr) TF6311 Version: 1.8.1 63
## Page 64

Programmer's reference Return value Type Description HRESULT Indicates success, see Return values [} 68]. Parameter Name Type Description socket Id ULONG The socket to be used. 7.4.13 Method ITc Io Tcp Protocol:Get Free Send Data Size Returns the number of free bytes in the TCP send buffer. Syntax HRESULT TCOMAPI Get Remote Ip Addr(ULONG socket Id, ULONG& n Data) Return value Type Description HRESULT Indicates success, see Return values [} 68]. Parameter Name Type Description socket Id ULONG The socket to be used. n Data ULONG& Returns the free bytes in the buffer. 7.5 ARP/Ping: ITc Io Arp Ping Protocol(Recv) The interfaces ITc Io Arp Ping Protocol and ITc Io Arp Ping Protocol Recv enable sending of ARP and Ping messages from the real-time environment. A project that uses this interface contains a pointer to an ITc Io Arp Ping Protocol object and implements ITc Io Arp Ping Protocol Recv itself. ITc Io Arp Ping Protocol Recv serves as callback interface for receiving data from the TCP/UDP RT module within the application. ITc Io Arp Ping Protocol Recv methods: Name Description Arp Reply [} 65] Callback function that is invoked when an Arp Reply message is received. Ping Reply [} 65] Callback function that is invoked when an Ping Reply message is received. If these methods return S_OK, the packet is regarded as processed and is not forwarded to the operating system. If necessary, S_FALSE should be returned. 64 Version: 1.8.1 TF6311
## Page 65

Programmer's reference ITc Io Arp Ping Protocol methods: Name Description Arp Request [} 66] Sends an Arp Request Ping Request [} 66] Sends a Ping Request Register Receiver [} 67] Registering at the TCP/UDP RT module for receiving data. Unregister Receiver [} 67] Unregistering at the TCP/UDP RT module for receiving data. Check Received [} 68] Must be called cyclically; Arp Reply and Ping Reply are used as callback in the context of this method To receive ARP or Ping data, registration is required by calling Register Receiver. This can be done in Set Obj State SO(). Data is provided by a callback of method Arp Receive or Ping Receive from ITc Io Arp Ping Protocol Recv. During the shutdown, all modules should unregister via Unregister Receiver. This can be done in Set Obj State OS(). 7.5.1 Method ITc Io Arp Ping Protocol Recv:Ping Reply Callback function that is invoked when an Ping Reply message is received. Syntax HRESULT TCOMAPI Ping Reply(ULONG ip Addr, ULONG n Data, PVOID p Data, ETYPE_VLAN_HEADER* p Vlan=0) Return value Type Description HRESULT Indicates success and must be provided accordingly by the implemented module. If this is not S_OK, the response continues to be transferred to the operating system. Parameter Name Type Description ip Addr ULONG The IP address of the search. n Data ULONG Number of bytes received. p Data PVOID Pointer to the received data. p Vlan ETYPE_VLAN_HEADER* ETYPE_VLAN_HEADER structure, see below. The VLAN header represents information about the VLAN. typedef struct _ETYPE_VLAN_HEADER { USHORT VLan Type; unsigned short VLan Id H : 4; unsigned short reserved1 : 1; unsigned short Priority : 3; unsigned short VLan Id L : 8; } ETYPE_VLAN_HEADER, *PETYPE_VLAN_HEADER; 7.5.2 Method ITc Io Arp Ping Protocol Recv:Arp Reply Callback function that is invoked when an Arp Reply message is received. Syntax HRESULT TCOMAPI Arp Reply(ULONG ip Addr, ETHERNET_ADDRESS mac Addr, ETYPE_VLAN_HEADER* p Vlan=0) TF6311 Version: 1.8.1 65
## Page 66

Programmer's reference Return value Type Description HRESULT Indicates success and must be provided accordingly by the implemented module. If this is not S_OK, the response continues to be transferred to the operating system. Parameter Name Type Description ip Addr ULONG The IP address of the search. mac Addr ETHERNET_ADDRESS Determined MAC address. p Vlan ETYPE_VLAN_HEADER* ETYPE_VLAN_HEADER structure, see below. The VLAN header represents information about the VLAN. typedef struct _ETYPE_VLAN_HEADER { USHORT VLan Type; unsigned short VLan Id H : 4; unsigned short reserved1 : 1; unsigned short Priority : 3; unsigned short VLan Id L : 8; } ETYPE_VLAN_HEADER, *PETYPE_VLAN_HEADER; 7.5.3 Method ITc Io Arp Ping Protocol:Ping Request Sends a ping request. Syntax HRESULT TCOMAPI Ping Request(ULONG ip Addr, ULONG n Data=0, PVOID p Data=0, ETYPE_VLAN_HEADER* p Vlan=0) Return value Type Description HRESULT Indicates success, see Return values [} 68]. Parameter Name Type Description ip Addr ULONG The IP address of the target. n Data ULONG Number of bytes received. p Data PVOID Pointer to the received data. p Vlan ETYPE_VLAN_HEADER* ETYPE_VLAN_HEADER structure, see below. The VLAN header represents information about the VLAN. typedef struct _ETYPE_VLAN_HEADER { USHORT VLan Type; unsigned short VLan Id H : 4; unsigned short reserved1 : 1; unsigned short Priority : 3; unsigned short VLan Id L : 8; } ETYPE_VLAN_HEADER, *PETYPE_VLAN_HEADER; 7.5.4 Method ITc Io Arp Ping Protocol:Arp Request Sends an ARP request. Syntax HRESULT TCOMAPI Arp Request(ULONG ip Addr, ETHERNET_ADDRESS* mac Addr=0, ETYPE_VLAN_HEADER* p Vlan=0) 66 Version: 1.8.1 TF6311
## Page 67

Programmer's reference Return value Type Description HRESULT Indicates success, see Return values [} 68]. Parameter Name Type Description ip Addr ULONG The IP address of the target. mac Addr ETHERNET_ADDRESS* Restriction of the MAC address. p Vlan ETYPE_VLAN_HEADER* ETYPE_VLAN_HEADER structure, see below. The VLAN header represents information about the VLAN. typedef struct _ETYPE_VLAN_HEADER { USHORT VLan Type; unsigned short VLan Id H : 4; unsigned short reserved1 : 1; unsigned short Priority : 3; unsigned short VLan Id L : 8; } ETYPE_VLAN_HEADER, *PETYPE_VLAN_HEADER; 7.5.5 Method ITc Io Arp Ping Protocol:Register Receiver Registering at the TCP/UDP RT module for receiving responses (ARP / Ping). Syntax HRESULT TCOMAPI Register Receiver(ITc Io Arp Ping Recv* ip Recv) Return value Type Description HRESULT Indicates success, see Return values [} 68]. Parameter Name Type Description ip Recv ITc Io Arp Ping Recv* Pointer to the receiver (Recv) interface. 7.5.6 Method ITc Io Arp Ping Protocol:Unregister Receiver Unregistering at the TCP/UDP RT module for receiving responses (ARP / Ping). Syntax HRESULT TCOMAPI Unregister Receiver(ITc Io Arp Ping Recv* ip Recv) Return value Type Description HRESULT Indicates success, see Return values [} 68]. Parameter Name Type Description ip Recv ITc Io Arp Ping Recv Reference to the receiver to be unregistered TF6311 Version: 1.8.1 67
## Page 68

Programmer's reference 7.5.7 Method ITc Io Arp Ping Protocol:Check Received Must be called cyclically; Arp Reply and Ping Reply are used as callback in the context of this method. Syntax HRESULT TCOMAPI Check Received() Return value Type Description HRESULT Indicates success, see Return values [} 68]. 7.6 Return values The interface functions have HRESULT as return values. The returned values are derived from the ADS Return Codes [} 70]. Their meaning for TF6311: Value Value Description (Enum) (Numeric) ADS_E_INVALI 0x9811070B Socket not allocated/known, transferred pointer NULL DPARM ADS_E_NOMO 0x98110716 No free sockets available. REHDLS Default: 32 see TCP/UDP RT Tc Com Parameter [} 55] ADS_E_INCOM 0x9811070E Socket in wrong state. PATIBLE E.g. Connect() attempt, if a socket was previous used with Listen(); Close() without previous connection; Send() without connection; Socket Listen(), if a Listen() call was already issued. ADS_E_INVALI 0x98110712 TCP/UDP RT object is not in OP mode DSTATE ADS_E_INVALI 0x98110706 Problem with parameter. DDATA E.g. p Data==NULL for Send Data ADS_E_EXIST 0x9811070F Port already used otherwise S ADS_E_PENDI 0x9811071E Not all data were sent (Send Data) NG S_OK 0x0 Call successful. Is Connected(): Connection exists S_FAIL 0x1 Call not successful, general error Is Connected(): Connection does not exist The values from the range 0x9811 are defined in the enumeration "E_HRESULTAds Err" (PLC) and corresponding ADS_E_* (C++) "defines". 68 Version: 1.8.1 TF6311
## Page 69

Fault analysis 8 Fault analysis At this point, it is usual practice to list problems or situations in connection with handling the product, together with an error description. 8.1 Start-up: Ip Stack ADS 1823 / 0x71f If ADS error 1823 (0x71f) occurs when an IP stack Tc COM object is started, the configuration of the network card is probably incorrect. Check the settings under "Adapter" for the network card in the Solution: The configuration of the network card for the TCP/UDP RT module is documented in more detail here [} 14]. TF6311 Version: 1.8.1 69
## Page 70

Appendix 9 Appendix 9.1 ADS Return Codes Grouping of error codes: Global error codes: ADS Return Codes [} 70]... (0x9811_0000 ...) Router error codes: ADS Return Codes [} 70]... (0x9811_0500 ...) General ADS errors: ADS Return Codes [} 71]... (0x9811_0700 ...) RTime error codes: ADS Return Codes [} 73]... (0x9811_1000 ...) Global error codes Hex Dec HRESULT Name Description 0x0 0 0x98110000 ERR_NOERROR No error. 0x1 1 0x98110001 ERR_INTERNAL Internal error. 0x2 2 0x98110002 ERR_NORTIME No real time. 0x3 3 0x98110003 ERR_ALLOCLOCKEDMEM Allocation locked – memory error. 0x4 4 0x98110004 ERR_INSERTMAILBOX Mailbox full – the ADS message could not be sent. Reducing the number of ADS messages per cycle will help. 0x5 5 0x98110005 ERR_WRONGRECEIVEHMSG Wrong HMSG. 0x6 6 0x98110006 ERR_TARGETPORTNOTFOUND Target port not found – ADS server is not started, not reachable or not installed. 0x7 7 0x98110007 ERR_TARGETMACHINENOTFOUND Target computer not found – AMS route was not found. 0x8 8 0x98110008 ERR_UNKNOWNCMDID Unknown command ID. 0x9 9 0x98110009 ERR_BADTASKID Invalid task ID. 0x A 10 0x9811000A ERR_NOIO No IO. 0x B 11 0x9811000B ERR_UNKNOWNAMSCMD Unknown AMS command. 0x C 12 0x9811000C ERR_WIN32ERROR Win32 error. 0x D 13 0x9811000D ERR_PORTNOTCONNECTED Port not connected. 0x E 14 0x9811000E ERR_INVALIDAMSLENGTH Invalid AMS length. 0x F 15 0x9811000F ERR_INVALIDAMSNETID Invalid AMS Net ID. 0x10 16 0x98110010 ERR_LOWINSTLEVEL Installation level is too low –Twin CAT 2 license error. 0x11 17 0x98110011 ERR_NODEBUGINTAVAILABLE No debugging available. 0x12 18 0x98110012 ERR_PORTDISABLED Port disabled – Twin CAT system service not started. 0x13 19 0x98110013 ERR_PORTALREADYCONNECTED Port already connected. 0x14 20 0x98110014 ERR_AMSSYNC_W32ERROR AMS Sync Win32 error. 0x15 21 0x98110015 ERR_AMSSYNC_TIMEOUT AMS Sync Timeout. 0x16 22 0x98110016 ERR_AMSSYNC_AMSERROR AMS Sync error. 0x17 23 0x98110017 ERR_AMSSYNC_NOINDEXINMAP No index map for AMS Sync available. 0x18 24 0x98110018 ERR_INVALIDAMSPORT Invalid AMS port. 0x19 25 0x98110019 ERR_NOMEMORY No memory. 0x1A 26 0x9811001A ERR_TCPSEND TCP send error. 0x1B 27 0x9811001B ERR_HOSTUNREACHABLE Host unreachable. 0x1C 28 0x9811001C ERR_INVALIDAMSFRAGMENT Invalid AMS fragment. 0x1D 29 0x9811001D ERR_TLSSEND TLS send error – secure ADS connection failed. 0x1E 30 0x9811001E ERR_ACCESSDENIED Access denied – secure ADS access denied. Router error codes 70 Version: 1.8.1 TF6311
## Page 71

Appendix Hex Dec HRESULT Name Description 0x500 1280 0x98110500 ROUTERERR_NOLOCKEDMEMORY Locked memory cannot be allocated. 0x501 1281 0x98110501 ROUTERERR_RESIZEMEMORY The router memory size could not be changed. 0x502 1282 0x98110502 ROUTERERR_MAILBOXFULL The mailbox has reached the maximum number of possible messages. 0x503 1283 0x98110503 ROUTERERR_DEBUGBOXFULL The Debug mailbox has reached the maximum number of possible messages. 0x504 1284 0x98110504 ROUTERERR_UNKNOWNPORTTYPE The port type is unknown. 0x505 1285 0x98110505 ROUTERERR_NOTINITIALIZED The router is not initialized. 0x506 1286 0x98110506 ROUTERERR_PORTALREADYINUSE The port number is already assigned. 0x507 1287 0x98110507 ROUTERERR_NOTREGISTERED The port is not registered. 0x508 1288 0x98110508 ROUTERERR_NOMOREQUEUES The maximum number of ports has been reached. 0x509 1289 0x98110509 ROUTERERR_INVALIDPORT The port is invalid. 0x50A 1290 0x9811050A ROUTERERR_NOTACTIVATED The router is not active. 0x50B 1291 0x9811050B ROUTERERR_FRAGMENTBOXFULL The mailbox has reached the maximum number for fragmented messages. 0x50C 1292 0x9811050C ROUTERERR_FRAGMENTTIMEOUT A fragment timeout has occurred. 0x50D 1293 0x9811050D ROUTERERR_TOBEREMOVED The port is removed. General ADS error codes TF6311 Version: 1.8.1 71
## Page 72

Appendix Hex Dec HRESULT Name Description 0x700 1792 0x98110700 ADSERR_DEVICE_ERROR General device error. 0x701 1793 0x98110701 ADSERR_DEVICE_SRVNOTSUPP Service is not supported by the server. 0x702 1794 0x98110702 ADSERR_DEVICE_INVALIDGRP Invalid index group. 0x703 1795 0x98110703 ADSERR_DEVICE_INVALIDOFFSET Invalid index offset. 0x704 1796 0x98110704 ADSERR_DEVICE_INVALIDACCESS Reading or writing not permitted. 0x705 1797 0x98110705 ADSERR_DEVICE_INVALIDSIZE Parameter size not correct. 0x706 1798 0x98110706 ADSERR_DEVICE_INVALIDDATA Invalid data values. 0x707 1799 0x98110707 ADSERR_DEVICE_NOTREADY Device is not ready to operate. 0x708 1800 0x98110708 ADSERR_DEVICE_BUSY Device is busy. 0x709 1801 0x98110709 ADSERR_DEVICE_INVALIDCONTEXT Invalid operating system context. This can result from use of ADS blocks in different tasks. It may be possible to resolve this through multitasking synchronization in the PLC. 0x70A 1802 0x9811070A ADSERR_DEVICE_NOMEMORY Insufficient memory. 0x70B 1803 0x9811070B ADSERR_DEVICE_INVALIDPARM Invalid parameter values. 0x70C 1804 0x9811070C ADSERR_DEVICE_NOTFOUND Not found (files, ...). 0x70D 1805 0x9811070D ADSERR_DEVICE_SYNTAX Syntax error in file or command. 0x70E 1806 0x9811070E ADSERR_DEVICE_INCOMPATIBLE Objects do not match. 0x70F 1807 0x9811070F ADSERR_DEVICE_EXISTS Object already exists. 0x710 1808 0x98110710 ADSERR_DEVICE_SYMBOLNOTFOUND Symbol not found. 0x711 1809 0x98110711 ADSERR_DEVICE_SYMBOLVERSIONINVALID Invalid symbol version. This can occur due to an online change. Create a new handle. 0x712 1810 0x98110712 ADSERR_DEVICE_INVALIDSTATE Device (server) is in invalid state. 0x713 1811 0x98110713 ADSERR_DEVICE_TRANSMODENOTSUPP Ads Trans Mode not supported. 0x714 1812 0x98110714 ADSERR_DEVICE_NOTIFYHNDINVALID Notification handle is invalid. 0x715 1813 0x98110715 ADSERR_DEVICE_CLIENTUNKNOWN Notification client not registered. 0x716 1814 0x98110716 ADSERR_DEVICE_NOMOREHDLS No further handle available. 0x717 1815 0x98110717 ADSERR_DEVICE_INVALIDWATCHSIZE Notification size too large. 0x718 1816 0x98110718 ADSERR_DEVICE_NOTINIT Device not initialized. 0x719 1817 0x98110719 ADSERR_DEVICE_TIMEOUT Device has a timeout. 0x71A 1818 0x9811071A ADSERR_DEVICE_NOINTERFACE Interface query failed. 0x71B 1819 0x9811071B ADSERR_DEVICE_INVALIDINTERFACE Wrong interface requested. 0x71C 1820 0x9811071C ADSERR_DEVICE_INVALIDCLSID Class ID is invalid. 0x71D 1821 0x9811071D ADSERR_DEVICE_INVALIDOBJID Object ID is invalid. 0x71E 1822 0x9811071E ADSERR_DEVICE_PENDING Request pending. 0x71F 1823 0x9811071F ADSERR_DEVICE_ABORTED Request is aborted. 0x720 1824 0x98110720 ADSERR_DEVICE_WARNING Signal warning. 0x721 1825 0x98110721 ADSERR_DEVICE_INVALIDARRAYIDX Invalid array index. 0x722 1826 0x98110722 ADSERR_DEVICE_SYMBOLNOTACTIVE Symbol not active. 0x723 1827 0x98110723 ADSERR_DEVICE_ACCESSDENIED Access denied. 0x724 1828 0x98110724 ADSERR_DEVICE_LICENSENOTFOUND Missing license. 0x725 1829 0x98110725 ADSERR_DEVICE_LICENSEEXPIRED License expired. 0x726 1830 0x98110726 ADSERR_DEVICE_LICENSEEXCEEDED License exceeded. 0x727 1831 0x98110727 ADSERR_DEVICE_LICENSEINVALID Invalid license. 0x728 1832 0x98110728 ADSERR_DEVICE_LICENSESYSTEMID License problem: System ID is invalid. 0x729 1833 0x98110729 ADSERR_DEVICE_LICENSENOTIMELIMIT License not limited in time. 0x72A 1834 0x9811072A ADSERR_DEVICE_LICENSEFUTUREISSUE Licensing problem: time in the future. 0x72B 1835 0x9811072B ADSERR_DEVICE_LICENSETIMETOLONG License period too long. 0x72C 1836 0x9811072C ADSERR_DEVICE_EXCEPTION Exception at system startup. 0x72D 1837 0x9811072D ADSERR_DEVICE_LICENSEDUPLICATED License file read twice. 0x72E 1838 0x9811072E ADSERR_DEVICE_SIGNATUREINVALID Invalid signature. 0x72F 1839 0x9811072F ADSERR_DEVICE_CERTIFICATEINVALID Invalid certificate. 0x730 1840 0x98110730 ADSERR_DEVICE_LICENSEOEMNOTFOUND Public key not known from OEM. 0x731 1841 0x98110731 ADSERR_DEVICE_LICENSERESTRICTED License not valid for this system ID. 0x732 1842 0x98110732 ADSERR_DEVICE_LICENSEDEMODENIED Demo license prohibited. 0x733 1843 0x98110733 ADSERR_DEVICE_INVALIDFNCID Invalid function ID. 0x734 1844 0x98110734 ADSERR_DEVICE_OUTOFRANGE Outside the valid range. 0x735 1845 0x98110735 ADSERR_DEVICE_INVALIDALIGNMENT Invalid alignment. 0x736 1846 0x98110736 ADSERR_DEVICE_LICENSEPLATFORM Invalid platform level. 72 Version: 1.8.1 TF6311
## Page 73

Appendix Hex Dec HRESULT Name Description 0x737 1847 0x98110737 ADSERR_DEVICE_FORWARD_PL Context – forward to passive level. 0x738 1848 0x98110738 ADSERR_DEVICE_FORWARD_DL Context – forward to dispatch level. 0x739 1849 0x98110739 ADSERR_DEVICE_FORWARD_RT Context – forward to real time. 0x740 1856 0x98110740 ADSERR_CLIENT_ERROR Client error. 0x741 1857 0x98110741 ADSERR_CLIENT_INVALIDPARM Service contains an invalid parameter. 0x742 1858 0x98110742 ADSERR_CLIENT_LISTEMPTY Polling list is empty. 0x743 1859 0x98110743 ADSERR_CLIENT_VARUSED Var connection already in use. 0x744 1860 0x98110744 ADSERR_CLIENT_DUPLINVOKEID The called ID is already in use. 0x745 1861 0x98110745 ADSERR_CLIENT_SYNCTIMEOUT Timeout has occurred – the remote terminal is not responding in the specified ADS timeout. The route setting of the remote terminal may be configured incorrectly. 0x746 1862 0x98110746 ADSERR_CLIENT_W32ERROR Error in Win32 subsystem. 0x747 1863 0x98110747 ADSERR_CLIENT_TIMEOUTINVALID Invalid client timeout value. 0x748 1864 0x98110748 ADSERR_CLIENT_PORTNOTOPEN Port not open. 0x749 1865 0x98110749 ADSERR_CLIENT_NOAMSADDR No AMS address. 0x750 1872 0x98110750 ADSERR_CLIENT_SYNCINTERNAL Internal error in Ads sync. 0x751 1873 0x98110751 ADSERR_CLIENT_ADDHASH Hash table overflow. 0x752 1874 0x98110752 ADSERR_CLIENT_REMOVEHASH Key not found in the table. 0x753 1875 0x98110753 ADSERR_CLIENT_NOMORESYM No symbols in the cache. 0x754 1876 0x98110754 ADSERR_CLIENT_SYNCRESINVALID Invalid response received. 0x755 1877 0x98110755 ADSERR_CLIENT_SYNCPORTLOCKED Sync Port is locked. 0x756 1878 0x98110756 ADSERR_CLIENT_REQUESTCANCELLED The request was cancelled. RTime error codes Hex Dec HRESULT Name Description 0x1000 4096 0x98111000 RTERR_INTERNAL Internal error in the real-time system. 0x1001 4097 0x98111001 RTERR_BADTIMERPERIODS Timer value is not valid. 0x1002 4098 0x98111002 RTERR_INVALIDTASKPTR Task pointer has the invalid value 0 (zero). 0x1003 4099 0x98111003 RTERR_INVALIDSTACKPTR Stack pointer has the invalid value 0 (zero). 0x1004 4100 0x98111004 RTERR_PRIOEXISTS The request task priority is already assigned. 0x1005 4101 0x98111005 RTERR_NOMORETCB No free TCB (Task Control Block) available. The maximum number of TCBs is 64. 0x1006 4102 0x98111006 RTERR_NOMORESEMAS No free semaphores available. The maximum number of semaphores is 64. 0x1007 4103 0x98111007 RTERR_NOMOREQUEUES No free space available in the queue. The maximum number of positions in the queue is 64. 0x100D 4109 0x9811100D RTERR_EXTIRQALREADYDEF An external synchronization interrupt is already applied. 0x100E 4110 0x9811100E RTERR_EXTIRQNOTDEF No external sync interrupt applied. 0x100F 4111 0x9811100F RTERR_EXTIRQINSTALLFAILED Application of the external synchronization interrupt has failed. 0x1010 4112 0x98111010 RTERR_IRQLNOTLESSOREQUAL Call of a service function in the wrong context 0x1017 4119 0x98111017 RTERR_VMXNOTSUPPORTED Intel VT-x extension is not supported. 0x1018 4120 0x98111018 RTERR_VMXDISABLED Intel VT-x extension is not enabled in the BIOS. 0x1019 4121 0x98111019 RTERR_VMXCONTROLSMISSING Missing function in Intel VT-x extension. 0x101A 4122 0x9811101A RTERR_VMXENABLEFAILS Activation of Intel VT-x fails. Specific positive HRESULT Return Codes: HRESULT Name Description 0x0000_0000 S_OK No error. 0x0000_0001 S_FALSE No error. Example: successful processing, but with a negative or incomplete result. 0x0000_0203 S_PENDING No error. Example: successful processing, but no result is available yet. 0x0000_0256 S_WATCHDOG_TIMEOUT No error. Example: successful processing, but a timeout occurred. TCP Winsock error codes TF6311 Version: 1.8.1 73
## Page 74

Appendix Hex Dec Name Description 0x274C 10060 WSAETIMEDOUT A connection timeout has occurred - error while establishing the connection, because the remote terminal did not respond properly after a certain period of time, or the established connection could not be maintained because the connected host did not respond. 0x274D 10061 WSAECONNREFUSED Connection refused - no connection could be established because the target computer has explicitly rejected it. This error usually results from an attempt to connect to a service that is inactive on the external host, that is, a service for which no server application is running. 0x2751 10065 WSAEHOSTUNREACH No route to host - a socket operation referred to an unavailable host. More Winsock error codes: Win32 error codes 74 Version: 1.8.1 TF6311
## Page 76

More Information: www.beckhoff.com/tf6311 Beckhoff Automation Gmb H & Co. KG Hülshorstweg 20 33415 Verl Germany Phone: +49 5246 9630 info@beckhoff.com www.beckhoff.com
