---
title: "TE1000 Twin CAT 3"
product: "TwinCAT"
category: "Communication"
tags: ["ADS", "CAT", "TWIN"]
language: "EN"
document_type: "Manual"
version: "1.1.3"
source_pdf: "https://download.beckhoff.com/download/Document/automation/twincat3/TwinCAT_ADS-DLL_C_EN.pdf"
release_date: "2024-07-18"
---
Manual | EN TE1000 Twin CAT 3 | ADS-DLL C++ 2024-07-18 | Version: 1.1.3
## Page 3

Table of contents Table of contents 1 Foreword.................................................................................................................................................... 5 1.1 Notes on the documentation............................................................................................................. 5 1.2 For your safety.................................................................................................................................. 5 1.3 Notes on information security............................................................................................................ 7 2 Introduction............................................................................................................................................... 8 3 C++ API...................................................................................................................................................... 9 3.1 Functions........................................................................................................................................... 9 3.1.1 Ads Get Dll Version............................................................................................................... 9 3.1.2 Ads Port Open...................................................................................................................... 9 3.1.3 Ads Port Close..................................................................................................................... 9 3.1.4 Ads Get Local Address....................................................................................................... 10 3.1.5 Ads Sync Write Req............................................................................................................ 10 3.1.6 Ads Sync Read Req............................................................................................................ 11 3.1.7 Ads Sync Read Req Ex........................................................................................................ 11 3.1.8 Ads Sync Read Write Req................................................................................................... 12 3.1.9 Ads Sync Read Write Req Ex............................................................................................... 12 3.1.10 Ads Sync Read Device Info Req........................................................................................... 13 3.1.11 Ads Sync Write Control Req................................................................................................ 14 3.1.12 Ads Sync Read State Req................................................................................................... 14 3.1.13 Ads Sync Add Device Notification Req................................................................................. 15 3.1.14 Ads Sync Del Device Notification Req.................................................................................. 16 3.1.15 Ads Sync Set Timeout......................................................................................................... 16 3.1.16 Ads Ams Register Router Notification.................................................................................. 17 3.1.17 Ads Ams Un Register Router Notification............................................................................. 17 3.1.18 PAms Router Notification Func Ex....................................................................................... 17 3.1.19 PAds Notification Func Ex................................................................................................... 18 3.1.20 Extended Functions (for multithreaded applications)....................................................... 18 3.2 Structures........................................................................................................................................ 26 3.2.1 Ams Addr.......................................................................................................................... 26 3.2.2 Ams Net Id......................................................................................................................... 26 3.2.3 Ads Version....................................................................................................................... 27 3.2.4 Ads Notification Attrib......................................................................................................... 27 3.2.5 Ads Notification Header..................................................................................................... 28 3.3 Enums............................................................................................................................................. 29 3.3.1 ADSSTATE...................................................................................................................... 29 3.3.2 ADSTRANSMODE........................................................................................................... 29 4 COM.......................................................................................................................................................... 30 4.1 Classes........................................................................................................................................... 30 4.1.1 Tc Ads Dll::Classes............................................................................................................ 30 4.1.2 Tc Client............................................................................................................................ 30 4.1.3 Tc Ads Sync....................................................................................................................... 30 4.2 Interfaces........................................................................................................................................ 31 4.2.1 ITc Client........................................................................................................................... 31 TE1000 Version: 1.1.3 3
## Page 4

Table of contents 4.2.2 ITc Ads Sync...................................................................................................................... 32 4.2.3 _ITc Ads Sync Event........................................................................................................... 37 4.3 Structures........................................................................................................................................ 37 4.3.1 Ads Version....................................................................................................................... 37 4.3.2 Time Stamp....................................................................................................................... 38 4.4 Enums............................................................................................................................................. 38 4.4.1 ADSERRORCODES........................................................................................................ 38 4.4.2 ADSSTATE...................................................................................................................... 40 4.4.3 ADSTRANSMODE........................................................................................................... 40 5 Integration................................................................................................................................................ 41 5.1 Linking C++ ADS library for Twin CAT 3 in Visual Studio................................................................ 41 6 Samples................................................................................................................................................... 42 6.1 Read DLL version........................................................................................................................... 44 6.2 Write flag synchronously into the PLC............................................................................................ 44 6.3 Read flag synchronously from the PLC........................................................................................... 44 6.4 Read ADS status............................................................................................................................. 45 6.5 Read ADS information.................................................................................................................... 46 6.6 Start/stop PLC................................................................................................................................. 46 6.7 Access an array in the PLC............................................................................................................. 47 6.8 Event driven reading....................................................................................................................... 48 6.9 Access by variable name................................................................................................................ 50 6.10 Read PLC variable declaration....................................................................................................... 51 6.11 Detect status change in Twin CAT router and the PLC................................................................... 52 6.12 Event-Driven Detection of Changes to the Symbol Table............................................................... 53 6.13 Reading the PLC variable declaration of an individual variable...................................................... 54 6.14 Upload PLC-variabledeclaration (dynamic) (2/2)............................................................................ 56 6.15 ADS-sum command: Read or Write a list of variables with one single ADS-command.................. 57 6.16 ADS-sum command: Get and release several handles.................................................................. 59 6.17 Transmitting structures to the PLC.................................................................................................. 62 6.18 Reading and writing of TIME/DATE variables................................................................................. 63 4 Version: 1.1.3 TE1000
## Page 5

Foreword 1 Foreword 1.1 Notes on the documentation This description is intended exclusively for trained specialists in control and automation technology who are familiar with the applicable national standards. For installation and commissioning of the components, it is absolutely necessary to observe the documentation and the following notes and explanations. The qualified personnel is obliged to always use the currently valid documentation. The responsible staff must ensure that the application or use of the products described satisfies all requirements for safety, including all the relevant laws, regulations, guidelines, and standards. Disclaimer The documentation has been prepared with care. The products described are, however, constantly under development. We reserve the right to revise and change the documentation at any time and without notice. No claims to modify products that have already been supplied may be made on the basis of the data, diagrams, and descriptions in this documentation. Trademarks Beckhoff®, Twin CAT®, Twin CAT/BSD®, TC/BSD®, Ether CAT®, Ether CAT G®, Ether CAT G10®, Ether CAT P®, Safety over Ether CAT®, Twin SAFE®, XFC®, XTS® and XPlanar® are registered and licensed trademarks of Beckhoff Automation Gmb H. If third parties make use of designations or trademarks used in this publication for their own purposes, this could infringe upon the rights of the owners of the said designations. Patents The Ether CAT Technology is covered, including but not limited to the following patent applications and patents: EP1590927, EP1789857, EP1456722, EP2137893, DE102015105702 and similar applications and registrations in several other countries. Ether CAT® is registered trademark and patented technology, licensed by Beckhoff Automation Gmb H, Germany Copyright © Beckhoff Automation Gmb H & Co. KG, Germany. The distribution and reproduction of this document as well as the use and communication of its contents without express authorization are prohibited. Offenders will be held liable for the payment of damages. All rights reserved in the event that a patent, utility model, or design are registered. 1.2 For your safety Safety regulations Read the following explanations for your safety. Always observe and follow product-specific safety instructions, which you may find at the appropriate places in this document. TE1000 Version: 1.1.3 5
## Page 6

Foreword Exclusion of liability All the components are supplied in particular hardware and software configurations which are appropriate for the application. Modifications to hardware or software configurations other than those described in the documentation are not permitted, and nullify the liability of Beckhoff Automation Gmb H & Co. KG. Personnel qualification This description is only intended for trained specialists in control, automation, and drive technology who are familiar with the applicable national standards. Signal words The signal words used in the documentation are classified below. In order to prevent injury and damage to persons and property, read and follow the safety and warning notices. Personal injury warnings DANGER Hazard with high risk of death or serious injury. WARNING Hazard with medium risk of death or serious injury. CAUTION There is a low-risk hazard that could result in medium or minor injury. Warning of damage to property or environment NOTICE The environment, equipment, or data may be damaged. Information on handling the product This information includes, for example: recommendations for action, assistance or further information on the product. 6 Version: 1.1.3 TE1000
## Page 7

Foreword 1.3 Notes on information security The products of Beckhoff Automation Gmb H & Co. KG (Beckhoff), insofar as they can be accessed online, are equipped with security functions that support the secure operation of plants, systems, machines and networks. Despite the security functions, the creation, implementation and constant updating of a holistic security concept for the operation are necessary to protect the respective plant, system, machine and networks against cyber threats. The products sold by Beckhoff are only part of the overall security concept. The customer is responsible for preventing unauthorized access by third parties to its equipment, systems, machines and networks. The latter should be connected to the corporate network or the Internet only if appropriate protective measures have been set up. In addition, the recommendations from Beckhoff regarding appropriate protective measures should be observed. Further information regarding information security and industrial security can be found in our https://www.beckhoff.com/secguide. Beckhoff products and solutions undergo continuous further development. This also applies to security functions. In light of this continuous further development, Beckhoff expressly recommends that the products are kept up to date at all times and that updates are installed for the products once they have been made available. Using outdated or unsupported product versions can increase the risk of cyber threats. To stay informed about information security for Beckhoff products, subscribe to the RSS feed at https:// www.beckhoff.com/secinfo. TE1000 Version: 1.1.3 7
## Page 8

Introduction 2 Introduction The Tc Ads Dll provides functions for communication with other ADS devices. • Communication to local Twin CAT systems or remote Twin CAT systems via the Twin CAT Message router. • Communication to remote Twin CAT systems via TCP/IP for Win32 Systems. The Tc Ads Dll provides the Twin CAT Ads Client functions. These functions are provided in 2 different ways: • By C API. • By COM interfaces [} 30] It is recommended to use the Twin CAT CP (royalty free) version with the library. 8 Version: 1.1.3 TE1000
## Page 9

C++ API 3 C++ API 3.1 Functions 3.1.1 Ads Get Dll Version Returns the version number, revision number and build number of the ADS-DLL. LONG Ads Get Dll Version( void ); Parameter - Return value The return value, which is of type long, contains in coded form these three items related to the ADS-DLL. Example See example 1 [} 44]. 3.1.2 Ads Port Open Establishes a connection (communication port) to the Twin CAT message router. LONG Ads Port Open( void ); Parameter - Return value A port number that has been assigned to the program by the ADS router is returned. Example See example 2 [} 44]. 3.1.3 Ads Port Close The connection (communication port) to the Twin CAT message router is closed. LONG Ads Port Close( void ); Parameter - Return value Returns the function's error status. TE1000 Version: 1.1.3 9
## Page 10

C++ API Example See example 2 [} 44]. 3.1.4 Ads Get Local Address Returns the local Net Id and port number. LONG Ads Get Local Address( PAms Addr p Addr ); Parameter p Addr [out] Pointer to the structure of type Ams Addr [} 26]. Return value Returns the function's error status. Example See example 2 [} 44]. 3.1.5 Ads Sync Write Req Writes data synchronously to an ADS device. LONG Ads Sync Write Req( PAms Addr p Addr, ULONG n Index Group, ULONG n Index Offset, ULONG n Length, PVOID p Data ); Parameter p Addr [in] Structure with Net Id [} 26] and port number of the ADS server. n Index Group [in] Index Group. n Index Offset [in] Index Offset. n Length [in] Length of the data, in bytes, written to the ADS server. p Data [in] Pointer to the data written to the ADS server. Return value Returns the function's error status. Example See example 2 [} 44]. 10 Version: 1.1.3 TE1000
## Page 11

C++ API 3.1.6 Ads Sync Read Req Reads data synchronously from an ADS server. LONG Ads Sync Read Req( PAms Addr p Addr, ULONG n Index Group, ULONG n Index Offset, ULONG n Length, PVOID p Data); Parameter p Addr [in] Structure with Net Id [} 26] and port number of the ADS server. n Index Group [in] Index Group. n Index Offset [in] Index Offset. n Length [in] Length of the data in bytes. p Data [out] Pointer to a data buffer that will receive the data. Return value Returns the function's error status. Example See example 3 [} 44]. 3.1.7 Ads Sync Read Req Ex Reads data synchronously from an ADS server. LONG Ads Sync Read Req Ex( PAms Addr p Addr, ULONG n Index Group, ULONG n Index Offset, ULONG n Length, PVOID p Data, ULONG *pcb Return ); Parameter p Addr [in] Structure with Net Id [} 26] and port number of the ADS server. n Index Group [in] Index Group. n Index Offset [in] Index Offset. n Length TE1000 Version: 1.1.3 11
## Page 12

C++ API [in] Length of the data in bytes. p Data [out] Pointer to a data buffer that will receive the data. pcb Return[out] Pointer to a variable. This variable returns the number of succesfully read data bytes. Return value Returns the function's error status. 3.1.8 Ads Sync Read Write Req Writes data synchronously into an ADS server and receives data back from the ADS device. LONG Ads Sync Read Write Req( PAms Addr p Addr, ULONG n Index Group, ULONG n Index Offset, ULONG n Read Length, PVOID p Read Data, ULONG n Write Length, PVOID p Write Data ); Parameter p Addr [in] Structure with Net Id [} 26] and port number of the ADS server. n Index Group [in] Index Group. n Index Offset [in] Index Offset. n Read Length [in] Length of the data, in bytes, returned by the ADS device. p Read Data [out] Buffer with data returned by the ADS device. n Write Length [in] Length of the data, in bytes, written to the ADS device. p Write Data [out] Buffer with data written to the ADS device. Return value Returns the function's error status. Example See example 7 [} 47]. 3.1.9 Ads Sync Read Write Req Ex Writes data synchronously into an ADS server and receives data back from the ADS device. 12 Version: 1.1.3 TE1000
## Page 13

C++ API LONG Ads Sync Read Write Req Ex( PAms Addr p Addr, ULONG n Index Group, ULONG n Index Offset, ULONG n Read Length, PVOID p Read Data, ULONG n Write Length, PVOID p Write Data, ULONG *pcb Return ); Parameter p Addr [in] Structure with Net Id [} 26] and port number of the ADS server. n Index Group [in] Index Group. n Index Offset [in] Index Offset. n Read Length [in] Length of the data, in bytes, returned by the ADS device. p Read Data [out] Buffer with data returned by the ADS device. n Write Length [in] Length of the data, in bytes, written to the ADS device. p Write Data [out] Buffer with data written to the ADS device. pcb Return[out] Pointer to a variable. This variable returns the number of successfully read data bytes. Return value Returns the function's error status. 3.1.10 Ads Sync Read Device Info Req Reads the identification and version number of an ADS server. LONG Ads Sync Read Device Info Req( PAms Addr p Addr, PCHAR p Dev Name, PAds Version p Version ); Parameter p Addr [in] Structure with Net Id [} 26] and port number of the ADS server. p Dev Name [out] Pointer to a character string that will receive the name of the ADS device. p Version [out] Address of a variable of type Ads Version [} 27], which will receive the version number, revision number and the build number. TE1000 Version: 1.1.3 13
## Page 14

C++ API Return value Returns the function's error status. Example See example 5 [} 46]. 3.1.11 Ads Sync Write Control Req Changes the ADS status and the device status of an ADS server. LONG Ads Sync Write Control Req( PAms Addr p Addr, USHORT n Ads State, USHORT n Device State, ULONG n Length, PVOID p Data ); Parameter p Addr [in] Structure with Net Id [} 26] and port number of the ADS server. n Ads State [in] New ADS status. n Device State [in] New device status. n Length [in] Length of the data in bytes. p Data [in] Pointer to data sent additionally to the ADS device. Return value Returns the function's error status. Comments In addition to changing the ADS status and the device status, it is also possible to send data to the ADS server in order to transfer further information. In the current ADS devices (PLC, NC, ...) this data has no further effect. Any ADS device can inform another ADS device of its current state. A distinction is drawn here between the status of the device itself (Device State) and the status of the ADS interface of the ADS device (Ads State). The states that the ADS interface can adopt are laid down in the ADS specification. Example See example 6 [} 46]. 3.1.12 Ads Sync Read State Req Reads the ADS status and the device status from an ADS server. LONG Ads Sync Read State Req( PAms Addr p Addr, USHORT *p Ads State, PUSHORT p Device State ); 14 Version: 1.1.3 TE1000
## Page 15

C++ API Parameter p Addr [in] Structure with Net Id [} 26] and port number of the ADS server. p Ads State [out] Address of a variable that will receive the ADS status (see data type ADSSTATE [} 29]). p Device State [out] Address of a variable that will receive the device status. Return value Returns the function's error status. Remarks Any ADS device can inform another ADS device of its current state. A distinction is drawn here between the status of the device itself (Device State) and the status of the ADS interface of the ADS device (Ads State). The states that the ADS interface can adopt are laid down in the ADS specification. Example 11 [} 52] illustrates how the change can be detected with the aid of a callback function. Example See example 4 [} 45]. 3.1.13 Ads Sync Add Device Notification Req A notification is defined within an ADS server (e.g. PLC). When a certain event occurs a function (the callback function) is invoked in the ADS client (C program). LONG Ads Sync Add Device Notification Req( PAms Addr p Addr, ULONG n Index Group, ULONG n Index Offset, PAds Notification Attrib p Note Attrib, PAds Notification Func Ex p Note Func, ULONG h User, PULONG p Notification ); Parameter p Addr [in] Structure with Net Id [} 26] and port number of the ADS server. n Index Group [in] Index Group. n Index Offset [in] Index Offset. p Note Attrib [in] Pointer to the structure [} 27] that contains further information. p Note Func [in] Name of the callback function [} 18]. h User TE1000 Version: 1.1.3 15
## Page 16

C++ API [in] 32-bit value that is passed to the callback function. p Notification [out] Address of the variable that will receive the handle of the notification. Return value Returns the function's error status. Limitation: Per ADS-Port a limitted number of 550 notifications are available. Example See example 8 [} 48]. 3.1.14 Ads Sync Del Device Notification Req A notification defined previously is deleted from an ADS server. LONG Ads Sync Del Device Notification Req( PAms Addr p Addr, ULONG h Notification ); Parameter p Addr [in] Structure with Net Id [} 26] and port number of the ADS server. h Notification [out] Address of the variable that contains the handle of the notification. Return value Returns the function's error status. Example See example 8 [} 48]. 3.1.15 Ads Sync Set Timeout Alters the timeout for the ADS functions. The standard value is 5000 ms. LONG Ads Sync Set Timeout( LONG n Ms); Parameter n Ms [in] Timeout in ms. Return value Returns the function's error status. Example - 16 Version: 1.1.3 TE1000
## Page 17

C++ API 3.1.16 Ads Ams Register Router Notification The Ads Ams Register Notification Req() function can be used to detect a change in the status of the Twin CAT router. The given callback function is invoked each time the status changes. Monitoring of the router's status is ended once more by the Ads Ams Un Register Notification() function. LONG Ads Ams Register Router Notification( PAms Router Notification Func Ex p Note Func ); Parameter p Note Func [in] Name of the callback function Return value Returns the function's error status. Hints: • Implemented from Tc Ads DLL File Version: 2.8.0.21 ( delivered with Twin CAT 2.9 Build > 941). • A connection to the Twin CAT-Router can be done, if Twin CAT has been installed on the local PC. The function delivers an error on a system without Twin CAT. Example - 3.1.17 Ads Ams Un Register Router Notification Monitoring the router's status is ended by the Ads Ams Un Register Notification() function. See also Ads Ams Register Notification Req(). LONG Ads Ams Un Register Router Notification( void ); Parameter - Return value Returns the function's error status. Hints: • Implemented from Tc Ads DLL File Version: 2.8.0.21 ( delivered with Twin CAT 2.9 Build > 941). • A connection to the Twin CAT-Router can be done, if Twin CAT has been installed on the local PC. The function delivers an error on a system without Twin CAT. Example - 3.1.18 PAms Router Notification Func Ex Type definition of the callback function required by the Ads Ams Register Router Notification [} 17] function. typedef void ( __stdcall *PAms Router Notification Func Ex)( long n Event ); TE1000 Version: 1.1.3 17
## Page 18

C++ API 3.1.19 PAds Notification Func Ex Type definition of the callback function required by the Ads Sync Add Device Notification Req [} 15] function. typedef void (__stdcall *PAds Notification Func Ex)(Ams Addr* p Addr, Ads Notification Header* p Notification, unsigned long h User ); 3.1.20 Extended Functions (for multithreaded applications) With the existing functions only one ADS port could be created for each process. Particularly for multithreaded applications this is not sufficient, since the individual Ads commands would block each other. With the new functions it is now possible to use more than one port. This would enable a separate ADS port to be used for each thread, for example. New ports can be opened via the Ads Port Open Ex function. The returned port number is then transferred as parameter to the individual sync functions. 3.1.20.1 Ads Port Open Ex Establishes a connection (communication port) to the Twin CAT message router. Unlike with Ads Port Open, a new ADS port is opened each time. The extended Ads functions have to be used for communicating with this port. The port number returned by Ads Port Open Ex is transferred as parameter to these functions. If no Twin CAT Message Router is present, the Ads Port Open Ex function will fail. LONG Ads Port Open Ex( void ); Parameters - Return value The number of the opened Ads port. A return value of 0 means the call has failed. Example See example 2 [} 44]. 3.1.20.2 Ads Port Close Ex The connection (communication port) to the Twin CAT message router is closed. The port to be closed must previously have been opened via an Ads Port Open Ex call. LONG Ads Port Close Ex( long n Port ); Parameters port [in] port number of an Ads port that had previously been opened with Ads Port Open Ex [} 18]. Return value Returns the function's error status. Example See example 2 [} 44]. 18 Version: 1.1.3 TE1000
## Page 19

C++ API 3.1.20.3 Ads Get Local Address Ex Returns the local Net Id and port number. LONG Ads Get Local Address Ex( long port, PAms Addr p Addr ); Parameters port [in] port number of an Ads port that had previously been opened with Ads Port Open Ex [} 18] or Ads Port Open [} 9]. p Addr [out] Pointer to the structure of type Ams Addr [} 26]. Return value Returns the function's error status. Example See example 2 [} 44]. 3.1.20.4 Ads Sync Write Req Ex Writes data synchronously to an ADS device. LONG Ads Sync Write Req Ex( LONG port, PAms Addr p Addr, ULONG n Index Group, ULONG n Index Offset, ULONG n Length, PVOID p Data ); Parameters port [in] port number of an Ads port that had previously been opened with Ads Port Open Ex [} 18] or Ads Port Open [} 9]. p Addr [in] Structure with Net Id [} 26] and port number of the ADS server. n Index Group [in] Index Group. n Index Offset [in] Index Offset. n Length [in] Length of the data, in bytes, written to the ADS server. p Data [in] Pointer to the data written to the ADS server. TE1000 Version: 1.1.3 19
## Page 20

C++ API Return value Returns the function's error status. Example See example 2 [} 44]. 3.1.20.5 Ads Sync Read Req Ex2 Reads data synchronously from an ADS server. LONG Ads Sync Read Req Ex2( LONG port, PAms Addr p Addr, ULONG n Index Group, ULONG n Index Offset, ULONG n Length, PVOID p Data, ULONG *pcb Return ); Parameters port [in] port number of an Ads port that had previously been opened with Ads Port Open Ex [} 18] or Ads Port Open [} 9]. p Addr [in] Structure with Net Id [} 26] and port number of the ADS server. n Index Group [in] Index Group. n Index Offset [in] Index Offset. n Length [in] Length of the data in bytes. p Data [out] Pointer to a data buffer that will receive the data. pcb Return [out] pointer to a variable. If successful, this variable will return the number of actually read data bytes. Return value Returns the function's error status. 3.1.20.6 Ads Sync Read Write Req Ex2 Writes data synchronously into an ADS server and receives data back from the ADS device. LONG Ads Sync Read Write Req Ex2( LONG port, PAms Addr p Addr, ULONG n Index Group, ULONG n Index Offset, ULONG n Read Length, PVOID p Read Data, ULONG n Write Length, 20 Version: 1.1.3 TE1000
## Page 21

C++ API PVOID p Write Data, ULONG* pcb Return ); Parameters port [in] port number of an Ads port that had previously been opened with Ads Port Open Ex [} 18] or Ads Port Open [} 9]. p Addr [in] Structure with Net Id [} 26] and port number of the ADS server. n Index Group [in] Index Group. n Index Offset [in] Index Offset. n Read Length [in] Length of the data, in bytes, returned by the ADS device. p Read Data [out] Buffer with data returned by the ADS device. n Write Length [in] Length of the data, in bytes, written to the ADS device. p Write Data [out] Buffer with data written to the ADS device. pcb Return [out] pointer to a variable. If successful, this variable will return the number of actually read data bytes. Return value Returns the function's error status. 3.1.20.7 Ads Sync Read Device Info Req Ex Reads the identification and version number of an ADS server. LONG Ads Sync Read Device Info Req Ex( LONG port, PAms Addr p Addr, PCHAR p Dev Name, PAds Version p Version ); Parameters port [in] port number of an Ads port that had previously been opened with Ads Port Open Ex [} 18] or Ads Port Open [} 9]. p Addr [in] Structure with Net Id [} 26] and port number of the ADS server. p Dev Name TE1000 Version: 1.1.3 21
## Page 22

C++ API [out] Pointer to a character string that will receive the name of the ADS device. p Version [out] Address of a variable of type Ads Version [} 27], which will receive the version number, revision number and the build number. Return value Returns the function's error status. Example See example 5 [} 46]. 3.1.20.8 Ads Sync Write Control Req Ex Changes the ADS status and the device status of an ADS server. LONG Ads Sync Write Control Req Ex( LONG port, PAms Addr p Addr, USHORT n Ads State, USHORT n Device State, ULONG n Length, PVOID p Data ); Parameters port [in] port number of an Ads port that had previously been opened with Ads Port Open Ex [} 18] or Ads Port Open [} 9]. p Addr [in] Structure with Net Id [} 26] and port number of the ADS server. n Ads State [in] New ADS status. n Device State [in] New device status. n Length [in] Length of the data in bytes. p Data [in] Pointer to data sent additionally to the ADS device. Return value Returns the function's error status. Comments In addition to changing the ADS status and the device status, it is also possible to send data to the ADS server in order to transfer further information. In the current ADS devices (PLC, NC, ...) this data has no further effect. Any ADS device can inform another ADS device of its current state. A distinction is drawn here between the status of the device itself (Device State) and the status of the ADS interface of the ADS device (Ads State). The states that the ADS interface can adopt are laid down in the ADS specification. 22 Version: 1.1.3 TE1000
## Page 23

C++ API Example See example 6 [} 46]. 3.1.20.9 Ads Sync Read State Req Ex Reads the ADS status and the device status from an ADS server. LONG Ads Sync Read State Req Ex( LONG port, PAms Addr p Addr, USHORT *p Ads State, PUSHORT p Device State); Parameters port [in] port number of an Ads port that had previously been opened with Ads Port Open Ex [} 18] or Ads Port Open [} 9]. p Addr [in] Structure with Net Id [} 26] and port number of the ADS server. p Ads State [out] Address of a variable that will receive the ADS status (see data type ADSSTATE [} 29]). p Device State [out] Address of a variable that will receive the device status. Return value Returns the function's error status. Remarks Any ADS device can inform another ADS device of its current state. A distinction is drawn here between the status of the device itself (Device State) and the status of the ADS interface of the ADS device (Ads State). The states that the ADS interface can adopt are laid down in the ADS specification. Example 11 [} 52] illustrates how the change can be detected with the aid of a callback function. Example See example 4 [} 45]. 3.1.20.10 Ads Sync Add Device Notification Req Ex A notification is defined within an ADS server (e.g. PLC). When a certain event occurs, a function (the callback function) is invoked in the ADS client (C program). LONG Ads Sync Add Device Notification Req Ex( LONG port, PAms Addr p Addr, ULONG n Index Group, ULONG n Index Offset, PAds Notification Attrib p Note Attrib, PAds Notification Func Ex p Note Func, ULONG h User, PULONG p Notification ); Parameters port TE1000 Version: 1.1.3 23
## Page 24

C++ API [in] port number of an Ads port that had previously been opened with Ads Port Open Ex [} 18] or Ads Port Open [} 9]. p Addr [in] Structure with Net Id [} 26] and port number of the ADS server. n Index Group [in] Index Group. n Index Offset [in] Index Offset. p Note Attrib [in] Pointer to the structure [} 27] that contains further information. p Note Func [in] Name of the callback function [} 18]. h User [in] 32-bit value that is passed to the callback function. p Notification [out] Address of the variable that will receive the handle of the notification. Return value Returns the function's error status. Limitation: Per ADS-Port a limited number of 550 notifications are available. Remarks If the Twin CAT router is stopped and then started again, the notifications become invalid. You can trap this event with the Ads Ams Register Router Notification() [} 17] function. Example See example 8 [} 48]. 3.1.20.11 Ads Sync Del Device Notification Req Ex A notification defined previously is deleted from an ADS server. LONG Ads Sync Del Device Notification Req Ex( LONG port, PAms Addr p Addr, ULONG h Notification ); Parameters port [in] port number of an Ads port that had previously been opened with Ads Port Open Ex [} 18] or Ads Port Open [} 9]. p Addr 24 Version: 1.1.3 TE1000
## Page 25

C++ API [in] Structure with Net Id [} 26] and port number of the ADS server. h Notification [out] Address of the variable that contains the handle of the notification. Return value Returns the function's error status. Example See example 8 [} 48]. 3.1.20.12 Ads Sync Set Timeout Ex Alters the timeout for the ADS functions. The standard value is 5000 ms. LONG Ads Sync Set Timeout Ex( LONG port, LONG n Ms ); Parameters port [in] port number of an Ads port that had previously been opened with Ads Port Open Ex [} 18] or Ads Port Open [} 9]. n Ms [in] Timeout in ms. Return value Returns the function's error status. Example - 3.1.20.13 Ads Sync Get Timeout Ex Returns the configured timeout for the ADS functions. The standard value is 5000 ms. LONG Ads Sync Get Timeout Ex( LONG port, LONG* pn Ms ); Parameters port [in] port number of an Ads port that had previously been opened with Ads Port Open Ex [} 18] or Ads Port Open [} 9]. pn Ms [out] Buffer to store timeout value in ms. Return value Returns the function's error status. TE1000 Version: 1.1.3 25
## Page 26

C++ API Example - 3.1.20.14 Ads Ams Port Enabled Ex Returns status of the ADS client connection. LONG Ads Ams Port Enabled Ex( LONG n Port, BOOL* pb Enabled ); Parameters n Port [in] port number of an Ads port that had previously been opened with Ads Port Open Ex [} 18] or Ads Port Open [} 9]. pb Enabled [out] buffer to store status value. Return value Returns the function's error status. Example - 3.2 Structures 3.2.1 Ams Addr The complete address of an ADS device can be stored in this structure. typedef struct { Ams Net Id net Id; USHORT port; } Ams Addr, *PAms Addr; Elements Net Id Net Id [} 26]. port Port number. 3.2.2 Ams Net Id The Net Id of and ADS device can be represented in this structure. typedef struct { UCHAR b[6]; } Ams Net Id, *PAms Net Id; Elements b[6] 26 Version: 1.1.3 TE1000
## Page 27

C++ API Net Id, consisting of 6 digits. Comment The structure consists of an array with 6 elements of type UCHAR. Each element in the array may adopt a value from 1 to 255. The Net Id is set with the aid of the Twin CAT system service. 3.2.3 Ads Version The structure contains the version number, revision number and build number. typedef struct { UCHAR version; UCHAR revision; USHORT build; } Ads Version, *PAds Version; Elements version Version number. revision Revision number. build Build number. 3.2.4 Ads Notification Attrib This structure contains all the attributes for the definition of a notification. typedef struct { ULONG cb Length; ADSTRANSMODE n Trans Mode; ULONG n Max Delay; ULONG n Cycle Time; } Ads Notification Attrib, *PAds Notification Attrib; Elements cb Length Length of the data that is to be passed to the callback function. n Trans Mode [} 29] ADSTRANS_SERVERCYCLE: The notification's callback function is invoked cyclically. ADSTRANS_SERVERONCHA: The notification's callback function is only invoked when the value changes. n Max Delay The notification's callback function is invoked at the latest when this time has elapsed. The unit is 100 ns. n Cycle Time The ADS server checks whether the variable has changed after this time interval. The unit is 100 ns. Remarks The ADS DLL is buffered from the real time transmission by a FIFO. Twin CAT first writes every value that is to be transmitted by means of the callback function into the FIFO. If the buffer is full, or if the n Max Delay time has elapsed, then the callback function is invoked for each entry. The n Trans Mode parameter affects this process as follows: TE1000 Version: 1.1.3 27
## Page 28

C++ API ADSTRANS_SERVERCYCLE The value is written cyclically into the FIFO at intervals of n Cycle Time. The smallest possible value for n Cycle Time is the cycle time of the ADS server; for the PLC, this is the task cycle time. The cycle time can be handled in 1ms steps. If you enter a cycle time of 0 ms, then the value is written into the FIFO with every task cycle. ADSTRANS_SERVERONCHA A value is only written into the FIFO if it has changed. The real-time sampling is executed in the time given in n Cycle Time. The cycle time can be handled in 1ms steps. If you enter 0 ms as the cycle time, the variable is written into the FIFO every time it changes. NOTICE Balance read operations Too many read operations can load the system so heavily that the user interface becomes much slower. Using ADS Notifications Folgen • Set the cycle time to the most appropriate values • Always close connections when they are no longer required. 3.2.5 Ads Notification Header This structure is also passed to the callback function. typedef struct { ULONG h Notification; __int64 n Time Stamp; ULONG cb Sample Size; UCHAR data[ANYSIZE_ARRAY]; } Ads Notification Header, *PAds Notification Header; Elements h Notification Handle for the notification. Is specified when the notification is defined; n Time Stamp Time stamp in FILETIME format. cb Sample Size Number of bytes transferred. data[ANY_SIZE_ARRAY] Array with the transferred data. Comment The time stamp is transferred in the FILETIME format. FILETIME is a 64-bit variable, representing the time and date in 100 ns steps, starting from 01.01.1601. Local time shift is not considered; coordinated universal time (UTC) is used. If you want access to the individual elements (day, month, year, hour, minute, second) you need to convert the time stamp from the FILETIME format to the SYSTEMTIME format, and then calculate the time, taking local time shifts into account. Example See example 8 [} 48]. 28 Version: 1.1.3 TE1000
## Page 29

C++ API 3.3 Enums 3.3.1 ADSSTATE typedef enum n Ads State { ADSSTATE_INVALID = 0, ADSSTATE_IDLE = 1, ADSSTATE_RESET = 2, ADSSTATE_INIT = 3, ADSSTATE_START = 4, ADSSTATE_RUN = 5, ADSSTATE_STOP = 6, ADSSTATE_SAVECFG = 7, ADSSTATE_LOADCFG = 8, ADSSTATE_POWERFAILURE = 9, ADSSTATE_POWERGOOD = 10, ADSSTATE_ERROR = 11, ADSSTATE_SHUTDOWN = 12, ADSSTATE_SUSPEND = 13, ADSSTATE_RESUME = 14, ADSSTATE_CONFIG = 15, // system is in config mode ADSSTATE_RECONFIG = 16, // system should restart in config mode ADSSTATE_MAXSTATES } ADSSTATE; 3.3.2 ADSTRANSMODE typedef enum n Ads Trans Mode { ADSTRANS_NOTRANS = 0, ADSTRANS_CLIENTCYCLE = 1, ADSTRANS_CLIENT1REQ = 2, ADSTRANS_SERVERCYCLE = 3, ADSTRANS_SERVERONCHA = 4 } ADSTRANSMODE; TE1000 Version: 1.1.3 29
## Page 30

COM 4 COM The Tc Ads Dll provides functions for communication with other ADS devices via the Twin CAT router through it's COM interface. You will find further information related to ADS under Twin CAT ADS The COM Class Tc Client [} 30] provides the user programs to establish a connection to ADS device to the local PC or to remote PC's. The Tc Ads Dll provides a multi-threaded threading model. It can be used by multi-threaded and single-threaded COM clients. If the Tc Ads Dll is used by single-threaded clients the method calls are synchronized by a marshaler. The marshaler is compiled into the Tc Ads Dll. No additional proxy-stub-dll is needed. The Tc Client [} 30] returns for each connection to one particular ADS device an object of the Type Tc Ads Sync [} 30]. This class provides synchronous ADS communication to the ADS device. The Class Tc Ads Sync [} 30] provides the communication function through the default interface ITc Ads Sync [} 32]. To receive Ads Notification from the Tc Ads Sync [} 30] object the user program has to implement and connect the Event Interface ITc Ads Sync Event [} 37]. 4.1 Classes 4.1.1 Tc Ads Dll::Classes The Tc Ads Dll provides interface to the outside by COM (Component Object Model). Co Classes Description Tc Client [} 30] The Main class of the Tc Ads Dll. Provides a class factory to establish a ADS client connection 4.1.2 Tc Client The Tc Client object provides a class factory to establish a ADS client connection. Interface Description ITc Client [} 31] Interface provides a class factory 4.1.3 Tc Ads Sync The Tc Ads Sync object provides ADS communication to an ADS device. The Tc Ads Sync object has no class factory and can just be created by an call. to ITc Client [} 30] ::ITc Client [} 30]Connect [} 31] 30 Version: 1.1.3 TE1000
## Page 31

COM Interface Description ITc Ads Sync [} 32] Interface that provides the Ads communication functions. 4.2 Interfaces 4.2.1 ITc Client The ITc Client interface provides a class factory to create an object to communicate with one Ads device. The interface derives from IUnknown. IUnknown Methods Description Query Interface Returns a pointer to the interface you query for Add Ref Increments the reference counter Release Decrements the reference counter ITc Client Methodes Description Connect [} 31] Creates an object of the type ITc Ads Sync that provides Ads synchronous communication to one particular ADS device. 4.2.1.1 ITc Client::Connect Creates a new Ads Client communication object for one particular Ads device by given Ads Net Id and Port Number. HRESULT Connect(Ams Net Id* p Ams Net Id, long n Port, ITc Ads Sync** pip Tc Ads Sync); Parameters p Ams Net Id [in] variable presents the Ams Net Id by the structure type Ams Net Id. If the Net Id is set to 0.0.0.0.0.0 the connection is made to the local Twin CAT system. If the client PC has no Twin CAT system installed the connection uses TCP/IP. The limitation on TCP/IP is that the client can just establish connections to the main remote device with the AMS Net Is = TCP/IP address + 1.1. . n Port [in] The Ads Port number of the Ads device we want to communicate with. ITc Ads Sync [out, retval] Returns a pointer to an ITc Ads Sync [} 32] pointer that holds the object that is used for Ads communication. Return Values S_OK The connect function was successfully called. ADSERRORCODES [} 38] An error occurs Remarks To establish a connection to remote Twin CAT Systems, the remote device has to be added to the list of Remote Computer on the Twin CAT system. If on client PC and remote PC a Twin CAT system is installed, the client PC has to be added to the list of remote computer on the remote PC and vice versa. If the client PC does not have a Twin CAT system installed the client PC has just to be added to the list of remote computers on the remote PC. If the Client PC has no Twin CAT system the AMS Net Id is just the TCP/IP address + 1.1. . TE1000 Version: 1.1.3 31
## Page 32

COM 4.2.2 ITc Ads Sync The ITc Client interface provides a client the functionality to communicate to ads device. The interface derives from IUnknown. IUnknown Methods Description Query Interface Returns a pointer to the interface you query for Add Ref Increments the reference counter Release Decrements the reference counter ITc Ads Sync Methodes and Description Properties Write [} 32] Writes a value to a variable as byte stream in an Ads device. Read [} 33] Reads the value of a variable as byte stream from an Ads device. Read Write [} 33] Writes a value to an Ads device and reads back the result in one step. Write Control [} 34] Writes a control command to an Ads device. Add Device Notification [} 34] Connects a variable to the client. The client will be notified by an event. Del Device Notification [} 35] Removes the connection of a variable. Read Device Info [} 35] Reads Device Information from an Ads device. Read State [} 36] Reads the state from an Ads device. Timeout [} 36] Sets the time after which the client will get a timeout warning on all other Ads commands 4.2.2.1 ITc Ads Sync::Write This method writes a value to a variable in an ADS device as byte stream 32 Version: 1.1.3 TE1000
## Page 33

COM HRESULT Write( index Group, index Offset, cb Len, p Data); Parameters index Group [in] A variable of the type long that holds the index group of the variable we want to write to. index Offset [in] A variable of the type long that holds the index offset of the variable we want to write to. cb Len [in] Count of byte we want to write to the variable. p Data [in, size_is(cb Len)] A pointer to the first element of a byte array with the length cb Len of the data we want to write to a variable in an Ads device. Return Values S_OK The function was successfully called ADSERRORCODES [} 38] An error occurs 4.2.2.2 ITc Ads Sync::Read This method reads a value of a variable from an ADS device as byte stream HRESULT Read( long index Group, long index Offset, long cb Len, long* pcb Read, byte* p Data); Parameters index Group [in] A variable of the type long that holds the index group of the variable we want to read. index Offset [in] A variable of the type long that holds the index offset of the variable we want to read. cb Len [in] Count of byte we want to read from the variable. pcb Read [out] Pointer to a variable the returns the count of bytes we really had read. p Data [out, size_is(cb Len), length_is(*pcb Read)] A pointer to the first element of a byte array with the length cb Len of the data we want to read from a variable in a Ads device. Return Values S_OK The function was successfully called ADSERRORCODES [} 38] An error occurs 4.2.2.3 ITc Ads Sync::Read Write This method writes a value to an ADS device and receive back the data device in one call. HRESULT Read Write( long index Group, long index Offset, long cb Rd Len, long* pcb Read, byte* p Rd Data, long cb Wr Len, byte* p Wr Data); TE1000 Version: 1.1.3 33
## Page 34

COM Parameters index Group [in] A variable of the type long that holds the index group of the variable we want to read. index Offset [in] A variable of the type long that holds the index offset of the variable we want to read. cb Rd Len [in] Count of byte we want to read from the variable. pcb Read [out] Pointer to a variable the returns the count of bytes we really had read. p Rd Data [out, size_is(cb Rd Len), length_is(*pcb Read)] A pointer to the first element of a byte array with the length cb Rd Len of the data we want to read from a variable in an Ads device. cb Wr Len [in] Count of byte we want to write to the variable. p Wr Data [in, size_is(p Wr Data)] A pointer to the first element of a byte array with the length cb Wr Len of the data we want to write to a variable in an Ads device. Return Values S_OK The function was successfully called ADSERRORCODES [} 38] An error occurs 4.2.2.4 ITc Ads Sync::Write Control This method sets the state of the ADS system an devices HRESULTWrite Control( ADSSTATE ads State, ADSSTATE device State, long cb Len, byte* p Data); Parameters ads State [in] The states as ADSSTATE [} 40] we want to set onto the ADS system. device State [in] The states as ADSSTATE [} 40] we want to set onto the ADS device. cb Len [in] Count of byte we want to write to the variable. p Data [in, size_is(cb Len)] A pointer to the first element of a byte array with the length cb Len of additional the data we want to write to the Ads device. Return Values S_OK The function was successfully called ADSERRORCODES [} 38] An error occurs 4.2.2.5 ITc Ads Sync::Add Device Notification Connects a variable to the client. The client will be notified by a event. HRESULT Add Device Notification( long index Group, long index Offset, long cb Len Data, ADSTRANSMODE trans Mode, long n Max Delay, long n Cycle Time, long* ph Notification); 34 Version: 1.1.3 TE1000
## Page 35

COM Parameters index Group [in] A variable of the type long that holds the index group of the variable we want to read. index Offset [in] A variable of the type long that holds the index offset of the variable we want to read. cb Len Data [in] Count of byte we want to read from the connected variable. trans Mode [out] The mode how the variable is connected with the type ADSTRANSMODE [} 40]. n Max Delay [in] The time with a resolution of 100 ns after we want to receive an callback on the implemented _ITc Ads Sync Event [} 37] interface. • n Cycle Time • [in] The time with a resolution of 100 ns how the variable should be collected ph Notification [out, retval] A pointer to the handle that unique identifies the connection of our variable. Return Values S_OK The function was successfully called ADSERRORCODES [} 38] An error occurs Remarks A n Cycle Time= 10000 and n Max Delay=100000 would receive every 10ms 10 values with the resolution of 1ms. 4.2.2.6 ITc Ads Sync::Del Device Notification This method removes the connection of a variable, that was connected before by an Add Device Notification HRESULT Del Device Notification( long ph Notication); Parameters ph Notification [in] The handle of the further established connection. Return Values S_OK The function was successfully called ADSERRORCODES [} 38] An error occurs Remarks A n Cycle Time= 10000 and n Max Delay=100000 would receive every 10ms 10 values with the resolution of 1ms. 4.2.2.7 ITc Ads Sync::Read Device Info This method retrieves information about the Ads device. HRESULT Read Device Info( BSTR* p Name, Ads Version* p Version); TE1000 Version: 1.1.3 35
## Page 36

COM Parameters p Name [out] A variable that holds the BSTR string that describes the ADS device. p Version [out] A pointer to a variable of the type Ads Version [} 37] that holds the version number. Return Values S_OK The function was successfully called ADSERRORCODES [} 38] An error occurs 4.2.2.8 ITc Ads Sync::Read State This method retrieves information about the ADA device State and the ADS system state. HRESULT Read State( ADSSTATE* p Ads State, ADSSTATE* p Device State); Parameters p Ads State [out] Pointer to variable of the type ADSSTATE [} 40] that holds the state of the ADS system. p Device State [out] Pointer to variable of the type ADSSTATE [} 40] that holds the state of the ADS device. Return Values S_OK The function was successfully called ADSERRORCODES [} 38] An error occurs 4.2.2.9 ITc Ads Sync::Timeout This property is used to assign or retrieve the timeout value in milliseconds for all other Ads functions of the ITc Ads Sync [} 32] interface. Retrieve the Timeout value HRESULT get_Timeout(long *p Time); Parameters p Time [out, retval] Pointer to a variable that holds the current timeout value Return Values S_OK The function was successfully called ADSERRORCODES [} 38] An Error occurs Assign a new Timeout value HRESULT put_Timeout(long n Time); Table 1: Parameters n Time [in] A variable that holds the new timeout value Table 2: Return Values S_OK The function was successfully called ADSERRORCODES [} 38] An Error occurs 36 Version: 1.1.3 TE1000
## Page 37

COM 4.2.3 _ITc Ads Sync Event The _ITc Ads Sync Event interface is the event Interface that a client has to implement if he wants to receive ADS Notification for connected variables. The interface derives from IUnknown. IUnknown Methods Description Query Interface Returns a pointer to the interface you query for Add Ref Increments the reference counter Release Decrements the reference counter _ITc Ads Sync Event Methodes Description Device Notification [} 37] This method is called from the server for all connected variables of this Ads device 4.2.3.1 _ITc Ads Sync Event::Device Notification This method is called from the server for all connected variables of this Ads device. The Event occurs for those variables that had been connected by an Add Device Notification [} 34] before. HRESULT Device Notification( Time Stamp* p Time, long h Notification, long cb Len, byte* p Data ); Parameters p Time [in] A pointer to a variable of the type Time Stamp [} 38] that holds the exact time when the connected variable was collected. h Notification [in] The handle that identifies one particular connected variable. The handle was retuned when the variable was connected by a call to method Add Device Notification [} 34]. cb Len [in] Count of data bytes received by this method. p Data [in, size_is(cb Len)]. A pointer to the first element of a byte array with the size of cb Len that contains the data of the connected variable Return Values S_OK The connect function was successfully called ADSERRORCODES [} 38] An error occurs 4.3 Structures 4.3.1 Ads Version The structure Ads Version represents a version number spitted into version, revision and build number. struct Ads Version { BYTE version; BYTE revision; short build; } TE1000 Version: 1.1.3 37
## Page 38

COM 4.3.2 Time Stamp The structure Time Stamp represents a windows FILETIME data structure. It is a 64-bit value representing the number of 100-nanosecond intervals since January 1, 1601. It is the means by which Win32 determines the date and time. struct Time Stamp { long n Low; long n High; }; 4.4 Enums 4.4.1 ADSERRORCODES The enumeration type ADSERRORCODE describes Ads errors with the following values: 38 Version: 1.1.3 TE1000
## Page 39

COM Const Hex Value Description ADS_E_ERROR 0x98117000 this is the offset of Ads Errors presented a COM HRESULT ADS_E_SRVNOTSUPP 0x98117001 the requested service is not supported by the ADS device ADS_E_INVALIDGRP 0x98117002 invalided index group ADS_E_INVALIDOFFSET 0x98117003 invalid index offset ADS_E_INVALIDACCESS 0x98117004 reading an writing not permitted ADSERR_DEVICE_INVALIDSI 0x98117005 parameter size is not correct ZE ADS_E_INVALIDDATA 0x98117006 invalided data value(s) ADS_E_NOTREADY 0x98117007 device is not in a ready state ADS_E_BUSY 0x98117008 device is busy ADS_E_INVALIDCONTEXT 0x98117009 invalid context ADS_E_NOMEMORY 0x9811700A out of memory ADS_E_INVALIDPARM 0x9811700B invalid parameter value(s) ADS_E_NOTFOUND 0x9811700C not found (files, ...) ADS_E_SYNTAX 0x9811700D syntax error in command or file ADS_E_INCOMPATIBLE 0x9811700E objects do not match ADS_E_EXISTS 0x9811700F object already exists ADS_E_SYMBOLNOTFOUND 0x98117010 symbol not found ADS_E_SYMBOLVERSIONINV 0x98117011 symbol version invalid ALID ADS_E_INVALIDSTATE 0x98117012 server is in invalid state ADS_E_TRANSMODENOTSUP 0x98117013 Ads Trans Mode not supported P ADS_E_NOTIFYHNDINVALID 0x98117014 Notification handle is invalid ADS_E_CLIENTUNKNOWN 0x98117015 Notification client not registered ADS_E_NOMOREHDLS 0x98117016 no more notification handles ADS_E_INVALIDWATCHSIZE 0x98117017 size for watch to big ADS_E_NOTINIT 0x98117018 device not initialized ADS_E_TIMEOUT 0x98117019 device has a timeout ADS_E_NOINTERFACE 0x9811701A query interface failed ADS_E_INVALIDINTERFACE 0x9811701B wrong interface required ADS_E_INVALIDCLSID 0x9811701C class ID is invalid ADS_E_INVALIDOBJID 0x9811701D object ID is invalid ADS_E_CLIENT_ERROR 0x98117040 Error class: client error ADS_E_CLIENT_INVALIDPAR 0x98117041 invalid parameter at service call M ADS_E_CLIENT_LISTEMPTY 0x98117042 polling list is empty ADS_E_CLIENT_VARUSED 0x98117043 var connection already in use ADS_E_CLIENT_DUPLINVOK 0x98117044 invoke id in use EID ADS_E_CLIENT_SYNCTIMEO 0x98117045 timeout elapsed UT ADS_E_CLIENT_W32ERROR 0x98117046 error in win32 subsystem ADS_E_CLIENT_TIMEOUTINV 0x98117047 ALID ADS_E_CLIENT_PORTNOTOP 0x98117048 EN ADS_E_CLIENT_NOAMSADD 0x98117049 R TE1000 Version: 1.1.3 39
## Page 40

COM Const Hex Value Description ADS_E_CLIENT_SYNCINTERN 0x98117050 internal error in ads sync AL ADS_E_CLIENT_ADDHASH 0x98117051 hash table overflow ADS_E_CLIENT_REMOVEHAS 0x98117052 key not found in hash table H ADS_E_CLIENT_NOMORESY 0x98117053 no more symbols in cache M 4.4.2 ADSSTATE The enumeration type ADSSTATE describes the Ads state with the following values: Const Int Value Description ADSSTATE_INVALID 0 Invalided state ADSSTATE_IDLE 1 Idles state ADSSTATE_RESET 2 Reset state ADSSTATE_INIT 3 initialized ADSSTATE_START 4 started ADSSTATE_RUN 5 running ADSSTATE_STOP 6 stopped ADSSTATE_SAVECFG 7 saved configuration ADSSTATE_LOADCFG 8 load configuration ADSSTATE_POWERFAILURE 9 power failure ADSSTATE_POWERGOOD 10 power good ADSSTATE_ERROR 11 error state ADSSTATE_SHUTDOWN 12 shutting down ADSSTATE_SUSPEND 13 suspended ADSSTATE_RESUME 14 resumed ADSSTATE_CONFIG 15 system is in config mode ADSSTATE_RECONFIG 16 system should restart in config mode 4.4.3 ADSTRANSMODE The enumeration type ADSTRANSMODE describes the mode of an device notification with the following values: Const Int Value Description ADSTRANS_NOTRANS 0 ADSTRANS_CLIENTCYCLE 1 ADSTRANS_CLIENTONCHA 2 ADSTRANS_SERVERCYCLE 3 ADSTRANS_SERVERONCHA 4 ADSTRANS_CLIENT1REQ 5 40 Version: 1.1.3 TE1000
## Page 41

Integration 5 Integration 5.1 Linking C++ ADS library for Twin CAT 3 in Visual Studio Necessary files The ADS components are installed with Twin CAT 3 and are located in '\Twin CAT\Ads Api' directory. Include the Header files. To use the functionality of the Tc Ads Dll in your project you have to include the Tc Ads Api.h and the Tc Ads Def.h header files into your project. #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads Def.h" #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads Api.h" Add the Library to your project You have to include the Tc Ads Dll.lib library, to use the functionality of the Tc Ads Dll. The library can be found per default in following Twin CAT folder: C:\Twin CAT\Ads Api\Tc Ads Dll\Lib\Tc Ads Dll.lib In Visual Studio you have to select the menu item Project|Properties. On the project settings dialog you select the scope of the settings for: Configuration Properties. To include the library, you have to add the path to the Tc Ads Dll. Lib in the Additional Dependencies modules text box. TE1000 Version: 1.1.3 41
## Page 42

Samples 6 Samples 42 Version: 1.1.3 TE1000
## Page 43

Samples Description Source text Example 1: Read DLL version [} 44] https://infosys.beckhoff.com/ content/1033/tc3_adsdll2/ Resources/7723063691/.zip Example 2: Write flag synchronously into PLC [} 44] https://infosys.beckhoff.com/ content/1033/tc3_adsdll2/ Resources/7723065867/.zip Example 3: Read flag synchronously from the PLC [} 44] https://infosys.beckhoff.com/ content/1033/tc3_adsdll2/ Resources/7723209099/.zip Example 4: Read ADS status [} 45] https://infosys.beckhoff.com/ content/1033/tc3_adsdll2/ Resources/7723067531/.zip Example 5: Read ADS information [} 46] https://infosys.beckhoff.com/ content/1033/tc3_adsdll2/ Resources/7723069195/.zip Example 6: Start/stop PLC [} 46] https://infosys.beckhoff.com/ content/1033/tc3_adsdll2/ Resources/7723070859/.zip Example 7: Access an array in the PLC [} 47] https://infosys.beckhoff.com/ content/1033/tc3_adsdll2/ Resources/7723072523/.zip Example 8: Event driven reading [} 48] https://infosys.beckhoff.com/ content/1033/tc3_adsdll2/ Resources/7723074187/.zip Example 9: Access by variable name [} 50] https://infosys.beckhoff.com/ content/1033/tc3_adsdll2/ Resources/7723075851/.zip Example 10: Read PLC variable declaration [} 51] https://infosys.beckhoff.com/ content/1033/tc3_adsdll2/ Resources/7723090315/.zip Example 11: Detect status change in Twin CAT router and the PLC https://infosys.beckhoff.com/ content/1033/tc3_adsdll2/ [} 52] Resources/7723094283/.zip Example 12: Event-Driven Detection of Changes to the Symbol Table https://infosys.beckhoff.com/ content/1033/tc3_adsdll2/ [} 53] Resources/7723095947/.zip Example 13: Reserved Example 14: Reading the PLC variable declaration of an individual https://infosys.beckhoff.com/ content/1033/tc3_adsdll2/ variable [} 54] Resources/7723097611/.zip Example 15: Reserved Example 16: Reserved Example 17: ADS-sum command: read or write [} 57] https://infosys.beckhoff.com/ content/1033/tc3_adsdll2/ Resources/7723115403/.zip Example 18: ADS-sum command: Get and release [} 59] https://infosys.beckhoff.com/ content/1033/tc3_adsdll2/ Resources/7723117067/.zip Example 19: Reserved Example 20: Transmitting structures to the PLC [} 62] https://infosys.beckhoff.com/ content/1033/tc3_adsdll2/ Resources/7723118731/.zip Example 21: Reading and writing of TIME/DATE variables [} 63] https://infosys.beckhoff.com/ content/1033/tc3_adsdll2/ Resources/7723120395/.zip TE1000 Version: 1.1.3 43
## Page 44

Samples 6.1 Read DLL version Download: 'https://infosys.beckhoff.com/content/1033/tc3_adsdll2/Resources/7723063691/.zip' This program determines the version of the DLL file. #include <iostream.h> #include <conio.h> #include <windows.h> // ADS headers for Twin CAT 3 #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads Def.h" #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads API.h" void main() { long n Temp; Ads Version* p DLLVersion; n Temp = Ads Get Dll Version(); p DLLVersion = (Ads Version *)&n Temp; cout << "Version: " << (int)p DLLVersion->version << '\n'; cout << "Revision: " << (int)p DLLVersion->revision << '\n'; cout << "Build: " << p DLLVersion->build << '\n'; cout.flush(); getch(); } 6.2 Write flag synchronously into the PLC Download: https://infosys.beckhoff.com/content/1033/tc3_adsdll2/Resources/7723065867/.zip In this example program, the value that the user has entered is written into flag double word 0. #include <iostream.h> #include <windows.h> // ADS headers for Twin CAT 3 #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads Def.h" #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads API.h" void main() { long n Err, n Port; Ams Addr Addr; PAms Addr p Addr = &Addr; DWORD dw Data; // Open communication port on the ADS router n Port = Ads Port Open(); n Err = Ads Get Local Address(p Addr); if (n Err) cerr << "Error: Ads Get Local Address: " << n Err << '\n'; // Twin CAT 3 PLC1 = 851 p Addr->port = 851; // Read value from user that is to be written to the PLC cout << "Value: "; cin >> dw Data; // Write value to MD0 n Err = Ads Sync Write Req( p Addr, 0x4020, 0x0, 0x4, &dw Data ); if (n Err) cerr << "Error: Ads Sync Write Req: " << n Err << '\n'; // Close communication port n Err = Ads Port Close(); if (n Err) cerr << "Error: Ads Port Close: " << n Err << '\n'; } 6.3 Read flag synchronously from the PLC Download: https://infosys.beckhoff.com/content/1033/tc3_adsdll2/Resources/7723209099/.zip 44 Version: 1.1.3 TE1000
## Page 45

Samples In this example program the value in flag double word 0 in the PLC is read and displayed on the screen. #include <iostream.h> #include <windows.h> #include <conio.h> // ADS headers for Twin CAT 3 #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads Def.h" #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads API.h" void main() { long n Err, n Port; Ams Addr Addr; PAms Addr p Addr = &Addr; DWORD dw Data; // Open communication port on the ADS router n Port = Ads Port Open(); n Err = Ads Get Local Address(p Addr); if (n Err) cerr << "Error: Ads Get Local Address: " << n Err << '\n'; // Twin CAT3 PLC1 = 851 p Addr->port = 851; // Read value from MD0 and display do { n Err = Ads Sync Read Req(p Addr, 0x4020, 0x0, 0x4, &dw Data); if (n Err) cerr << "Error: Ads Sync Read Req: " << n Err << '\n'; cout << dw Data << '\n'; cout.flush(); } while (getch() == '\r'); // Read the next value (use Carriage return as delimitter), stop otherwise // Close communication port n Err = Ads Port Close(); if (n Err) cerr << "Error: Ads Port Close: " << n Err << '\n'; } 6.4 Read ADS status Download: https://infosys.beckhoff.com/content/1033/tc3_adsdll2/Resources/7723067531/.zip This program reads the status of the PLC. The variable of type ADSSTATE contains information such as, for example, whether the PLC is in the RUN or STOP state. #include <iostream.h> #include <windows.h> #include <conio.h> // ADS headers for Twin CAT 3 #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads Def.h" #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads API.h" void main() { ADSSTATE n Ads State; USHORT n Device State; long n Err, n Port; Ams Addr Addr; PAms Addr p Addr = &Addr; // Open communication port on the ADS router n Port = Ads Port Open(); n Err = Ads Get Local Address(p Addr); if (n Err) cerr << "Error: Ads Get Local Address: " << n Err << '\n'; // Twin CAT3 PLC1 = 851 p Addr->port = 851; do { n Err = Ads Sync Read State Req(p Addr, &n Ads State, &n Device State); if (n Err) cerr << "Error: Ads Sync Read State Req: " << n Err << '\n'; else { cout << "Ads State: " << n Ads State << '\n'; cout << "Device State: " << n Device State << '\n'; } cout.flush(); TE1000 Version: 1.1.3 45
## Page 46

Samples } while ( getch() == '\r'); // continue on a carriage return, finish for any other key // Close communication port n Err = Ads Port Close(); if (n Err) cerr << "Error: Ads Port Close: " << n Err << '\n'; } 6.5 Read ADS information Download: https://infosys.beckhoff.com/content/1033/tc3_adsdll2/Resources/7723069195/.zip Each ADS device contains a version number and an identification. The example program reads this information from the PLC and displays it on the screen. #include <iostream.h> #include <windows.h> #include <conio.h> // ADS headers for Twin CAT 3 #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads Def.h" #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads API.h" void main() { LONG n Err, n Port; Ads Version Version; Ads Version *p Version = &Version; char p Dev Name[50]; Ams Addr Addr; PAms Addr p Addr = &Addr; // Open communication port on the ADS router n Port = Ads Port Open(); n Err = Ads Get Local Address(p Addr); if (n Err) cerr << "Error: Ads Get Local Address: " << n Err << '\n'; // Twin CAT3 PLC1 = 851 p Addr->port = 851; n Err = Ads Sync Read Device Info Req(p Addr, p Dev Name, p Version); if (n Err) cerr << "Error: Ads Sync Read Device Info Req: " << n Err << '\n'; else { cout << "Name: " << p Dev Name << '\n'; cout << "Version: " << (int)p Version->version << '\n'; cout << "Revision: " << (int)p Version->revision << '\n'; cout << "Build: " << p Version->build << '\n'; } cout.flush(); getch(); // Close communication port n Err = Ads Port Close(); if (n Err) cerr << "Error: Ads Port Close: " << n Err << '\n'; } 6.6 Start/stop PLC Download: https://infosys.beckhoff.com/content/1033/tc3_adsdll2/Resources/7723070859/.zip. The following program starts or stops run-time system 1 in the PLC. #include <iostream.h> #include <windows.h> #include <conio.h> // ADS headers for Twin CAT 3 #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads Def.h" #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads API.h" void main() { 46 Version: 1.1.3 TE1000
## Page 47

Samples USHORT n Ads State; USHORT n Device State = 0; long n Err, n Port; int ch; void *p Data = NULL; Ams Addr Addr; PAms Addr p Addr = &Addr; // Open communication port on the ADS router n Port = Ads Port Open(); n Err = Ads Get Local Address(p Addr); if (n Err) cerr << "Error: Ads Get Local Address: " << n Err << '\n'; // Twin CAT 3 PLC1 = 851 p Addr->port = 851; cout << "(R) -> PLC Run\n"; cout << "(S) -> PLC Stop\n"; cout.flush(); ch = getch(); ch = toupper(ch); while ( (ch == 'R') || (ch == 'S') ) { switch (ch) { case 'R': n Ads State = ADSSTATE_RUN; break; case 'S': n Ads State = ADSSTATE_STOP; break; } n Err = Ads Sync Write Control Req (p Addr, n Ads State, n Device State, 0, p Data); if (n Err) cerr << "Error: Ads Sync Write Control Req: " << n Err << '\n'; ch = getch(); ch = toupper(ch); } // Close communication port n Err = Ads Port Close(); if (n Err) cerr << "Error: Ads Port Close: " << n Err << '\n'; } 6.7 Access an array in the PLC Download: https://infosys.beckhoff.com/content/1033/tc3_adsdll2/Resources/7723072523/.zip An array, located in the PLC, is to be read by means of a read command. The variable is addressed here by its handle. The length of the whole array is provided as the length for the function Ads Sync Read Req(). The address of the first array element is given as variable. #include <iostream.h> #include <windows.h> #include <conio.h> // ADS headers for Twin CAT 3 #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads Def.h" #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads API.h" void main() { long n Err, n Port; Ams Addr Addr; PAms Addr p Addr = &Addr; unsigned long l Hdl Var; int n Index; short Data[10]; char sz Var []={"MAIN. PLCVar"}; // Open communication port on the ADS router n Port = Ads Port Open(); n Err = Ads Get Local Address(p Addr); if (n Err) cerr << "Error: Ads Get Local Address: " << n Err << '\n'; // Select Port: Twin CAT 3 PLC1 = 851 p Addr->port = 851; TE1000 Version: 1.1.3 47
## Page 48

Samples // Fetch handle for the PLC variable n Err = Ads Sync Read Write Req(p Addr, ADSIGRP_SYM_HNDBYNAME, 0x0, sizeof(l Hdl Var), &l Hdl Var, sizeof(sz Var), sz Var); if (n Err) cerr << "Error: Ads Sync Read Write Req: " << n Err << '\n'; // Read values of the PLC variables (by handle) n Err = Ads Sync Read Req(p Addr, ADSIGRP_SYM_VALBYHND, l Hdl Var, sizeof(Data), &Data[0]); if (n Err) cerr << "Error: Ads Sync Read Req: " << n Err << '\n'; else { for (n Index = 0; n Index < 10; n Index++) cout << "Data[" << n Index << "]: " << Data[n Index] << '\n'; } cout.flush(); getch(); // Close communication port n Err = Ads Port Close(); if (n Err) cerr << "Error: Ads Port Close: " << n Err << '\n'; } 6.8 Event driven reading Download: https://infosys.beckhoff.com/content/1033/tc3_adsdll2/Resources/7723074187/.zip If values from a PLC or NC are to be displayed continuously on a user interface, then it is very inefficient to use Ads Sync Read Req() [} 11], since this function must be called cyclically. By defining what are known as notifications (messages), a Twin CAT server can be made to transmit values via ADS to another ADS device. A distinction is drawn between whether the Twin CAT server is to transmit the values cyclically, or only when the values change. A notification is begun with the Ads Sync Add Device Notification Req() [} 15] function. After this, the callback function is automatically invoked by Twin CAT. Ads Sync Del Device Notification Req() [} 16] is used to halt the notification again. Since the number of notifications is limited, you should ensure the notifications no longer required by your program are deleted. You will find further information under the description of the Ads Notification Attrib [} 27] structure. The following program starts a notification on a variable handle in the PLC. Each time the PLC variable changes, the callback function is invoked. The callback function receives a variable of type Ads Notification Header() [} 28] as one of its parameters. This structure contains all the necessary information (value, time stamp, ...). Efficient Usage • Don't use time intensive executions in callbacks. • Remind to sync your callback and your mainthread, if you access each other (e.g. critical sections, mutex, events). #include <iostream> #include <conio.h> #include <windows.h> #include <winbase.h> // ADS headers for Twin CAT 3 #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads Def.h" #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads API.h" using namespace std; void _stdcall Callback(Ams Addr*, Ads Notification Header*, unsigned long); void main() { long n Err, n Port; Ams Addr Addr; PAms Addr p Addr = &Addr; ULONG h Notification, h User; Ads Notification Attrib ads Notification Attrib; char sz Var []={"MAIN. PLCVar"}; // open communication port on the ADS router n Port = Ads Port Open(); 48 Version: 1.1.3 TE1000
## Page 49

Samples n Err = Ads Get Local Address(p Addr); if (n Err) cerr << "Error: Ads Get Local Address: " << n Err << '\n'; // Twin CAT 3 RTS1 Port = 851 p Addr->port = 851; // set the attributes of the notification ads Notification Attrib.cb Length = 4; ads Notification Attrib.n Trans Mode = ADSTRANS_SERVERONCHA; ads Notification Attrib.n Max Delay = 0; ads Notification Attrib.n Cycle Time = 10000000; // 1sec // get handle n Err = Ads Sync Read Write Req(p Addr, ADSIGRP_SYM_HNDBYNAME, 0x0, sizeof(h User), &h User, sizeof(sz Var), sz Var); if (n Err) cerr << "Error: Ads Sync Read Write Req: " << n Err << '\n'; // initiate the transmission of the PLC-variable n Err = Ads Sync Add Device Notification Req(p Addr, ADSIGRP_SYM_VALBYHND, h User, &ads Notification Attrib, Callback, h User, &h Notification); if (n Err) cerr << "Error: Ads Sync Add Device Notification Req: " << n Err << '\n'; cout << "Notification: " << h Notification << "\n\n"; cout.flush(); // wait for user intraction (keystroke) getch(); // finish the transmission of the PLC-variable n Err = Ads Sync Del Device Notification Req(p Addr, h Notification); if (n Err) cerr << "Error: Ads Sync Del Device Notification Req: " << n Err << '\n'; // release handle n Err = Ads Sync Write Req(p Addr, ADSIGRP_SYM_RELEASEHND, 0, sizeof(h User), &h User); if (n Err) cerr << "Error: Ads Sync Write Req: " << n Err << '\n'; // Close the communication port n Err = Ads Port Close(); if (n Err) cerr << "Error: Ads Port Close: " << n Err << '\n'; } // Callback-function void __stdcall Callback(Ams Addr* p Addr, Ads Notification Header* p Notification, ULONG h User) { int n Index; static ULONG n Count = 0; SYSTEMTIME System Time, Local Time; FILETIME File Time; LARGE_INTEGER Large Integer; TIME_ZONE_INFORMATION Time Zone Information; cout << ++n Count << ". Call:\n"; // print (to screen)) the value of the variable cout << "Value: " << *(ULONG *)p Notification->data << '\n'; cout << "Notification: " << p Notification->h Notification << '\n'; // Convert the timestamp into SYSTEMTIME Large Integer. Quad Part = p Notification->n Time Stamp; File Time.dw Low Date Time = (DWORD)Large Integer. Low Part; File Time.dw High Date Time = (DWORD)Large Integer. High Part; File Time To System Time(&File Time, &System Time); // Convert the time value Zeit to local time Get Time Zone Information(&Time Zone Information); System Time To Tz Specific Local Time(&Time Zone Information, &System Time, &Local Time); // print out the timestamp cout << Local Time.w Hour << ":" << Local Time.w Minute << ":" << Local Time.w Second << '.' << Local Time.w Milliseconds << " den: " << Local Time.w Day << '.' << Local Time.w Month << '.' << Local Time.w Year << '\n'; // Größe des Buffers in Byte cout << "Sample Size: " << p Notification->cb Sample Size << '\n'; // 32-Bit Variable (auch Zeiger), die beim Add Notification gesetzt wurde // (siehe main) cout << "h User: " << h User << '\n'; // Print out the ADS-address of the sender cout << "Server Net Id: "; TE1000 Version: 1.1.3 49
## Page 50

Samples for (n Index = 0; n Index < 6; n Index++) cout << (int)p Addr->net Id.b[n Index] << "."; cout << "\n Port: " << p Addr->port << "\n\n"; cout.flush(); } 6.9 Access by variable name Download: https://infosys.beckhoff.com/content/1033/tc3_adsdll2/Resources/7723075851/.zip The following program accesses a PLC variable that does not have an address. Access must therefore be made by the variable name. Once the PLC variable in the example program exceeds 10 it is reset to 0. All data that ADS devices make available to the outside is organised by means of Index Groups and Index Offset. An Index Group can be thought of as a table, with each entry being addressed by the Index Offset. The Twin CAT PLC has, for example, Index Groups in which the variables that belong to the input/output or flags regions are stored. Index Groups are also available to the Twin CAT PLC through which system functions may be addressed. The Index Groups ADSIGRP_SYM_HNDBYNAME and ADSIGRP_ SYM_VALBYHND are important for the example program. The Index Group ADSIGRP_SYM_HNDBYNAME is used to request a handle from a PLC variable identified by name. The variable can be accessed with the aid of this handle and the Index Group ADSIGRP_SYM_VALBYHND. The variable's handle is passed as the Index Offset. #include <iostream.h> #include <windows.h> #include <conio.h> // ADS headers for Twin CAT 3 #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads Def.h" #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads API.h" void main() { long n Err, n Port; Ams Addr Addr; PAms Addr p Addr = &Addr; ULONG l Hdl Var, n Data; char sz Var []={"MAIN. PLCVar"}; // Open communication port on the ADS router n Port = Ads Port Open(); n Err = Ads Get Local Address(p Addr); if (n Err) cerr << "Error: Ads Get Local Address: " << n Err << '\n'; // Twin CAT 3 PLC1 = 851 p Addr->port = 851; // Fetch handle for an <sz Var> PLC variable n Err = Ads Sync Read Write Req(p Addr, ADSIGRP_SYM_HNDBYNAME, 0x0, sizeof(l Hdl Var), &l Hdl Var, sizeof(sz Var), sz Var); if (n Err) cerr << "Error: Ads Sync Read Write Req: " << n Err << '\n'; do { // Read value of a PLC variable (by handle) n Err = Ads Sync Read Req( p Addr, ADSIGRP_SYM_VALBYHND, l Hdl Var, sizeof(n Data), &n Data ); if (n Err) cerr << "Fehler: Ads Sync Read Req: " << n Err << '\n'; else cout << "Wert: " << n Data << '\n'; cout.flush(); if (Data > 10) { // Reset the value of the PLC variable to 0 n Data = 0; n Err = Ads Sync Write Req(p Addr, ADSIGRP_SYM_VALBYHND, l Hdl Var, sizeof(n Data), &n Data); if (n Err) cerr << "Error: Ads Sync Write Req: " << n Err << '\n'; } } while ( getch() == '\r'); // read next value with RETURN, else end //Release handle of plc variable n Err = Ads Sync Write Req(p Addr, ADSIGRP_SYM_RELEASEHND, 0, sizeof(l Hdl Var), &l Hdl Var); 50 Version: 1.1.3 TE1000
## Page 51

Samples if (n Err) cerr << "Error: Ads Sync Write Req: " << n Err << '\n'; // Close communication port n Err = Ads Port Close(); if (n Err) cerr << "Error: Ads Port Close: " << n Err << '\n'; } 6.10 Read PLC variable declaration Download: https://infosys.beckhoff.com/content/1033/tc3_adsdll2/Resources/7723090315/.zip The following information is transferred when accessing the variable declaration: • Variable name • Data type • Length • Address (Index Group / Index Offset) • Comment All the information listed above is transmitted in a data stream. Before this can be read, the first Ads Sync Read Req() [} 11] is used to obtain the length. The data itself is transferred with the second Ads Sync Read Req() [} 11]. The pch Symbols variable is a pointer, pointing to this region. The FOR-loop copies the corresponding data region into the p Ads Symbol Entry structure for each individual PLC variable. The individual information items in the PLC variables are stored in this structure. The macros PADSSYMBOLNAME, PADSSYMBOLTYPE and PADSSYMBOLCOMMENT simplify the evaluation of this data. #include <iostream.h> #include <windows.h> #include <conio.h> #include <assert.h> // ADS headers for Twin CAT 3 #include "C:\Twin CAT\3.0\Ads Api\Tc Ads Dll\Include\Tc Ads Def.h" #include "C:\Twin CAT\3.0\Ads Api\Tc Ads Dll\Include\Tc Ads API.h" void main() { long n Err, n Port; char *pch Symbols = NULL; UINT ui Index; Ams Addr Addr; PAms Addr p Addr = &Addr; Ads Symbol Upload Info t Ads Symbol Upload Info; PAds Symbol Entry p Ads Symbol Entry; // Open communication port on the ADS router n Port = Ads Port Open(); n Err = Ads Get Local Address(p Addr); if (n Err) cerr << "Error: Ads Get Local Address: " << n Err << '\n'; // Select Port: Twin CAT 3 PLC1 = 851 p Addr->port = 851; // Read the length of the variable declaration n Err = Ads Sync Read Req(p Addr, ADSIGRP_SYM_UPLOADINFO, 0x0, sizeof(t Ads Symbol Upload Info), &t Ads Symbol Upload Info); if (n Err) cerr << "Error: Ads Sync Read Req: " << n Err << '\n'; pch Symbols = new char[t Ads Symbol Upload Info.n Sym Size]; assert(pch Symbols); // Read information about the PLC variables n Err = Ads Sync Read Req(p Addr, ADSIGRP_SYM_UPLOAD, 0, t Ads Symbol Upload Info.n Sym Size, pch Symbols); if (n Err) cerr << "Error: Ads Sync Read Req: " << n Err << '\n'; // Output information about the PLC variables p Ads Symbol Entry = (PAds Symbol Entry)pch Symbols; for (ui Index = 0; ui Index < t Ads Symbol Upload Info.n Symbols; ui Index++) { cout << PADSSYMBOLNAME(p Ads Symbol Entry) << "\t\t" << p Ads Symbol Entry->i Group << '\t' << p Ads Symbol Entry->i Offs << '\t' << p Ads Symbol Entry->size << '\t' TE1000 Version: 1.1.3 51
## Page 52

Samples << PADSSYMBOLTYPE(p Ads Symbol Entry) << '\t' << PADSSYMBOLCOMMENT(p Ads Symbol Entry) << '\n'; p Ads Symbol Entry = PADSNEXTSYMBOLENTRY(p Ads Symbol Entry); cout.flush(); } getch(); // Close communication port n Err = Ads Port Close(); if (n Err) cerr << "Fehler: Ads Port Close: " << n Err << '\n'; // Release memory if (pch Symbols) delete(pch Symbols); } 6.11 Detect status change in Twin CAT router and the PLC Download: https://infosys.beckhoff.com/content/1033/tc3_adsdll2/Resources/7723094283/.zip When an application is actually running it is often important to interrogate the status of Twin CAT and/or of its components; e.g., whether the PLC is in the RUN state. To avoid the need to repeatedly issue this inquiry, changes in the status can be detected very effectively with the aid of callback functions. The following example program monitors the status of the PLC (run-time system 1) and of the Twin CAT router. By invoking the Ads Ams Register Router Notification() function, the given callback function will be invoked every time the status of the Twin CAT router changes. The current status can be interrogated by means of the parameters that are transferred. The Ads Sync Add Device Notification Req() is used to monitor the status of the PLC. The data that is passed to the callback function represents the current status of the PLC. #include <iostream.h> #include <conio.h> #include <windows.h> #include <winbase.h> // ADS headers for Twin CAT 3 #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads Def.h" #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads API.h" void __stdcall Callback(Ams Addr*, Ads Notification Header*, ULONG); void __stdcall Router Call(LONG); void main() { LONG n Err, n Port; ULONG h Notification, h User = 0; Ams Addr Addr; PAms Addr p Addr = &Addr; Ads Notification Attrib ads Notification Attrib; // Open communication port on the ADS router n Port = Ads Port Open(); n Err = Ads Get Local Address(p Addr); if (n Err) cerr << "Error: Ads Get Local Address: " << n Err << '\n'; // Select Port: Twin CAT 3 PLC1 = 851 p Addr->port = 851; n Err = Ads Ams Register Router Notification(&Router Call); if (n Err) cerr << "Error: Ads Ams Register Router Notification: " << n Err << '\n'; // Invoke notification ads Notification Attrib.cb Length = sizeof(short); ads Notification Attrib.n Trans Mode = ADSTRANS_SERVERONCHA; ads Notification Attrib.n Max Delay = 0; // jede Aenderung sofort melden ads Notification Attrib.dw Change Filter = 0; // n Err = Ads Sync Add Device Notification Req(p Addr, ADSIGRP_DEVICE_DATA, ADSIOFFS_DEVDATA_ADSSTATE, &ads Notification Attrib, Callback, h User, &h Notification); if (n Err) cerr << "Error: Ads Sync Add Device Notification Req: " << n Err << "\n"; getch(); // The following calls return errors if Twin CAT is halted n Err = Ads Sync Del Device Notification Req(p Addr, h Notification); if (n Err) cerr << "Error: Ads Sync Del Device Notification Req: " << n Err << '\n'; 52 Version: 1.1.3 TE1000
## Page 53

Samples n Err = Ads Ams Un Register Router Notification(); if (n Err) cerr << "Error: Ads Ams Un Register Router Notification: " << n Err << '\n'; n Err = Ads Port Close(); if (n Err) cerr << "Error: Ads Port Close: " << n Err << '\n'; return; } // ADS state callback function void __stdcall Callback(Ams Addr* p Addr, Ads Notification Header* p Notification, ULONG h User) { INT n Index; n Index = *(short *)p Notification->data; switch (n Index) { case ADSSTATE_RUN: cout << "PLC run\n"; break; case ADSSTATE_STOP: cout << "PLC stop\n"; break; default : cout << "PLC ADS-State" << n Index << "\n"; break; } cout.flush (); } // Twin CAT router callback function void __stdcall Router Call (long n Reason) { switch (n Reason) { case AMSEVENT_ROUTERSTOP: cout << "Twin CAT-Router stop\n"; break; case AMSEVENT_ROUTERSTART: cout << "Twin CAT-Router start\n"; break; case AMSEVENT_ROUTERREMOVED: cout << "Twin CAT-Router removed\n"; break; default: cout << "Twin CAT-Router AMS-Event " << n Reason << "\n"; break; } cout.flush (); } 6.12 Event-Driven Detection of Changes to the Symbol Table Download: https://infosys.beckhoff.com/content/1033/tc3_adsdll2/Resources/7723095947/.zip. ADS devices that support symbol names (PLC, NC, ...) store those names in an internal table. A handle is assigned here to each symbol. The symbol handle is necessary in order to be able to access the variables (see also Example 9 [} 50]). If the symbol table changes because, for instance, a new PLC program is written into the controller, the handles must be ascertained once again. The example below illustrates how changes to the symbol table can be detected. #include <iostream.h> #include <windows.h> #include <conio.h> #include <winbase.h> // ADS headers for Twin CAT 3 #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads Def.h" #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads API.h" void __stdcall Symbol Changed(Ams Addr*, Ads Notification Header*, unsigned long); void main() { long n Err; Ams Addr Addr; PAms Addr p Addr = &Addr; ULONG h Notification; TE1000 Version: 1.1.3 53
## Page 54

Samples Ads Notification Attrib ads Notification Attrib; // Open communication port on the ADS router Ads Port Open(); n Err = Ads Get Local Address(p Addr); if (n Err) cerr << "Error: Ads Get Local Address: " << n Err << '\n'; // Select Port: Twin CAT 3 PLC1 = 851 p Addr->port = 851; // Specify attributes of the notification ads Notification Attrib.cb Length = 1; ads Notification Attrib.n Trans Mode = ADSTRANS_SERVERONCHA; ads Notification Attrib.n Max Delay = 5000000; // 500ms ads Notification Attrib.n Cycle Time = 5000000; // 500ms // Start notification for changes to the symbol table n Err = Ads Sync Add Device Notification Req(p Addr, ADSIGRP_SYM_VERSION, 0, &ads Notification Attrib, Symbol Changed, NULL, &h Notification); if (n Err) cerr << "Error: Ads Sync Add Device Notification Req: " << n Err << '\n'; // Wait for a key-press from the user getch(); // Stop notification n Err = Ads Sync Del Device Notification Req(p Addr, h Notification); if (n Err) cerr << "Error: Ads Sync Del Device Notification Req: " << n Err << '\n'; // Close communication port n Err = Ads Port Close(); if (n Err) cerr << "Error: Ads Port Close: " << n Err << '\n'; } // Callback function void __stdcall Symbol Changed(Ams Addr* p Addr, Ads Notification Header* p Notification, ULONG h User) { cout << "Symboltabelle hat sich geändert!\n"; cout.flush(); } 6.13 Reading the PLC variable declaration of an individual variable Download: https://infosys.beckhoff.com/content/1033/tc3_adsdll2/Resources/7723097611/.zip The following information is transferred when accessing the variable declaration: • Variable name • Data type • Length • Address (Index Group / Index Offset) • Comment The Ads Sync Read Write Req() call is used to read the variable information. The variable name is transferred to the function via parameter p Write Data. After the call the requested information is contained in variable p Ads Symbol Entry . The individual information items in the PLC variables are stored in this structure. The macros PADSSYMBOLNAME, PADSSYMBOLTYPE and PADSSYMBOLCOMMENT simplify the evaluation of this data. In the next step, the data type of the variable is evaluated via p Ads Symbol Entry->data Type. If the data type is UDINT or ARRAY OF UDINT, the value of this variable is also read. #include <windows.h> #include <conio.h> #include <assert.h> #include <string.h> #include <iostream.h> // ADS headers for Twin CAT 3 #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads Def.h" #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads API.h" typedef enum Ads Data Type Id 54 Version: 1.1.3 TE1000
## Page 55

Samples { ADST_VOID = VT_EMPTY, ADST_INT8 = VT_I1, ADST_UINT8 = VT_UI1, ADST_INT16 = VT_I2, ADST_UINT16 = VT_UI2, ADST_INT32 = VT_I4, ADST_UINT32 = VT_UI4, ADST_INT64 = VT_I8, ADST_UINT64 = VT_UI8, ADST_REAL32 = VT_R4, ADST_REAL64 = VT_R8, ADST_STRING = VT_LPSTR, ADST_WSTRING = VT_LPWSTR, ADST_REAL80 = VT_LPWSTR+1, ADST_BIT = VT_LPWSTR+2, ADST_BIGTYPE = VT_BLOB, ADST_MAXTYPES = VT_STORAGE, } ADS_DATATYPE; typedef struct _Value String { DWORD dw Value; char* sz Label; } Value String; Value String Ads Datatype String[] = { { VT_EMPTY, "ADST_VOID", }, { VT_I1, "ADST_INT8", }, { VT_UI1, "ADST_UINT8", }, { VT_I2, "ADST_INT16", }, { VT_UI2, "ADST_UINT16", }, { VT_I4, "ADST_INT32", }, { VT_UI4, "ADST_UINT32", }, { VT_I8, "ADST_INT64", }, { VT_UI8, "ADST_UINT64", }, { VT_R4, "ADST_REAL32", }, { VT_R8, "ADST_REAL64", }, { VT_LPSTR, "ADST_STRING", }, { VT_LPWSTR, "ADST_WSTRING", }, { VT_LPWSTR+2, "ADST_BIT", }, { VT_BLOB, "ADST_BIGTYPE", }, { VT_STORAGE, "ADST_MAXTYPES", }, }; void main() { long n Err, n Port; Ams Addr Addr; PAms Addr p Addr = &Addr; char sz Variable[255]; BYTE buffer[0x FFFF]; PAds Symbol Entry p Ads Symbol Entry; // Open communication port on the ADS router n Port = Ads Port Open(); n Err = Ads Get Local Address(p Addr); if (n Err) cerr << "Error: Ads Get Local Address: " << n Err << '\n'; // Select Port: Twin CAT 3 PLC1 = 851 p Addr->port = 851; for(;;) { cout << "Enter variable Name: "; cin >> sz Variable; n Err = Ads Sync Read Write Req(p Addr, ADSIGRP_SYM_INFOBYNAMEEX, 0, sizeof(buffer), buffer, strlen(sz Variable)+1, sz Variable); if (n Err) { cerr << "Error: Ads Sync Read Req: " << n Err << '\n'; } else { p Ads Symbol Entry = (PAds Symbol Entry)buffer; cout << "Name: " << PADSSYMBOLNAME(p Ads Symbol Entry) << "\n" <<"Index Group: "<< p Ads Symbol Entry->i Group << '\n' <<"Index Offset: "<< p Ads Symbol Entry->i Offs << '\n' TE1000 Version: 1.1.3 55
## Page 56

Samples <<"Size: "<< p Ads Symbol Entry->size << '\n' <<"Type: "<< (char*)PADSSYMBOLTYPE(p Ads Symbol Entry) << '\n' <<"Comment: "<< (char*)PADSSYMBOLCOMMENT(p Ads Symbol Entry) << '\n'; switch( p Ads Symbol Entry->data Type ) { case ADST_UINT32: { int n Elements = p Ads Symbol Entry->size/sizeof(unsigned long); unsigned long *p Val = new unsigned long[n Elements]; cout << "Datatype: ADST_UINT32" <<'\n'; Ads Sync Read Req(p Addr, p Ads Symbol Entry->i Group, p Ads Symbol Entry->i Offs, p Ads Symbol Entry->size, p Val); if( n Err ) { cerr << "Error: Ads Sync Read Req: Unable to read Value" << n Err << '\n'; } else { cout << "Value: "; for( int i=0; i<n Elements; i++ ) { cout << p Val[i] << '\t'; } cout << '\n'; } } break; default: { int n Type = sizeof(Ads Datatype String)/sizeof(Value String); for( int i=0; i< n Type; i++ ) { if( Ads Datatype String[i].dw Value == p Ads Symbol Entry->data Type ) { cout << "Datatype:" << Ads Datatype String[i].sz Label <<'\n'; break; } } if( i == n Type ) cout << "Datatype:" << "Unknown datatype:" << p Ads Symbol Entry->data Type <<'\n'; } break; } } cout << "Exit(y/n)" << '\n'; cout.flush(); if( getch() == 'y' ) break; } // Close communication port n Err = Ads Port Close(); if (n Err) cerr << "Fehler: Ads Port Close: " << n Err << '\n'; } 6.14 Upload PLC-variabledeclaration (dynamic) (2/2) Download: https://infosys.beckhoff.com/content/1033/tc3_adsdll2/Resources/12470837515/.zip This sample describes how to upload the PLC symbol information in a more efficient dynamic way. The PLC symbol information contain the following parts: • variable name • data type • length • address (Index Group / Index Offset) • comment 56 Version: 1.1.3 TE1000
## Page 57

Samples NOTICE We highly recommend to NOT work with this Index Group/Index Offset for ADS communication but instead use handles of symbols for ADS communication. After uploading the information "name", "datatype" and "length" it makes sense to request a handle for this symbol. Read the major information via ADS into internal class "CAds Parse Symbols": // Read major symbol information via ADS from device Ads Symbol Upload Info2 info; n Result = Ads Sync Read Req(&m_ams Addr, ADSIGRP_SYM_UPLOADINFO2, 0, sizeof(info), &info); if ( n Result == ADSERR_NOERR ) { // size of symbol information PBYTE p Sym = new BYTE[info.n Sym Size]; if ( p Sym ) { // upload symbols (instances) n Result = Ads Sync Read Req(&m_ams Addr, ADSIGRP_SYM_UPLOAD, 0, info.n Sym Size, p Sym); if ( n Result == ADSERR_NOERR ) { // get size of datatype description PBYTE p DT = new BYTE[info.n Datatype Size]; if ( p DT ) { // upload datatye-descriptions n Result = Ads Sync Read Req(&m_ams Addr, ADSIGRP_SYM_DT_UPLOAD, 0, info.n Datatype Size, p DT); if ( n Result == ADSERR_NOERR ) { // create class-object for each datatype-description m_p Dyn Symbols = new CAds Parse Symbols(p Sym, info.n Sym Size, p DT, info.n Datatype Size); if ( m_p Dyn Symbols == NULL ) n Result = ADSERR_DEVICE_NOMEMORY; } delete [] p DT; } } delete [] p Sym; } } } Get Parent : The routine Get Parent will jump NOT jump to the direct parent of a child. Instead this command will jump to the next entry of the direct parent. Get Sibling: Selecting this option will return the next symbol within the current hierarchy level. Symbols containing child information will be displayed, but the child elements will not be displayed. Get Child: If the current symbol contains child-symbol information (so the current symbol is an instance of a datatype description), this command will enter the next hierarchy and return the information about first child object. Get Next: Clicking this button the next symbol will be extracted from internal class "CAds Parse Symbols" and be displayed. Selecting always just this option allows to navigate from first ADS-symbol through the hierarchy symbol tree to the end of list. 6.15 ADS-sum command: Read or Write a list of variables with one single ADS-command Download: https://infosys.beckhoff.com/content/1033/tc3_adsdll2/Resources/7723115403/.zip This sample describes how to read multiple single variables with one single ADS API call. TE1000 Version: 1.1.3 57
## Page 58

Samples Mind the ADS requirements Note that ADS is just a transport layer, but there could be important side effects: So read these requirements and take care on limitations. Background : ADS offers powerful and fast communication to exchange any kind of information. It's possible to read single variables or complete arrays and structures with each one single ADS-API call. This new ADS command offers to read with one singale ADS call multiple variables which are not structured within a linear memory. As a result the ADS caller application (like scada Systems etc.) can extremly speed up cyclic polling : Sample : • Until now : Polling 4000 single variables which are not in a linear area (like array / structure / fixed PLC address ) would cause 4000 single Ads-Read Req with each 1-2 ms protocol time. As a result the scanning of these variables take 4000ms-8000ms. • New Ads-Command allows to read multiple variables with one single ADS-Read Req : 4000 single variables are handled with e.g. 8 single Ads-Read Req (each call requesting 500 variables) with each 1-2 ms protocol time. As a result the scanning of these variables take just few 10ms. Requirements and important limitations: Note that ADS is just a transport layer, but there could be important side effects. So read these requirements and take care on limitations: • Version of target ADS Device: ADS itself is just the transport layer, but the requested ADS device has to support the ADS-Command. • Bytes length of requested data: Requesting a large list of values from variables is fine, but the requested data of the Ads-response (the data-byte-length) have to pass the AMS-router (size by default a 2048kb) So the caller has to limit the requested variables based on calculation of requested data-byte-length. • Number of Sub-ADS calls: Highly recommended to max. 500! If the PLC is processing one ADS request, it will completely work on this single ADS request BEFORE starting next PLC cycle. As a result one single ADS request with 200.000 sub-Ads-requests would cause that PLC would collect and copy 200.000 variables into one single ADS response, before starting next PLC. So this large number of ads-sub-commands will jitter the PLC execution! Notice We highly recommend to not request more than 500 Ads-Sub commands. // This code snippet using ADSIGRP_SUMUP_READ with Index Group 0x F080 and Index Offset as number of ADS-sub-commands // Demonstrates how to read a list of variables, see full demo-code // Use ADS-Read Write request : "Write" the requested data down to ADS device and "Read" the received answer n Err = Ads Sync Read Write Req( p Addr, 0x F080, // Sum-Command, response will contain ADS-error code for each ADS-Sub-command req Num, // number of ADS-Sub-Commands 4*req Num+req Size, // number requested bytes in the sample two variables each 4 bytes. NOTE : we request additional "error"-flag(long) for each ADS-sub commands (void*)(m Ads Sum Buffer Res), // provide buffer for response 12*req Num, // send 12 bytes for each variable (each ads-Sub command consist of 3 * ULONG : IG, IO, Len) &par Req); // This code snippet using ADSIGRP_SUMUP_WRITE with Index Group 0x F081 and Index Offset as number of ADS-sub-commands // Demonstrates how to write a list of variables, see full demo-code // Use ADS-Read Write request : "Write" the send a list of data to list of variables down to ADS device and "Read" the received return codes n Err = Ads Sync Read Write Req( p Addr, 0x F081, // ADS list-write command 58 Version: 1.1.3 TE1000
## Page 59

Samples req Num, // number of ADS-Sub commands 4*req Num, // we expect an ADS-error-return-code (long) for each ADS-Sub command (void*)(m Ads Sum Buffer Res), // provide space for the response containing the return codes 16*req Num, // cbyte Len : in THIS sample we send two variables each 4 byte // --> send 16 bytes (IG1, IO1, Len1, IG2, IO2, Len2, Data1, Data2) &par Req); // buffer with data 6.16 ADS-sum command: Get and release several handles Download: https://infosys.beckhoff.com/content/1033/tc3_adsdll2/Resources/7723117067/.zip This sample shows how to get and release several handles with the ADS-sum command. It's constructed like the Ads Sync Read Write Request and is used as container to transport the sub commands. 1. Get handles First, all necessary headers have to be included. #include <iostream.h> #include <windows.h> #include <conio.h> // ADS headers for Twin CAT 3 #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads Def.h" #include "C:\Twin CAT\Ads Api\Tc Ads Dll\Include\Tc Ads API.h" Next step is to define a structure, declare variables and allocate memory. // Structure declaration for valuestypedef struct data Req { unsigned long index Group; // index group in ADS server interfaceunsigned long index Offset; // index offset in ADS server interfaceunsigned long rlength; // count of bytes to readunsigned long wlength; // count of bytes to write }TData Req, *PTData Req; // Variables declaration Ams Addr Addr; LONG n Err, n Port; PAms Addr p Addr = &Addr; char sz Var1[] = {".b Var01"}; char sz Var2[] = {".b Var02"}; // Allocate memory ULONG cb Req = ( sizeof(TData Req)*2 ) + sizeof(sz Var1) + sizeof(sz Var2); BYTE* p Buff Req = new BYTE[cb Req]; BYTE* p Buff Res = new BYTE[24]; // Put structure over memory PTData Req p Data Req = (PTData Req)p Buff Req; ULONG* p Data Res = (ULONG*)p Buff Res; The values which can be transferred are written behind the last structure. // p Data Req-> structure 1 p Data Req->index Group = ADSIGRP_SYM_HNDBYNAME; p Data Req->index Offset = 0x0; p Data Req->rlength = sizeof(ULONG); p Data Req->wlength = sizeof(sz Var1); // Skip to next structure p Data Req = p Data Req+1; // p Data Req-> structure 2 TE1000 Version: 1.1.3 59
## Page 60

Samples p Data Req->index Group = ADSIGRP_SYM_HNDBYNAME; p Data Req->index Offset = 0x0; p Data Req->rlength = sizeof(ULONG); p Data Req->wlength = sizeof(sz Var2); // Skip to write data 1char* sz Var Name = ( (char*)p Data Req ) + sizeof(TData Req); strncpy( sz Var Name, sz Var1, sizeof(sz Var1) ); // Skip to write data 2 sz Var Name = sz Var Name + sizeof(sz Var1); strncpy( sz Var Name, sz Var2, sizeof(sz Var2) ); For the communication a open port is necessary. After that the local address is handed over. If it comes to transmission the port is assigned to the address of the run time system 1 first. The parameters for the sum command consist of Index Group (0xf082) - call the sum command, Index Offset (0x2)- count of sub commands, Read Length (0x18)- size of the data which can be read, Read Data (p Buff Res)- memory which read data assumes, Write Length (cb Req)- size of the data which can be send and Write Length (p Buff Req)- memory which contains data that can be sent. // Open communication port on the ADS router n Port = Ads Port Open(); n Err = Ads Get Local Address(p Addr); cout << "open port: "; if (n Err == 0) { cout << "OK" << '\n'; // Get handles p Addr->port = AMSPORT_R0_PLC_RTS1; n Err = Ads Sync Read Write Req( p Addr, 0xf082, // ADS list-read-write command 0x2, // number of ADS-sub commands 0x18, // we expect an ADS-error-return-code for each ADS-sub command p Buff Res, // provide space for the response containing the return codes cb Req, // cb Req : send 48 bytes (IG1, IO1, RLen1, WLen1,// IG2, IO2, RLen2, WLen2, Data1, Data2) p Buff Req ); // buffer with data } else {cout << "ERROR [" << n Err << "]" << '\n';}; cout << "connect: "; if (n Err == 0) { cout << "OK" << '\n'; // Skip to handle 1 and examine the value ULONG n Var Handle = *( (ULONG*)p Buff Res ); if (n Var Handle != 0) { cout << " > handle1: "; cout << "ERROR [" << n Var Handle << "]" << '\n'; } // Skip to handle 2 and examine the value n Var Handle = *( (ULONG*)p Buff Res + 2 ); if (n Var Handle != 0) { cout << " > handle2: "; cout << "ERROR [" << n Var Handle << "]" << '\n'; } } else {cout << "ERROR [" << n Err << "]" << '\n';}; 2. Release handles Define a structure, declare variables and allocate memory again. // Structure declaration for valuestypedef struct data Rel { unsigned long index Group; // index group in ADS server interfaceunsigned long index Offset; // index offset in ADS server interfaceunsigned long length; // count of bytes to write }TData Rel, *PTData Rel; // Variables declaration ULONG* n Var1 = (ULONG*)p Buff Res+4; ULONG* n Var2 = (ULONG*)p Buff Res+5; 60 Version: 1.1.3 TE1000
## Page 61

Samples // Allocate memory ULONG cb Rel = sizeof(TData Rel)*2 + sizeof(ULONG)*2; BYTE* p Buff Rel = new BYTE[cb Rel]; ULONG cb Rel Res = sizeof(ULONG)*2; BYTE* p Buff Rel Res = new BYTE[cb Rel Res]; // Put structure over memory PTData Rel p Data Rel = (PTData Rel)p Buff Rel; ULONG* p Data Rel Res = (ULONG*)p Buff Rel Res; The values which can be transferred are written behind the last structure again. // p Data Rel-> structure 1 p Data Rel->index Group = ADSIGRP_IOIMAGE_RWIB; p Data Rel->index Offset = 0x0; p Data Rel->length = sizeof(ULONG); // Skip to next structure p Data Rel++; // p Data Req-> structure 2 p Data Rel->index Group = ADSIGRP_IOIMAGE_RWIB; p Data Rel->index Offset = 0x0; p Data Rel->length = sizeof(ULONG); // Skip to next structure p Data Rel++; // Write handles into structure memcpy( p Data Rel, n Var1, sizeof(ULONG) ); memcpy( (ULONG*)p Data Rel+1, n Var2, sizeof(ULONG) ); The existing connection is used to release the handles. The parameters for the sum command consist of Index Group (0xf081) - call the sum command, Index Offset (0x2)- count of sub commands, Read Length (cb Rel Res)- size of the data which can be read, Read Data (p Buff Rel Res)- memory which read data assumes, Write Length (cb Rel)- size of the data which can be send and Write Length (p Buff Rel)- memory which contains data that can be sent. Last thing left is releasing the handles and closing the port. // Release handles n Err = Ads Sync Read Write Req( p Addr, 0xf081, // ADS list-write command 0x2, // number of ADS-sub commands cb Rel Res, // we expect an ADS-error-return-code for each ADS-sub command p Buff Rel Res, // provide space for the response containing the return codes cb Rel, // cb Req : send 40 bytes (IG1, IO1, Len1, IG2, IO2, Len2, Data1, Data2) p Buff Rel ); // buffer with data cout << "disconnect: "; if (n Err == 0) { cout << "OK" << '\n'; // Skip to handle 1 and examine the value ULONG n Var Handle = *( (ULONG*)p Buff Res ); if (n Var Handle != 0) { cout << " > handle1: "; cout << "ERROR [" << n Var Handle << "]" << '\n'; } // Skip to handle 2 and examine the value n Var Handle = *( (ULONG*)p Buff Res + 2 ); if (n Var Handle != 0) { cout << " > handle2: "; cout << "ERROR [" << n Var Handle << "]" << '\n'; TE1000 Version: 1.1.3 61
## Page 62

Samples } } else {cout << "ERROR [" << n Err << "]" << '\n';}; // Close the communication port n Err = Ads Port Close(); cout << "close port: "; if (n Err == 0) {cout << "OK" << '\n' << "-------------------" << '\n';} else {cout << "ERROR [" << n Err << "]" << '\n' << "-------------------" << '\n';} cout.flush(); // Wait for key press getch(); } 6.17 Transmitting structures to the PLC Download: https://infosys.beckhoff.com/content/1033/tc3_adsdll2/Resources/7723118731/.zip This example shows how to write a structure to the PLC via ADS. The elements in the structure have different data types: #include <stdio.h> #include <tchar.h> #include "windows.h" // ADS headers for Twin CAT 3 #include "C:\Twin CAT\3.0\Ads Api\Tc Ads Dll\Include\Tc Ads Def.h" #include "C:\Twin CAT\3.0\Ads Api\Tc Ads Dll\Include\Tc Ads API.h" // Create new struct typedef struct Plc Struct { INT16 short Val; INT32 int Val; byte byte Val; DOUBLE double Val; FLOAT float Val; } SPlc Var, *p SPlc Var; int _tmain(int argc, _TCHAR* argv[]) { long n Err, n Port; Ams Addr Addr; PAms Addr p Addr = &Addr; ULONG l Hdl Var; // New struct. Assign test values Plc Struct Plc Var; Plc Var.short Val = 1; Plc Var.int Val = 2; Plc Var.byte Val = 3; Plc Var.double Val = 4.04; Plc Var.float Val = (FLOAT)5.05; // Declare PLC variable which should notify changes char sz Var []={"MAIN. PLCVar"}; // Extract values from struct and write to byte array // Circumvent memory holes caused by padding BYTE *p Data = new BYTE[19]; int n IOffs = 0; memcpy_s(&p Data[n IOffs], 19, &Plc Var.short Val, 2); n IOffs += 2; memcpy_s(&p Data[n IOffs], 17, &Plc Var.int Val, 4); n IOffs += 4; memcpy_s(&p Data[n IOffs], 13, &Plc Var.byte Val, 1); n IOffs++; memcpy_s(&p Data[n IOffs], 12, &Plc Var.double Val, 8); n IOffs += 8; memcpy_s(&p Data[n IOffs], 4, &Plc Var.float Val, 4); // Open communication port on the ADS router 62 Version: 1.1.3 TE1000
## Page 63

Samples n Port = Ads Port Open(); n Err = Ads Get Local Address(p Addr); if (n Err) printf("Error: Ads: Open port: %d\n", n Err); // Twin CAT 3 PLC1 = 851 p Addr->port = 851; // Get variable handle n Err = Ads Sync Read Write Req(p Addr, ADSIGRP_SYM_HNDBYNAME, 0x0, sizeof(l Hdl Var), &l Hdl Var, sizeof(sz Var), sz Var); // Write the struct to the Plc Ads Sync Write Req(p Addr, ADSIGRP_SYM_VALBYHND, // Index Group l Hdl Var, // Index Offset 0x13, // Size of struct (void*) p Data); if (n Err) printf("Error: Ads: Write struct: %d\n", n Err); // Close communication delete [] p Data; //Release handle of plc variable n Err = Ads Sync Write Req(p Addr, ADSIGRP_SYM_RELEASEHND, 0, sizeof(l Hdl Var), &l Hdl Var); if (n Err) printf("Error: Ads Sync Write Req: %d \n", n Err); n Err = Ads Port Close(); if (n Err) printf("Error: Ads: Close port: %d\n", n Err); getchar(); } 6.18 Reading and writing of TIME/DATE variables Download: https://infosys.beckhoff.com/content/1033/tc3_adsdll2/Resources/7723120395/.zip The PLC contains the TIME variable MAIN. Time1 and the DT variable MAIN. Date1. This example shows how to read, write and display those variables: #include <stdio.h> #include <windows.h> #include <tchar.h> #include <time.h> // ADS headers for Twin CAT 3 #include "C:\Twin CAT\3.0\Ads Api\Tc Ads Dll\Include\Tc Ads Def.h" #include "C:\Twin CAT\3.0\Ads Api\Tc Ads Dll\Include\Tc Ads API.h" #define TIME_LENGHT 56 #define DATE_LENGHT 62 #define MON_START 1 #define YEAR_START 1900 int _tmain(int argc, _TCHAR* argv[]) { long l Err, l Port; long l Time, l Ms, l Sek, l Min, l Hour, l Day; Ams Addr Addr; PAms Addr p Addr = &Addr; DWORD dw Time, dw Date; ULONG l Hdl Time, l Hdl Date; // Declare PLC variable char sz Plc Time []={"MAIN. Time1"}; char sz Plc Date []={"MAIN. Date1"}; // Open the communication l Port = Ads Port Open(); l Err = Ads Get Local Address(p Addr); if(l Err) printf_s((char*)"Error: Getting local adress: 0x%i \n", l Err); p Addr->port = AMSPORT_R0_PLC_RTS1; TE1000 Version: 1.1.3 63
## Page 64

Samples // Get variable handle l Err = Ads Sync Read Write Req(p Addr, ADSIGRP_SYM_HNDBYNAME, 0x0, sizeof(l Hdl Time), &l Hdl Time, sizeof(sz Plc Time), sz Plc Time); l Err = Ads Sync Read Write Req(p Addr, ADSIGRP_SYM_HNDBYNAME, 0x0, sizeof(l Hdl Date), &l Hdl Date, sizeof(sz Plc Date), sz Plc Date); // Read from MAIN. Time1 l Err = Ads Sync Read Req(p Addr, ADSIGRP_SYM_VALBYHND, // Index Group l Hdl Time, // Index Offset 0x4, // Size of DWORD &dw Time); if(l Err) printf_s((char*)"Error: Read time variable: 0x%i \n", l Err); //Convert DWORD to Time l Time = (long)dw Time; l Ms = (l Time % 1000); l Sek = (l Time / 1000) % 60; l Min = (l Time / 60000) % 60; l Hour = (l Time / 3600000) % 24; l Day = (l Time / 86400000) % 365; wchar_t sz Time[TIME_LENGHT]; wsprintf(sz Time, L"Time from PLC: %dd %dh %dm %ds %dms \n", l Day, l Hour, l Min, l Sek, l Ms); wprintf_s(sz Time); //Write to MAIN. Time1 //Manipulate DWORD for demonstration dw Time += 3600000; //Add 3600000ms (One hour) //Ads Write l Err = Ads Sync Write Req(p Addr, ADSIGRP_SYM_VALBYHND, //Index Group l Hdl Time, //Index Offset 0x4, &dw Time); if(l Err) printf_s((char*)"Error: Write time variable: 0x%i \n", l Err); //Read from MAIN. Date1 //Ads Read l Err = Ads Sync Read Req(p Addr, ADSIGRP_SYM_VALBYHND, //Index Group l Hdl Date, //Index Offset 0x4, &dw Date); if(l Err) printf_s((char*)"Error: Read date variable: 0x%i \n", l Err); //Convert long to date time_t t Date(dw Date); tm tm Date; gmtime_s(&tm Date, &t Date); wchar_t sz Date[DATE_LENGHT]; wsprintf(sz Date, L"Date from PLC: %d/%d/%d %d:%d:%d \n", tm Date.tm_mday, tm Date.tm_mon + MON_START, tm Date.tm_year + YEAR_START, tm Date.tm_hour, tm Date.tm_min, tm Date.tm_sec); wprintf_s(sz Date); //Write to MAIN. Date1 //Manipulate DWORD for demonstration dw Date += 3600; //Add 3600s (One hour) //Ads Write l Err = Ads Sync Write Req(p Addr, ADSIGRP_SYM_VALBYHND, //Index Group l Hdl Date, //Index Offset 0x4, &dw Date); if(l Err) printf_s((char*)L"Error: Write time variable: 0x%i \n", l Err); 64 Version: 1.1.3 TE1000
## Page 65

Samples //Releases handles of plc variable l Err = Ads Sync Write Req(p Addr, ADSIGRP_SYM_RELEASEHND, 0, sizeof(l Hdl Time), &l Hdl Time); if (l Err) printf("Error: Ads Sync Write Req: %d \n", l Err); l Err = Ads Sync Write Req(p Addr, ADSIGRP_SYM_RELEASEHND, 0, sizeof(l Hdl Date), &l Hdl Date); if (l Err) printf("Error: Ads Sync Write Req: %d \n", l Err); //Close the communication l Err = Ads Port Close(); if(l Err) printf_s((char*)L"Error: Closing connection: 0x%i \n", l Err); printf_s("\n Press enter to exit.."); getchar(); } TE1000 Version: 1.1.3 65
## Page 67

More Information: www.beckhoff.com/te1000 Beckhoff Automation Gmb H & Co. KG Hülshorstweg 20 33415 Verl Germany Phone: +49 5246 9630 info@beckhoff.com www.beckhoff.com
