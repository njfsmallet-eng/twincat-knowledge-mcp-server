---
title: "TE1200_TC3_PLC_Static_Analysis_EN"
product: "TE1200"
category: "PLC"
tags: ["ANALYSIS", "PLC", "STATIC"]
language: "EN"
document_type: "Manual"
version: "2.9.0"
source_pdf: "https://download.beckhoff.com/download/Document/automation/twincat3/TE1200_TC3_PLC_Static_Analysis_EN.pdf"
release_date: "2025-06-30"
---
Manual | EN TE1200 Twin CAT 3 | PLC Static Analysis 2025-06-30 | Version: 2.9.0

## Page 3

Table of contents Table of contents 1 Foreword.................................................................................................................................................... 5 1.1 Notes on the documentation............................................................................................................. 5 1.2 For your safety.................................................................................................................................. 5 1.3 Notes on information security............................................................................................................ 7 1.4 Information on the security risk analysis........................................................................................... 8 2 Overview.................................................................................................................................................... 9 3 Installation............................................................................................................................................... 11 3.1 Functionality: Light vs. full............................................................................................................... 11 3.2 System Requirements..................................................................................................................... 13 3.3 Licensing......................................................................................................................................... 13 4 Configuration........................................................................................................................................... 14 4.1 Settings........................................................................................................................................... 14 4.2 Rules............................................................................................................................................... 16 4.2.1 Rules - overview and description..................................................................................... 17 4.3 Naming conventions........................................................................................................................ 81 4.3.1 Naming conventions – overview and description............................................................. 83 4.3.2 Options............................................................................................................................. 90 4.3.3 Placeholder {datatype}..................................................................................................... 93 4.4 Metrics............................................................................................................................................. 94 4.4.1 Metrics - overview and description................................................................................... 95 4.5 Forbidden symbols ....................................................................................................................... 110 5 Commands............................................................................................................................................. 111 5.1 Command 'Run static analysis'..................................................................................................... 111 5.1.1 Syntax in the message window...................................................................................... 112 5.2 Command 'Run static analysis [Check all objects]'....................................................................... 113 5.3 Command 'View Standard Metrics'............................................................................................... 114 5.3.1 Commands in the context menu of the 'Standard Metrics' view..................................... 115 5.4 Command 'View Standard Metrics [Check all objects]'................................................................. 116 5.4.1 Commands in the context menu of the 'Standard Metrics' view..................................... 117 5.5 'Show constant propagation values for current editor' command.................................................. 118 5.6 Command 'Show cognitive complexity for current editor'.............................................................. 119 6 Pragmas and attributes........................................................................................................................ 121 7 Constant propagation........................................................................................................................... 126 8 Quick Fix/Precompile............................................................................................................................. 130 9 Automation Interface support.............................................................................................................. 132 10 Examples............................................................................................................................................... 135 10.1 Static analysis............................................................................................................................... 135 10.2 Standard metrics........................................................................................................................... 136 11 Support and Service............................................................................................................................. 138 TE1200 Version: 2.9.0 3

## Page 4

Table of contents 4 Version: 2.9.0 TE1200

## Page 5

Foreword 1 Foreword 1.1 Notes on the documentation This description is intended exclusively for trained specialists in control and automation technology who are familiar with the applicable national standards. The documentation and the following notes and explanations must be complied with when installing and commissioning the components. The trained specialists must always use the current valid documentation. The trained specialists must ensure that the application and use of the products described is in line with all safety requirements, including all relevant laws, regulations, guidelines, and standards. Disclaimer The documentation has been compiled with care. The products described are, however, constantly under development. We reserve the right to revise and change the documentation at any time and without notice. Claims to modify products that have already been supplied may not be made on the basis of the data, diagrams, and descriptions in this documentation. Trademarks Beckhoff®, ATRO® , Ether CAT®, Ether CAT G®, Ether CAT G10®, Ether CAT P®, MX-System®, Safety over Ether CAT®, TC/BSD®, Twin CAT®, Twin CAT/BSD®, Twin SAFE®, XFC®, XPlanar®, and XTS® are registered and licensed trademarks of Beckhoff Automation Gmb H. If third parties make use of the designations or trademarks contained in this publication for their own purposes, this could infringe upon the rights of the owners of the said designations. Ether CAT® is a registered trademark and patented technology, licensed by Beckhoff Automation Gmb H, Germany. Copyright © Beckhoff Automation Gmb H & Co. KG, Germany. The distribution and reproduction of this document, as well as the use and communication of its contents without express authorization, are prohibited. Offenders will be held liable for the payment of damages. All rights reserved in the event that a patent, utility model, or design are registered. Third-party trademarks Trademarks of third parties may be used in this documentation. You can find the trademark notices here: https://www.beckhoff.com/trademarks. 1.2 For your safety Safety regulations Read the following explanations for your safety. Always observe and follow product-specific safety instructions, which you may find at the appropriate places in this document. Exclusion of liability All the components are supplied in particular hardware and software configurations which are appropriate for the application. Modifications to hardware or software configurations other than those described in the documentation are not permitted, and nullify the liability of Beckhoff Automation Gmb H & Co. KG. TE1200 Version: 2.9.0 5

## Page 6

Foreword Personnel qualification This description is only intended for trained specialists in control, automation, and drive technology who are familiar with the applicable national standards. Signal words The signal words used in the documentation are classified below. In order to prevent injury and damage to persons and property, read and follow the safety and warning notices. Personal injury warnings DANGER Hazard with high risk of death or serious injury. WARNING Hazard with medium risk of death or serious injury. CAUTION There is a low-risk hazard that could result in medium or minor injury. Warning of damage to property or environment NOTICE The environment, equipment, or data may be damaged. Information on handling the product This information includes, for example: recommendations for action, assistance or further information on the product. 6 Version: 2.9.0 TE1200

## Page 7

Foreword 1.3 Notes on information security The products of Beckhoff Automation Gmb H & Co. KG (Beckhoff), insofar as they can be accessed online, are equipped with security functions that support the secure operation of plants, systems, machines and networks. Despite the security functions, the creation, implementation and constant updating of a holistic security concept for the operation are necessary to protect the respective plant, system, machine and networks against cyber threats. The products sold by Beckhoff are only part of the overall security concept. The customer is responsible for preventing unauthorized access by third parties to its equipment, systems, machines and networks. The latter should be connected to the corporate network or the Internet only if appropriate protective measures have been set up. In addition, the recommendations from Beckhoff regarding appropriate protective measures should be observed. Further information regarding information security and industrial security can be found in our https://www.beckhoff.com/secguide. Beckhoff products and solutions undergo continuous further development. This also applies to security functions. In light of this continuous further development, Beckhoff expressly recommends that the products are kept up to date at all times and that updates are installed for the products once they have been made available. Using outdated or unsupported product versions can increase the risk of cyber threats. To stay informed about information security for Beckhoff products, subscribe to the RSS feed at https:// www.beckhoff.com/secinfo. TE1200 Version: 2.9.0 7

## Page 8

Foreword 1.4 Information on the security risk analysis If you have installed this product, Beckhoff will provide you with the following information for a security risk analysis for your system. Engineering Workload: Twin CAT. Standard. XAE To be able to use the TE1200 function, you only need to install the standard workload mentioned above. See also: • Information on the security risk analysis for the Twin CAT standard XAE workload Runtime No runtime components are installed or required. 8 Version: 2.9.0 TE1200

## Page 9

Overview 2 Overview With the integration of the static code analysis, a further programming tool is available in Twin CAT 3.1 that supports the PLC software development process. The tool is integrated in Twin CAT 3 PLC and can be seen as a supplement to the compiler. Function overview Static Analysis implements more than 100 coding rules, some of which can be parameterized and combined to create individual rule sets. The rule sets defined in "PLCopen Coding Guidelines" are taken into account in some rules. For example, it can report if a pointer variable has not been checked for nonzero before dereferencing. As a result, the user's attention is drawn to possibly inadvertent and erroneous implementations, so that these program points can be optimized at an early stage. You can also define a naming convention for each possible data type, which is then checked for compliance. In addition, over 20 metrics are available to analyze and characterize the underlying source code. When calculated regularly, the metrics can indicate negative trends and deviations from quality targets. The key figures therefore represent an indicator for assessing software quality. For example, the tabular output contains metrics for the number of statements or the proportion of comments. The Static Analysis can be triggered manually or performed automatically during the code generation. Twin CAT outputs the result of the analysis, i.e. messages regarding deviations from the specifications and rules, in the message window. In the PLC project properties you can define the parameters to be checked in detail. When configuring the rules, you can also define whether a rule violation is to be output as an error or a warning. You can use pragma statements to exclude particular parts of the code from the check. For errors reported by Static Analysis based on precompile information, there is support in the ST Editor for immediate troubleshooting (Quick Fix/Precompile [} 130]). Advantage Static Analysis helps to write code that is easier to read and to identify potential sources of error during programming. On the one hand, this increases code quality and, on the other, saves a lot of time when developing applications and troubleshooting. Failure to observe a coding rule generally indicates an implementation weakness; correcting it enables early troubleshooting or error avoidance. The automatic control of the user-specific naming conventions also ensures that the control programs can be developed in a standardized manner with regard to type and variable names. This gives different PLC projects implemented on the basis of the same naming conventions a uniform look and feel, which greatly improves the readability of programs. In addition, the metrics provide an indication of the software quality. Functionalities An overview of the functionalities of "Twin CAT 3 PLC Static Analysis" is provided below: • Static Analysis: ◦ Function: The Static Analysis checks the source code of a project for deviations from certain coding rules and naming conventions, as well as for forbidden symbols. The result is output in the message window. ◦ Configuration: The required coding rules, naming conventions and forbidden symbols can be configured in the Rules [} 16], Naming conventions [} 81] and Forbidden symbols [} 110] tabs of the PLC project properties. • Standard metrics: ◦ Function: Certain metrics are applied to your source code, which express the software properties in the form of key figures (e.g. the number of statements or the percentage of comments). They provide an indication of the software quality. The results are output in the Standard Metrics view. ◦ Configuration: The required metrics can be configured in the Metrics [} 94] tab of the PLC project properties. Alternatively, there is an option to use a license-free version of Static Analysis that provides a very much reduced range of functions. A detailed comparison of the functions of the license-free and the licensed version of Static Analysis can be found in chapter Installation [} 11]. TE1200 Version: 2.9.0 9

## Page 10

Overview Further information on installation, configuration and execution of the "Static Analysis" can be found on the following pages: • Installation [} 11] • Configuration of the settings, rules, naming conventions, metrics and forbidden symbols [} 14] • Command 'Run static analysis' [} 111] • Command 'Run static analysis [Check all objects]' [} 113] • Command 'View Standard Metrics' [} 114] • Command 'View Standard Metrics [Check all objects]' [} 116] • Pragmas and attributes [} 121] • Examples [} 135] • Automation Interface support [} 132] Libraries Twin CAT only analyzes the application code of the current PLC project; the referenced libraries are ignored! If you have opened the library project, however, you can check the elements it contains with the help of the command Command 'Run static analysis [Check all objects]' [} 113]. Punctual disablement of checks Pragmas and attributes [} 121] can be used to disable checks for certain parts of the code. Static Analysis via the Automation Interface Static Analysis can be operated via the Automation Interface (see Automation Interface support [} 132]). 10 Version: 2.9.0 TE1200

## Page 11

Installation 3 Installation The TE1200 | Twin CAT 3 PLC Static Analysis function is installed when the Twin CAT 3 development environment is installed. Accordingly, there is no separate TF1200 setup/package. The additional TE1200 engineering component only needs to be licensed. Information on a license-free test mode can be found under Licensing [} 13]. Twin CAT Package Manager: Installation (Twin CAT 3.1 Build 4026) Detailed instructions on installing products can be found in the chapter Installing workloads in the Twin CAT 3.1 Build 4026 installation instructions. Install the following workload to be able to use the product: • Twin CAT. Standard. XAE Twin CAT setup: Installation (Twin CAT 3.1 Build 4024 and earlier) Install the following setup in order to be able to use the product: • Twin CAT 3.1 e Xtended Automation Engineering (XAE) (full installation) Detailed installation instructions can be found in the Installation Twin CAT 3.1 Build 4024 chapter. 3.1 Functionality: Light vs. full If you do not have an Engineering license for TE1200 you can use the license-free version of Static Analysis (Static Analysis Light), which has some restrictions (see table below). The free Light version enables you to familiarize yourself with the basic handling of the product, for example, based on a heavily reduced set of functions. Static Analysis Light vs. Static Analysis Full An overview of the different features of the license-free and license-managed variants of Static Analysis is provided below. TE1200 Version: 2.9.0 11

## Page 12

Installation Functional aspect Static Analysis Light Static Analysis Full (without TE1200 license) (with TE1200 license) License required No, usable free of charge Yes, TE1200 license required Save/export and load/import (rule) Not possible, coupled to PLC Possible configuration project properties (using the Load/Save buttons in the Settings [} 14]) Execution is coupled to the Yes, not configurable Configurable compilation process (using the Perform static analysis automatically option in the Settings [} 14]; Manual execution with the help of the command Command 'Run static analysis' [} 111]) Checking for unused objects (e.g. Not possible Possible within a library project) (with the help of the command Command 'Run static analysis [Check all objects]' [} 113]) Maximum number of reported 500 (not configurable) Configurable errors (Further information on the (using the setting Maximum significance of 500 as the number of errors in the Settings maximum number of errors can be [} 14]) found in the Settings [} 14]) Maximum number of reported Output of warnings not possible Configurable warnings (see following line) (using the setting Maximum number of warnings in the Settings [} 14]) Rules: Activation options [} 16] • Active and output as error • Active and output as error • Inactive • Active and output as warning • Inactive Rules: scope [} 17] 7 coding rules More than 100 coding rules • SA0033: Unused variables • SA0028: Overlapping memory areas • SA0006: Write access to multiple tasks • SA0004: Multiple writes access on output • SA0027: Multiple usage of name • SA0167: Report temporary Function Block instances • SA0175: Suspicious operation on string Rules: Precompile wavy underline, Not available Available Quick Fix [} 130] Naming conventions [} 81] Not available Available Metrics [} 94] Not available Available Forbidden symbols [} 110] Not available Available 12 Version: 2.9.0 TE1200

## Page 13

Installation Pragmas and attributes [} 121] for Yes, available in the Light scope: Yes, available in full scope: temporary deactivation of rules • Pragma {analysis ...} • Pragma {analysis ...} • Attribute {attribute 'no-analysis'} • Attribute {attribute 'no-analysis'} • Attribute {attribute 'analysis' := • Attribute {attribute 'analysis' := '...'} '...'} • Attribute {attribute 'naming' := '...'} • Attribute {attribute 'nameprefix' := '...'} • Attribute {attribute 'analysis:report-multiple- instance-calls'} 3.2 System Requirements Engineering (XAE) Technical data Requirements Operating system • Windows 10 • Windows 11 Target platform • x86 • x64 Twin CAT version Twin CAT 3.1 Build 4022 or higher Required Twin CAT license TE1200 Engineering license 3.3 Licensing For information on licensing the TE1200 engineering component, please read the documentation on Licensing. Close XAE before (de)activating the TE1200 license Before activating or deactivating the TE1200 license via Twin CAT restart, please close all open development environments. Test mode Please note that there is no 7-day trial license available for this product. If you do not have an Engineering license for TE1200 you can use the license-free version of Static Analysis (Static Analysis Light), which has some restrictions (see below). The free Light version enables you to familiarize yourself with the basic handling of the product, for example, based on a heavily reduced set of functions. See also: Functionality: Light vs. full [} 11] TE1200 Version: 2.9.0 13

## Page 14

Configuration 4 Configuration After the installation [} 11] and licensing of "TE1200 | Twin CAT 3 PLC Static Analysis", the category Static Analysis in the properties of the PLC project is extended by the additional rules and configuration options. In the project properties you will then find tabs for the basic configuration and for configuring the rules, conventions, metrics and forbidden symbols, which have to be taken into account in the code analysis. The properties of a PLC project can be opened via the context menu of PLC project object or via the Project menu, if the focus is on a PLC project in the project tree. The current settings or modifications are saved when you save the PLC project properties. The Save button, which can be found in the Settings tab, can be used to save the current Static Analysis configuration additionally in an external file. Such a configuration file can be loaded into the development environment via the Load button. The following pages contain further information on the individual tabs of the Static Analysis project properties category. • Settings [} 14] • Rules [} 16] • Naming conventions [} 81] • Naming conventions (2) [} 90] • Metrics [} 94] • Forbidden symbols [} 110] Scope of the "Static Analysis" configuration The parameters you set in the category Static Analysis of the PLC project properties are referred to as Solution options and therefore affect not only the PLC project whose properties you currently edit. The configured settings, rules, naming conventions, metrics and forbidden symbols are applied to all PLC projects in the development environment. 4.1 Settings The Settings tab can be used to configure whether the static code analysis is automatically performed when the code is generated. The current configuration of the Static Analysis can be saved in an external file, or a configuration can be loaded from an external file. 14 Version: 2.9.0 TE1200

## Page 15

Configuration Perform Static Analysis If this option is enabled, Twin CAT performs the Static Analysis whenever automatically after compilation code is generated without error (e.g. when the command Build Project is executed). The analysis can be started manually via the command Command 'Run static analysis' [} 111], irrespective of the configuration of this option. Load This button opens the standard dialog for a locating of a file. Select the required configuration file *.csa for the Static Analysis, which may previously have been created via Save (see below). Since the Static Analysis properties are "solution options", the project properties for the Static Analysis, as described in the csa file, are applied to all PLC projects in the development environment. Save This button is used to save the current project properties for the Static Analysis in an xml file. The standard dialog for saving a file appears, and the file type is preset to "Static analysis files" (*.csa). Such a file can later be applied to the project via the Load button (see above). Please note that the setting of the error limit "Maximum number of errors" is not saved in this file. Maximum number of errors Preset: 500 In this box you can enter the desired error limit, which is checked during the execution of the Static Analysis. If either the error limit or the warning limit (see below) is reached, execution of the Static Analysis is canceled and the previous analysis result is output. Performance vs. completeness: Please note: The more objects are checked by the Static Analysis, the longer the execution of the Static Analysis takes. And the more errors are entered in the output window, the longer the results output of the Static Analysis takes. In the assumed case that there are more than 500 Static Analysis errors in a PLC project, the following use cases arise. • Use of a small error limit (e.g. 500): You wish to gradually process the output errors by correcting the respective program code and executing the Static Analysis again to check the correction. In this case it wouldn't be necessary to check all the objects at once and to display all the errors at once. Instead, it is usually sufficient in this case to display a subset as the Static Analysis result, wherein the Static Analysis is executed with a good performance. • Use of a large error limit (e.g. 5000): You wish to output a total report from the Static Analysis in order to be able to roughly estimate the total work required for the correction of the program code. You can attain this goal by increasing the error limit. Please note that, depending on the project situation, the execution of the Static Analysis takes (much) longer the higher the error limit is set. Detailed explanation of the behavior: If there are more than 500 Static Analysis errors in a project, then configuring the error limit to 500 does not mean that the Static Analysis outputs exactly 500 errors. In fact, the following happens during the execution of the Static Analysis: Before checking a further POU, a check is performed to see whether the Static Analysis errors found so far already exceed the configured limit. If this is the case, the execution of the Static Analysis is aborted and the analysis result so far is output. If on the other hand the limit has not been reached, this POU is checked by the Static Analysis and the errors found in this POU are added to the analysis result. If this newly formed error total (e.g. 530) exceeds the configured error limit, the execution of the Static Analysis is aborted before the checking of the next POU and the errors found so far (e.g. 530) are output. TE1200 Version: 2.9.0 15

## Page 16

Configuration Maximum number of warnings Preset: 500 In this field, you can enter the desired warning limit, which is checked during the execution of Static Analysis. If either the error limit (see above) or the warning limit is reached, execution of the Static Analysis is canceled and the previous analysis result is output. Further information on the use cases can be found in the description of the "Maximum number of errors" option (see above). 4.2 Rules In the Rules tab you can configure the rules that are taken into account when the static analysis is performed [} 111]. The rules are displayed as a tree structure in the project properties. Some rules are arranged below organizational nodes. The rules alert the user to possibly inadvertent and erroneous implementations so that these parts of the programme can be optimized at an early stage. Default settings All rules are enabled by default, with the exception of SA0016, SA0024, SA0073, SA0101, SA0105-SA0107, SA0111-SA0125, SA0133, SA0134, SA0145, SA0147, SA0148, SA0150, SA0162-SA0167 and the "strict" IEC rules. Configuring the rules Individual rules can be enabled or disabled via the checkbox for the respective row. Ticking the checkbox for a subnode affects all entries below this node. Ticking the checkbox for the top node affects all list entries. The entries below a node can be collapsed or expanded by clicking on the minus or plus sign to the left of the node name. The number in brackets after each rule, for example "Unreachable code (1)", is the rule number that is issued if the rule is not observed. The following three settings are available, which can be accessed by repeated clicking on the checkbox: • : The rule is not checked. • : A rule violation results in an error being reported in the message window. 16 Version: 2.9.0 TE1200

## Page 17

Configuration • : A rule violation results in a warning being reported in the message window. Syntax of rule violations in the message window Each rule has a unique number (shown in parentheses after the rule in the rule configuration view). If a rule violation is detected during the static analysis, the number together with an error or warning description is issued in the message window, based on the following syntax. The abbreviation "SA" stands for "Static Analysis". Syntax: "SA<rule number>: <rule description>" Sample for rule number 33 (unused variables): "SA0033: Not used: variable 'b Sample'" Temporary disabling of rules Rules that are enabled in this dialog can be temporarily disabled in the project via a pragma. For further information please refer to Pragmas and attributes [} 121]. Overview and description of the rules An overview of the rules and a detailed description of the rules can be found at Rules - overview and description [} 17]. 4.2.1 Rules - overview and description Check strict IEC rules The checks under the node "Check strict IEC rules" determine functionalities and data types that are allowed in Twin CAT, in extension of IEC61131-3. Checking concurrent/competing access The following rules exist on this topic: SA0006: Write access from multiple tasks [} 24] Determines variables that are written to by more than one task. SA0103: Concurrent access on not atomic data [} 59] Determines non-atomic variables (for example with data types STRING, WSTRING, ARRAY, STRUCT, FB instances, 64-bit data types) that are used in more than one task. Please note that only direct access can be recognized. Indirect access operations, for example via pointer/reference, are not listed. Please also refer to the documentation on the subject "Multi-task data access synchronization in the PLC", which contains several notes on the necessity and options for data access synchronization. Parameterizable rules Parameterizability Please note that some rules can be parameterized and, for example, limits can be set individually. You can configure the parameters to be taken into account in the respective check by double- clicking on the row of the corresponding rule in the rule configuration (PLC project properties > "Static Analysis" category > "Rules" tab). You can set the control parameters in the dialog that opens. The following rules can be parameterized: • SA0100: Variables greater than <n> bytes [} 57] • SA0101: Names with invalid length [} 57] TE1200 Version: 2.9.0 17

## Page 18

Configuration • SA0166: Maximum number of input/output/VAR_IN_OUT variables [} 75] • SA0178: Cognitive complexity [} 80] • SA0179: Coupling between objects [} 80] Overview - SA0001: Unreachable code [} 22] - SA0002: Empty objects [} 22] - SA0003: Empty statements [} 22] - SA0004: Multiple writes access on output [} 23] - SA0006: Write access from several tasks [} 24] - SA0007: Address operators on constants [} 24] - SA0008: Check subrange types [} 25] - SA0009: Unused return values [} 25] - SA0010: Arrays with only one component [} 26] - SA0011: Useless declarations with only one component [} 26] - SA0012: Variables which could be declared as constants [} 26] - SA0013: Declarations with the same variable name [} 27] - SA0014: Assignments of instances [} 27] - SA0015: Access to global data via FB_init [} 28] - SA0016: Gaps in structures [} 28] - SA0017: Non-regular assignments to pointer variables [} 29] - SA0018: Unusual bit access [} 29] - SA0020: Possibly assignment of truncated value to REAL variable [} 30] - SA0021: Transporting the address of a temporary variable [} 30] - SA0022: (Possibly) non-rejected return values [} 31] - SA0023: Complex return values [} 31] - SA0024: Untyped literals [} 31] - SA0025: Unqualified enumeration constants [} 32] - SA0026: Possible truncated strings [} 32] - SA0027: Multiple usage of name [} 33] - SA0028: Overlapping memory areas [} 33] - SA0029: Notation in code different to declaration [} 34] - List unused objects - SA0031: Unused signatures [} 34] 18 Version: 2.9.0 TE1200

## Page 19

Configuration - SA0032: Unused enumeration constants [} 34] - SA0033: Unused variables [} 35] - SA0035: Unused input variables [} 35] - SA0036: Unused output variables [} 35] - SA0034: Enumeration variables with incorrect assignment [} 36] - SA0037: Write access to input variable [} 36] - SA0038: Read access to output variable [} 37] - SA0040: Possible division by zero [} 37] - SA0041: Possibly loop-invariant code [} 37] - SA0042: Usage of different access paths [} 38] - SA0043: Use of a global variable in only one POU [} 39] - SA0044: Declarations with reference to interface [} 39] - Conversions - SA0019: Implicit pointer conversions [} 40] - SA0130: Implicit expanding conversions [} 40] - SA0133: Explicit narrowing conversions [} 41] - SA0134: Explicit signed/unsigned conversions [} 41] - Usage of direct addresses - SA0005: Invalid addresses and data types [} 42] - SA0047: Access to direct addresses [} 42] - SA0048: AT declarations on direct addresses [} 43] - Rules for operators - SA0051: Comparison operators on BOOL variables [} 43] - SA0052: Unusual shift operation [} 43] - SA0053: Too big bitwise shift [} 44] - SA0054: Comparisons of REAL/LREAL for equality/inequality [} 44] - SA0055: Unnecessary comparison operations of unsigned operands [} 45] - SA0056: Constant out of valid range [} 45] - SA0057: Possible loss of decimal points [} 46] - SA0058: Operations of enumeration variables [} 46] - SA0059: Comparison operations always returning TRUE or FALSE [} 47] - SA0060: Zero used as invalid operand [} 48] - SA0061: Unusual operation on pointer [} 48] - SA0062: Expression is constant [} 49] TE1200 Version: 2.9.0 19

## Page 20

Configuration - SA0063: Possibly not 16-bit-compatible operations [} 49] - SA0064: Addition of pointer [} 49] - SA0065: Incorrect pointer addition to base size [} 50] - SA0066: Use of temporary results [} 51] - Rules for statements - FOR statements - SA0072: Invalid uses of counter variable [} 52] - SA0073: Use of non-temporary counter variable [} 52] - SA0081: Upper border is not a constant [} 52] - CASE statements - SA0075: Missing ELSE [} 53] - SA0076: Missing enumeration constant [} 54] - SA0077: Type mismatches with CASE expression [} 54] - SA0078: Missing CASE branches [} 55] - SA0090: Return statement before end of function [} 55] - SA0095: Assignments in conditions [} 56] - SA0100: Variables greater than <n> bytes [} 57] - SA0101: Names with invalid length [} 57] - SA0102: Access to program/fb variables from the outside [} 58] - SA0103: Concurrent access on not atomic data [} 59] - SA0105: Multiple instance calls [} 60] - SA0106: Virtual method calls in FB_init [} 60] - SA0107: Missing formal parameters [} 62] - Check strict IEC rules - SA0111: Pointer variables [} 62] - SA0112: Reference variables [} 62] - SA0113: Variables with data type WSTRING [} 62] - SA0114: Variables with data type LTIME [} 63] - SA0115: Declarations with data type UNION [} 63] - SA0117: Variables with data type BIT [} 63] - SA0119: Object-oriented features [} 64] - SA0120: Program calls [} 64] - SA0121: Missing VAR_EXTERNAL declarations [} 65] - SA0122: Array index defined as expression [} 65] 20 Version: 2.9.0 TE1200

## Page 21

Configuration - SA0123: Usages of INI, ADR or BITADR [} 66] - SA0147: Unusual shift operation - strict [} 66] - SA0148: Unusual bit access - strict [} 66] - Rules for initializations - SA0118: Initializations not using constants [} 67] - SA0124: Dereference access in initializations [} 67] - SA0125: References in initializations [} 68] - SA0140: Statements commented out [} 71] - Possible use of uninitialized variables - SA0039: Possible null pointer dereferences [} 69] - SA0046: Possible use of not initialized interface [} 70] - SA0145: Possible use of not initialized reference [} 70] - SA0150: Violations of lower or upper limits of the metrics [} 71] - SA0160: Recursive calls [} 72] - SA0161: Unpacked structure in packed structure [} 73] - SA0162: Missing comments [} 74] - SA0163: Nested comments [} 74] - SA0164: Multi-line comments [} 75] - SA0166: Maximum number of input/output/VAR_IN_OUT variables [} 75] - SA0167: Report temporary Function Block instances [} 76] - SA0168: Unnecessary assignments [} 77] - SA0169: Ignored outputs [} 77] - SA0170: Address of an output variable should not be used [} 77] - SA0171: Enumerations should have the 'strict' attribute [} 78] - SA0172: Possible attempt to access outside the array limits [} 79] - SA0175: Suspicious operation on string [} 79] - Metrics - SA0178: Cognitive complexity [} 80] - SA0179: Coupling between objects [} 80] - SA0180: Index range does not cover the entire array [} 80] Detailed description TE1200 Version: 2.9.0 21

## Page 22

Configuration SA0001: Unreachable code Function Determines code that is not executed, for example due to a RETURN or CONTINUE statement. Reason Unreachable code should be avoided in any case. The check often indicates the presence of test code, which should be removed. Importance High PLCopen rule CP2 Sample 1 – RETURN: PROGRAM MAIN VAR b Return Before End : BOOL; END_VAR b Return Before End := FALSE; RETURN; b Return Before End := TRUE; // => SA0001 Sample 2 – CONTINUE: FUNCTION F_Continue In Loop : BOOL VAR n Counter : INT; END_VAR F_Continue In Loop := FALSE; FOR n Counter := INT#0 TO INT#5 BY INT#1 DO CONTINUE; F_Continue In Loop := FALSE; // => SA0001 END_FOR SA0002: Empty objects Function Determines POUs, GVLs or data type declarations that do not contain code. Reason Empty objects should be avoided. They are often a sign that an object is not fully implemented. Exception: In some cases, the body of a function block will not assigned code if it is only to be used via interfaces. In other cases, a method is only created because it is required by an interface, without scope for meaningful implementation of the method. In any case, a comment should be included in such a situation. Importance Medium SA0003: Empty statements Function Determines lines of code containing a semicolon (;) but no statement. Reason An empty statement can be an indication of missing code. Exception Although there are meaningful uses for empty statements. For example, it may be useful to explicitly program all cases in a CASE statement, including cases in which no action is required. If such an empty CASE statement is commented, the statistical code analysis does not generate an error message. Importance Low Samples: ; // => SA0003 (* comment *); // => SA0003 n Var; // => SA0003 The following sample generates the error "SA0003: Empty statement" for State 2. 22 Version: 2.9.0 TE1200

## Page 23

Configuration CASE n Var OF 1: Do Something(); 2: ; 3: Do Something Else(); END_CASE The following sample does not generate an SA0003 error. CASE n Var OF 1: Do Something(); 2: ; // nothing to do 3: Do Something Else(); END_CASE SA0004: Multiple write access on output Function Determines outputs that are written at more than one position. Reason The maintainability suffers if an output is written in various places in the code. It is then unclear which write access is actually affecting the process. It is good practice to perform the calculation of the output variables in auxiliary variables and to assign the calculated value to a point at the end of the cycle. Exception No error is issued if an output variable is written in different branches of IF or CASE statements. Importance High PLCopen rule CP12 This rule cannot be disabled via a pragma or attribute! For more information on attributes, see Pragmas and attributes [} 121]. Sample: Global variable list: VAR_GLOBAL b Var AT%QX0.0 : BOOL; n Sample AT%QW5 : INT; END_VAR MAIN program: PROGRAM MAIN VAR n Condition : INT; END_VAR IF n Condition < INT#0 THEN b Var := TRUE; // => SA0004 n Sample := INT#12; // => SA0004 END_IF CASE n Condition OF INT#1: b Var := FALSE; // => SA0004 INT#2: n Sample := INT#11; // => SA0004 ELSE b Var := TRUE; // => SA0004 n Sample := INT#9; // => SA0004 END_CASE TE1200 Version: 2.9.0 23

## Page 24

Configuration SA0006: Write access from several tasks Function Determines variables with write access from more than one task. Reason A variable that is written in several tasks may change its value unexpectedly under certain circumstances. This can lead to confusing situations. String variables and, on some 32-bit systems, 64-bit integer variables also may even assume an inconsistent state if the variable is written in two tasks at the same time. Exception In certain cases it may be necessary for several tasks to write a variable. Make sure, for example through the use of semaphores, that the access does not lead to an inconsistent state. Importance High PLCopen rule CP10 See also rule SA0103 [} 59]. Call corresponds to write access Please note that calls are interpreted as write access. For example, calling a method for a function block instance is regarded as a write access to the function block instance. A more detailed analysis of accesses and calls is not possible, e.g. due to virtual calls (pointers, interface). To deactivate rule SA0006 for a variable (e.g. for a function block instance), the following attribute can be inserted above the variable declaration: {attribute 'analysis' := '-6'} Examples: The two global variables n Var and b Var are written by two tasks. Global variable list: VAR_GLOBAL n Var : INT; b Var : BOOL; END_VAR Program MAIN_Fast, called from the task Plc Task Fast: n Var := n Var + 1; // => SA0006 b Var := (n Var > 10); // => SA0006 Program MAIN_Slow, called from the task Plc Task Slow: n Var := n Var + 2; // => SA0006 b Var := (n Var < -50); // => SA0006 SA0007: Address operators on constants Function Determines locations at which the ADR operator is used for a constant. Reason A pointer to a constant variable cancels the CONSTANT property of the variable. The variable can be changed via the pointer without the compiler reporting this. Exception In rare cases, it may make sense for pointer to a constant to be passed to a function. If this option is used, measures must be implemented to ensure that the function does not change the value that was passed to it. In this case, use VAR_IN_OUT CONSTANT if possible. Importance High If the option Replace constants is enabled in the compiler options of the PLC project properties, the address operator for scalar constants (Integer, BOOL, REAL) is not allowed and a compilation error is issued. (Constant strings, structures and arrays always have an address.) Sample: 24 Version: 2.9.0 TE1200

## Page 25

Configuration PROGRAM MAIN VAR CONSTANT c Value : INT := INT#15; END_VAR VAR p Value : POINTER TO INT; END_VAR p Value := ADR(c Value); // => SA0007 SA0008: Check subrange types Function Determines range exceedances of subrange types. Assigned literals are checked at an early stage by the compiler. If constants are assigned, the values must be within the defined range. If variables are assigned, the data types must be identical. Reason If subrange types are used, make sure that the function remains within the respective subrange. The compiler checks such subrange violations only for assignments of constants. Importance Low The check is not performed for CFC objects, because the code structure does not allow this. Sample: PROGRAM MAIN VAR n Sub1 : INT (INT#1.. INT#10); n Sub2 : INT (INT#1.. INT#1000); n Var : INT; END_VAR n Sub1 := n Sub2; // => SA0008 n Sub1 := n Var; // => SA0008 SA0009: Unused return values Function Determines function, method and property calls for which the return value is not used. Reason If a function or method returns a return value, the value should be evaluated. In many cases the return value contains information to indicate whether the function was executed successfully. If no evaluation is performed, it is subsequently not possible to determine whether the return value was overlooked or whether it is in fact not required. Exception If a return value is of no interest during a call, this should be documented and the assignment can be omitted. Error returns should never be ignored! Importance Medium PLCopen rule CP7/CP17 Sample: Function F_Return BOOL: FUNCTION F_Return BOOL : BOOL F_Return BOOL := TRUE; MAIN program: PROGRAM MAIN VAR b Var : BOOL; END_VAR F_Return BOOL(); // => SA0009 b Var := F_Return BOOL(); TE1200 Version: 2.9.0 25

## Page 26

Configuration SA0010: Arrays with only one component Function Determines arrays containing only a single component. Reason An array with a component can be replaced by a Base Type variable. Access to such a variable is much faster than access to a variable via an index. Exception The length of an array is often determined by a constant and used as a parameter for a program. The program can then work with arrays of different lengths and does not have to be changed if the length is only 1. Such a situation should be documented accordingly. Importance Low Samples: PROGRAM MAIN VAR a Empty1 : ARRAY [0..0] OF INT; // => SA0010 a Empty2 : ARRAY [15..15] OF REAL; // => SA0010 END_VAR SA0011: Useless declarations with only one component Function Determines structures, unions, or enumerations with only one component. Reason No structures, unions or enumerations with only one component should be declared. Such declarations can be confusing for readers. A structure with only one element can be replaced by an alias type. An enumeration with an element can be replaced by a constant. Importance Low PLCopen rule CP22/CP24 Sample 1 – Structure: TYPE ST_Single Struct : // => SA0011 STRUCT n Part : INT; END_STRUCT END_TYPE Sample 2 – Union: TYPE U_Single Union : // => SA0011 UNION f Var : LREAL; END_UNION END_TYPE Sample 3 – Enumeration: TYPE E_Single Enum : // => SA0011 ( e Only One := 1 ); END_TYPE SA0012: Variables which could be declared as constants Function Determines variables that are not subject to write access and therefore could not be declared as constants. Reason If a variable is only written at the declaration point and is otherwise only used in read mode, the static analysis assumes that the variable is to remain unchanged. Declaration as a constant means that the variable is checked for changes in the event of program modifications. Plus, declaration as a constant may lead to faster code. Importance Low Sample: 26 Version: 2.9.0 TE1200

## Page 27

Configuration PROGRAM MAIN VAR n Sample : INT := INT#17; n Var : INT; END_VAR n Var := n Var + n Sample; // => SA0012 SA0013: Declarations with the same variable name Function Determines variables with the same name as other variables (example: global and local variables with the same name), or the same name as functions, actions, methods or properties within the same access range. Reason Identical names can be confusing when the code is read and can lead to errors if the wrong object is accessed accidentally. We therefore recommend using naming conventions that avoid such situations. Importance Medium PLCopen rule N5/N9 Samples: Global variable list GVL_App: VAR_GLOBAL n Var : INT; END_VAR MAIN program, containing a method with the name Sample: PROGRAM MAIN VAR b Var : BOOL; n Var : INT; // => SA0013 Sample : DWORD; // => SA0013 END_VAR .n Var := 100; // Writing global variable "n Var" n Var := 500; // Writing local variable "n Var" METHOD Sample VAR_INPUT … SA0014: Assignments of instances Function Determines assignments to function block instances. For instances with pointer or reference variables such assignments may be risky. Reason This is a performance warning. When an instance is assigned to another instance, all elements and subelements are copied from one instance to the other. Pointers to data are also copied, but not their referenced data, so that the target instance and the source instance contain the same data after the assignment. Depending on the size of the instances, such an assignment may take a long time. If, for example, an instance is to be passed to a function for processing, it is much better to pass a pointer to the instance. A copy method can be useful for selectively copying values from one instance to another: fb2. Copy From(fb1) Importance Medium Sample: PROGRAM MAIN VAR fb1 : FB_Sample; fb2 : FB_Sample; END_VAR fb1(); fb2 := fb1; // => SA0014 TE1200 Version: 2.9.0 27

## Page 28

Configuration SA0015: Access to global data via FB_init Function Determines access of a function block to global data via the FB_init method. The value of this variables depends on the order of the initializations! Reason Depending on the declaration location of the instance of a function block, a non-initialized variable may be accessed if the rule is violated. Importance High Sample: Global variable list GVL_App: VAR_GLOBAL n Var : INT; END_VAR Function block FB_Sample: FUNCTION_BLOCK FB_Sample VAR n Local : INT; END_VAR Method FB_Sample. FB_init: METHOD FB_init : BOOL VAR_INPUT b Init Retains : BOOL; // if TRUE, the retain variables are initialized (warm start / cold start) b In Copy Code : BOOL; // if TRUE, the instance afterwards gets moved into the copy code (online change) END_VAR n Local := 2*n Var; // => SA0015 Program MAIN: PROGRAM MAIN VAR fb Sample : FB_Sample; END_VAR SA0016: Gaps in structures Function Determines gaps in structures or function blocks, caused by the alignment requirements of the currently selected target system. If possible, you should remove gaps by rearranging the structure elements or by filling them with dummy elements. If this is not possible, you can disable the rule for the affected structures using the attribute {attribute 'analysis' := '...'} [} 123]. Reason Due to different alignment requirements on different platforms, such structures may have a different layout in the memory. The code may behave differently, depending on the platform. Importance Low Samples: TYPE ST_Unpadded Structure1 : STRUCT b BOOL : BOOL; n INT : INT; // => SA0016 n BYTE : BYTE; n WORD : WORD; END_STRUCT END_TYPE TYPE ST_Unpadded Structure2 : STRUCT b BOOL : WORD; n INT : INT; 28 Version: 2.9.0 TE1200

## Page 29

Configuration n BYTE : BYTE; n WORD : WORD; // => SA0016 END_STRUCT END_TYPE SA0017: Non-regular assignments to pointer variables Function Determines assignments to pointers, which are not an address (ADR operator, pointer variables) or constant 0. Reason If a pointer is assigned a value that is not a valid address, dereferencing the pointer leads to an “Access Violation Exception”. Importance High Sample: PROGRAM MAIN VAR n Var : INT; p Int : POINTER TO INT; n Address : XWORD; END_VAR n Address := n Address + 1; p Int := ADR(n Var); // no error p Int := 0; // no error p Int := n Address; // => SA0017 SA0018: Unusual bit access Function Determines bit access to signed variables. However, the IEC 61131-3 standard only permits bit access to bit fields. See also strict rule SA0148 [} 66]. Reason Signed data types should not be used as bit fields and vice versa. The IEC 61131-3 standard does not provide for such access. This rule must be observed if the code is to be portable. Exception Exception for flag enumerations: If an enumeration is declared as flag via the pragma attribute {attribute 'flags'}, the error SA0018 is not issued for bit access with OR, AND or NOT operations. Importance Medium Samples: PROGRAM MAIN VAR n INT : INT; n DINT : DINT; n ULINT : ULINT; n SINT : SINT; n USINT : USINT; n BYTE : BYTE; END_VAR n INT.3 := TRUE; // => SA0018 n DINT.4 := TRUE; // => SA0018 n ULINT.18 := FALSE; // no error because this is an unsigned data type n SINT.2 := FALSE; // => SA0018 n USINT.3 := TRUE; // no error because this is an unsigned data type n BYTE.5 := FALSE; // no error because BYTE is a bit field TE1200 Version: 2.9.0 29

## Page 30

Configuration SA0020: Possibly assignment of truncated value to REAL variable Function Determines operations on integer variables, during which a truncated value may be assigned to a variable of data type REAL. Reason The static code analysis returns an error when the result of an integer calculation is assigned to a REAL or LREAL variable. The programmer should be made aware of a possibly incorrect interpretation of such an assignment: f LEAL := n DINT1 * n DINT2. Since the value range of LREAL is greater than that of DINT, it could be assumed that the result of the calculation is always displayed in LREAL. But this is not the case. The processor calculates the result of the multiplication as an integer and then casts the result to LREAL. An overflow in the integer calculation would be lost. To avoid this problem, the calculation should be performed as a REAL operation: f LREAL := TO_LREAL(n DINT1) * TO_LREAL(n DINT2) Importance High Sample: PROGRAM MAIN VAR n Var1 : DWORD; n Var2 : DWORD; f Var : REAL; END_VAR n Var1 := n Var1 + DWORD#1; n Var2 := n Var2 + DWORD#2; f Var := n Var1 * n Var2; // => SA0020 SA0021: Transporting the address of a temporary variable Function Determines assignments of addresses of temporary variables (variables on the stack) to non-temporary variables. Reason Local variables of a function or method are created on the stack and exist only while the function or method is processed. If a pointer points to such a variable after processing the method or function, then this pointer can be used to access undefined memory or an incorrect variable in another function. This situation must be avoided in any case. Importance High Sample: Method FB_Sample. Sample Method: METHOD Sample Method : XWORD VAR f Var : LREAL; END_VAR Sample Method := ADR(f Var); Program MAIN: PROGRAM MAIN VAR n Return : XWORD; fb Sample : FB_Sample; END_VAR n Return := fb Sample. Sample Method(); // => SA0021 30 Version: 2.9.0 TE1200

## Page 31

Configuration SA0022: (Possibly) unassigned return value Function Determines all functions and methods containing an execution thread without assignment to the return value. Reason An unassigned return value in a function or method indicates missing code. Even if the return value always has a default value, it is useful to explicitly assign it again in any case, in order to avoid ambiguities. Importance Medium Sample: FUNCTION F_Sample : DWORD VAR_INPUT n In : UINT; END_VAR VAR n Temp : INT; END_VAR n In := n In + UINT#1; IF (n In > UINT#10) THEN n Temp := 1; // => SA0022 ELSE F_Sample := DWORD#100; END_IF SA0023: Complex return values Function Determines complex return values that cannot be returned with a simple register copy of the processor. These include structures and arrays as well as return values of the type STRING (irrespective of the size of storage space occupied). Reason This is a performance warning. If large values are returned as a result of a function, method, or property, the processor copies them repeatedly when the code is executed. This can lead to runtime problems and should be avoided if possible. Better performance is achieved if a structured value is passed to a function or method as VAR_IN_OUT and filled in the function or method. Importance Medium Sample: Structure ST_sample: TYPE ST_Sample : STRUCT n1 : INT; n2 : BYTE; END_STRUCT END_TYPE Example of functions with return value: FUNCTION F_My Function1 : I_My Interface // no error FUNCTION F_My Function2 : ST_Sample // => SA0023 FUNCTION F_My Function3 : ARRAY[0..1] OF BOOL // => SA0023 SA0024: Untyped literals Function Determines untyped literals that are part of an operation. Reason Untyped literals are automatically typed depending on their use. In some cases, such as n DWORD := ROL(DWORD#1, i);, this can lead to unexpected situations where it is better to achieve clear clarification by using a typed literal. Importance Low Sample: TE1200 Version: 2.9.0 31

## Page 32

Configuration PROGRAM MAIN VAR n INT : INT := 10; // no error as no part of operation n DINT : DINT; n LINT : LINT; f REAL : REAL; f LREAL : LREAL; END_VAR n INT := n INT + 34; // => SA0024 n INT := n INT + INT#34; // no error n DINT := n DINT + 23; // => SA0024 n DINT := n DINT + DINT#23; // no error n LINT := n LINT + 124; // => SA0024 f REAL := f REAL + 1.1; // => SA0024 f LREAL := f LREAL + 3.4; // => SA0024 SA0025: Unqualified enumeration constants Function Determines enumeration constants that are not used with a qualified name, i.e. without preceding enumeration name. Reason Qualified access makes the code more readable and easier to maintain. Without forcing qualified variable names, an additional enumeration could be inserted when the program is extended. This enumeration contains a constant with the same name as an existing enumeration (see the sample below: "e Red"). In this case there would be an ambiguous access in this piece of code. We recommend using only enumerations that have the {attribute 'qualified-only’}. Importance Medium Sample: Enumeration E_Color: TYPE E_Color : ( e Red, e Green, e Blue ); END_TYPE MAIN program: PROGRAM MAIN VAR e Color : E_Color; END_VAR e Color := E_Color.e Green; // no error e Color := e Green; // => SA0025 SA0026: Possible truncated strings Function Determines string assignments and initializations that do not use an adequate string length. Reason If strings of different lengths are assigned, a string may be truncated. The result is then not the expected one. Importance Medium Samples: PROGRAM MAIN VAR s Var1 : STRING[10]; s Var2 : STRING[6]; s Var3 : STRING[6] := 'abcdefghi'; // => SA0026 END_VAR 32 Version: 2.9.0 TE1200

## Page 33

Configuration s Var2 := s Var1; // => SA0026 SA0027: Multiple usage of name Function Determines multiple use of a variable name/identifier or object name (POU) within the scope of a project. The following cases are covered: • The name of an enumeration constant is identical to the name in another enumeration within the application or in an included library. • The name of a variable is identical to the name of another object in the application or in an included library. • The name of a variable is identical to the name of an enumeration constant in an enumeration in the application or in an included library. • The name of an object is identical to the name of another object in the application or in an included library. Reason Identical names can be confusing when reading the code. They can lead to errors if the wrong object is accessed inadvertently. Therefore, define and follow naming conventions in order to avoid such situations. Exception Enumerations declared with the 'qualified_only' attribute are exempt from SA0027 checking because their elements can only be accessed in a qualified manner. Importance Medium Sample: The following sample generates error/warning SA0027, since the library Tc2_Standard is referenced in the project, which provides the function block TON. PROGRAM MAIN VAR ton : INT; // => SA0027 END_VAR SA0028: Overlapping memory areas Function Determines the points due to which two or more variables occupy the same storage space. Reason If two variables occupy the same storage space, the code may behave very unexpectedly. This must be avoided in all cases. If the use of a value in different interpretations is unavoidable, for example once as DINT and once as REAL, you should define a UNION. Also, via a pointer you can access a value typed otherwise without converting the value. Importance High Sample: In the following sample both variables use byte 21, i.e. the memory areas of the variables overlap. PROGRAM MAIN VAR n Var1 AT%QB21 : INT; // => SA0028 n Var2 AT%QD5 : DWORD; // => SA0028 END_VAR TE1200 Version: 2.9.0 33

## Page 34

Configuration SA0029: Notation in code different to declaration Function Determines the code positions (in the implementation) at which the notation of an identifier differs from the notation in its declaration. Reason The IEC 61131-3 standard defines identifiers as not case-sensitive. This means that a variable declared as "varx" can also be used as "Va Rx" in the code. However, this can be confusing and misleading and should therefore be avoided. Importance Medium Samples: Function F_TEST: FUNCTION F_TEST : BOOL … Program MAIN: PROGRAM MAIN VAR n Var : INT; b Return : BOOL; END_VAR nvar := n Var + 1; // => SA0029 b Return := F_Test(); // => SA0029 SA0031: Unused signatures Function Determines programs, function blocks, functions, data types, interfaces, methods, properties, actions etc., which are not called within the compiled program code. Reason Unused objects result in unnecessary project bloat and confusion when the code is read. Importance low PLCopen rule CP2 SA0032: Unused enumeration constants Function Determines enumeration constants that are not used in the compiled program code. Reason Unused enumeration constants result in unnecessary enumeration definition bloat and confusion when the program is read. Importance Low PLCopen rule CP24 Sample: Enumeration E_Sample: TYPE E_Sample : ( e Null, e One, // => SA0032 e Two ); END_TYPE Program MAIN: PROGRAM MAIN VAR e Sample : E_Sample; END_VAR e Sample := E_Sample.e Null; e Sample := E_Sample.e Two; 34 Version: 2.9.0 TE1200

## Page 35

Configuration SA0033: Unused variables Function Determines variables that are declared but not used within the compiled program code. Reason Unused variables make a program less easy to read and maintain. Unused variables occupy unnecessary memory space and take up unnecessary runtime during the initialization. Importance medium PLCopen rule CP22/CP24 SA0035: Unused input variables Function Determines input variables that are not assigned within the respective function block. Reason Unused variables make a program less easy to read and maintain. Unused variables occupy unnecessary memory space and take up unnecessary runtime during the initialization. Importance Medium PLCopen rule CP24 Sample: Function block FB_Sample: FUNCTION_BLOCK FB_Sample VAR_INPUT b In1 : BOOL; b In2 : BOOL; // => SA0035 END_VAR VAR_OUTPUT b Out1 : BOOL; b Out2 : BOOL; // => SA0036 END_VAR b Out1 := b In1; SA0036: Unused output variables Function Determines output variables that are not assigned within the respective function block. Reason Unused variables make a program less easy to read and maintain. Unused variables occupy unnecessary memory space and take up unnecessary runtime during the initialization. Importance Medium PLCopen rule CP24 Sample: Function block FB_Sample: FUNCTION_BLOCK FB_Sample VAR_INPUT b In1 : BOOL; b In2 : BOOL; // => SA0035 END_VAR VAR_OUTPUT b Out1 : BOOL; b Out2 : BOOL; // => SA0036 END_VAR b Out1 := b In1; TE1200 Version: 2.9.0 35

## Page 36

Configuration SA0034: Enumeration variables with incorrect assignment Function Determines values that are assigned to an enumeration variable. Only defined enumeration constants may be assigned to an enumeration variable. Reason An enumeration type variable should only have the intended values, otherwise code that uses that variable may not work correctly. We recommend using only enumerations that have the {attribute 'strict'}. In this case the compiler checks the correct use of the enumeration components. Importance High Sample: Enumeration E_Color: TYPE E_Color : ( e Red := 1, e Blue := 2, e Green := 3 ); END_TYPE Program MAIN: PROGRAM MAIN VAR e Color : E_Color; END_VAR e Color := E_Color.e Red; e Color := e Blue; e Color := 1; // => SA0034 SA0037: Write access to input variable Function Determines input variables (VAR_INPUT) that are subject to write access within the POU. Reason According to the IEC 61131-3 standard, an input variable may not be changed within a function block. Such access is also an error source and makes the code more difficult to maintain. It indicates that a variable is used as an input and simultaneously as an auxiliary variable. Such dual use should be avoided. Importance Medium Sample: Function block FB_Sample: FUNCTION_BLOCK FB_Sample VAR_INPUT b In : BOOL := TRUE; n In : INT := 100; END_VAR VAR_OUTPUT b Out : BOOL; END_VAR Method FB_Sample. Sample Method: IF b In THEN n In := 500; // => SA0037 b Out := TRUE; END_IF 36 Version: 2.9.0 TE1200

## Page 37

Configuration SA0038: Read access to output variable Function Determines output variables (VAR_OUTPUT) that are subject to read access within the POU. Reason The IEC-61131-3 standard prohibits reading an output within a function block. It indicates that the output is not only used as an output but also as a temporary variable for intermediate results. Such dual use should be avoided. Importance Low Sample: Function block FB_Sample: FUNCTION_BLOCK FB_Sample VAR_OUTPUT b Out : BOOL; n Out : INT; END_VAR VAR b Local : BOOL; n Local : INT; END_VAR Method FB_Sample. Sample Method: IF b Out THEN // => SA0038 b Local := (n Out > 100); // => SA0038 n Local := n Out; // => SA0038 n Local := 2*n Out; // => SA0038 END_IF SA0040: Possible division by zero Function Determines code positions at which division by zero may occur. Reason Division by 0 is not allowed. A variable that is used as a divisor should always be checked for 0 first. Otherwise, a "Divide by Zero" exception may occur at runtime. Importance High Sample: PROGRAM MAIN VAR CONSTANT c Sample : INT := 100; END_VAR VAR n Quotient1 : INT; n Dividend1 : INT; n Divisor1 : INT; n Quotient2 : INT; n Dividend2 : INT; n Divisor2 : INT; END_VAR n Divisor1 := c Sample; n Quotient1 := n Dividend1/n Divisor1; // no error n Quotient2 := n Dividend2/n Divisor2; // => SA0040 SA0041: Possibly loop-invariant code Function Determines assignments in (FOR, WHILE, REPEAT) loops that calculate the same value for each loop pass. Such lines of code could be inserted outside the loop. Reason This is a performance warning. Code that is executed in a loop, but does the same thing in every loop pass, can be executed outside the loop. Importance Medium TE1200 Version: 2.9.0 37

## Page 38

Configuration Sample: In the following sample SA0041 is output as error/warning, since the variables n Test1 and n Test2 are not used in the loop. PROGRAM MAIN VAR CONSTANT c Max : INT := 3; END_VAR VAR n Test1 : INT := 5; n Test2 : INT := n Test1; n Test3 : INT; n Test4 : INT; n Test5 : INT; n Test6 : INT; n Index : INT; n Counter : INT; END_VAR FOR n Counter := 1 TO 100 DO n Test3 := n Test1 + n Test2; // => SA0041 n Test4 := n Test3 + n Counter; // no loop-invariant code, because n Test3 and n Counter are used within loop n Test6 := n Test5; // simple assignments are not regarded END_FOR FOR n Index := 1 TO c Max-1 DO // => SA0041 for "c Max-1" n Counter := n Counter + 1; END_FOR SA0042: Usage of different access paths Function Determines the usage of different access paths for the same variable. Reason Different access to the same element reduces the readability and maintainability of a program. We recommend consistent use of {attribute 'qualified-only'} for libraries, global variable lists and enumerations. This forces fully qualified access. Importance Low Samples: In the following sample SA0042 is output as error/warning, because the global variable n Global is accessed directly and via the GVL namespace, and because the function CONCAT is accessed directly and via the library namespace. Global variables: VAR_GLOBAL n Global : INT; END_VAR Program MAIN: PROGRAM MAIN VAR s Var : STRING; END_VAR n Global := INT#2; // => SA0042 GVL.n Global := INT#3; // => SA0042 s Var := CONCAT('ab', 'cd'); // => SA0042 s Var := Tc2_Standard. CONCAT('ab', 'cd'); // => SA0042 38 Version: 2.9.0 TE1200

## Page 39

Configuration SA0043: Use of a global variable in only one POU Function Determines global variables that are only used in one POU. Reason A global variable that is only used at one point should also be declared at this point. Importance Medium PLCopen rule CP26 Sample: The global variable n Global1 is only used in the MAIN program. Global variables: VAR_GLOBAL n Global1 : INT; // => SA0043 n Global2 : INT; END_VAR Program Sub Program: n Global2 := 123; MAIN program: Sub Program(); n Global1 := n Global2; SA0044: Declarations with reference to interface Function Determines declarations with REFERENCE TO <interface> and declarations of VAR_IN_OUT variables with the type of an interface (realized implicitly via REFERENCE TO). Reason An interface type is always implicitly a reference to an instance of a function block that implements this interface. A reference to an interface is therefore a reference to a reference and can lead to unwanted behavior. Importance High Samples: I_Sample is an interface defined in the project. Function block FB_Sample: FUNCTION_BLOCK FB_Sample VAR_INPUT i Input : I_Sample; END_VAR VAR_OUTPUT i Output : I_Sample; END_VAR VAR_IN_OUT i In Out1 : I_Sample; // => SA0044 {attribute 'analysis' := '-44'} i In Out2 : I_Sample; // no error SA0044 because rule is deactivated via attribute END_VAR Program MAIN: PROGRAM MAIN VAR fb Sample : FB_Sample; i Sample : I_Sample; ref Itf : REFERENCE TO I_Sample; // => SA0044 END_VAR TE1200 Version: 2.9.0 39

## Page 40

Configuration SA0019: Implicit pointer conversions Function Determines implicitly generated pointer data type conversions. Reason Pointers are not strictly typed in Twin CAT and can be assigned to each other as required. This is a commonly used option and therefore not reported by the compiler. However, it can also unintentionally lead to unexpected access. If a POINTER TO BYTE is assigned to a POINTER TO DWORD, it is possible that the last pointer will unintentionally overwrite memory. Therefore, always check this rule and suppress the message only in cases where you deliberately want to access a value with a different type. Implicit data type conversions are reported with a different message. Exception BOOL ↔ BIT Importance High PLCopen rule CP25 Samples: PROGRAM MAIN VAR n Int : INT; n Byte : BYTE; p Int : POINTER TO INT; p Byte : POINTER TO BYTE; END_VAR p Int := ADR(n Int); p Byte := ADR(n Byte); p Int := ADR(n Byte); // => SA0019 p Byte := ADR(n Int); // => SA0019 p Int := p Byte; // => SA0019 p Byte := p Int; // => SA0019 SA0130: Implicit expanding conversions Function Determines code positions where conversions from smaller to larger data types are implicitly carried out during arithmetic operations. Reason The compiler allows any assignment of different types if the range of the source type is fully within the range of the target type. However, the compiler will build a conversion into the code as late as possible. For an assignment of the following type: n LINT := n DINT * n DINT; the compiler performs the implicit conversion only after the multiplication: n LINT := TO_LINT(n DINT * n DINT); An overflow is therefore truncated. If you want to prevent this, you can have the conversion performed earlier for the elements: n LINT := TO_LINT(n DINT) * TO_LINT(n DINT); Therefore, it may be useful to report points where the compiler implements implicit conversions in order to check whether these are exactly what is intended. In addition, explicit conversions can serve to improve portability to other systems if they have more restrictive type checks. Exception BOOL ↔ BIT Importance Low Samples: PROGRAM MAIN VAR n DINT : DINT; n LINT : LINT; n USINT : USINT; n UINT : UINT; 40 Version: 2.9.0 TE1200

## Page 41

Configuration n UDINT : UDINT; n ULINT : ULINT; n LWORD : LWORD; f LREAL : LREAL; n BYTE : BYTE; END_VAR n DINT := UINT_TO_DINT(n UINT) * UINT_TO_DINT(n UINT); // no error n DINT := n UINT * n UINT; // => SA0130 n LINT := n DINT * n DINT; // => SA0130 n ULINT := n USINT * n USINT; // => SA0130 n LWORD := n UDINT * n UDINT; // => SA0130 f LREAL := n BYTE * n BYTE; // => SA0130 SA0133: Explicit narrowing conversions Function Determines explicitly performed conversions from a larger to a smaller data type. Reason A large number of type conversions can mean that incorrect data types have been selected for variables. There are therefore programming guidelines that require an explicit justification for data type conversions. Importance Low Samples: PROGRAM MAIN VAR n SINT : SINT; n DINT : DINT; n LINT : LINT; n BYTE : BYTE; n UINT : UINT; n DWORD : DWORD; n LWORD : LWORD; f REAL : REAL; f LREAL : LREAL; END_VAR n SINT := LINT_TO_SINT(n LINT); // => SA0133 n BYTE := DINT_TO_BYTE(n DINT); // => SA0133 n SINT := DWORD_TO_SINT(n DWORD); // => SA0133 n UINT := LREAL_TO_UINT(f LREAL); // => SA0133 f REAL := LWORD_TO_REAL(n LWORD); // => SA0133 SA0134: Explicit signed/unsigned conversions Function Determines explicitly performed conversions from signed to unsigned data types or vice versa. Reason Excessive use of type conversions may mean that incorrect data types have been selected for variables. There are therefore programming guidelines that require an explicit justification for data type conversions. Importance Low Samples: PROGRAM MAIN VAR n BYTE : BYTE; n UDINT : UDINT; n ULINT : ULINT; n WORD : WORD; n LWORD : LWORD; n SINT : SINT; n INT : INT; n DINT : DINT; n LINT : LINT; END_VAR TE1200 Version: 2.9.0 41

## Page 42

Configuration n LINT := ULINT_TO_LINT(n ULINT); // => SA0134 n UDINT := DINT_TO_UDINT(n DINT); // => SA0134 n SINT := BYTE_TO_SINT(n BYTE); // => SA0134 n WORD := INT_TO_WORD(n INT); // => SA0134 n LWORD := SINT_TO_LWORD(n SINT); // => SA0134 SA0005: Invalid addresses and data types Function Determines invalid address and data type specifications. The following size prefixes are valid for addresses. Deviations from this lead to an invalid address specification. • X for BOOL • B for 1-byte data types • W for 2-byte data types • D for 4-byte data types Reason Variables that lie on direct addresses should, if possible, be associated with an address that corresponds to their data type width. It can be confusing for the reader of the code if, for example, a DWORD is placed on a BYTE address. Importance Low If the recommended placeholders %I* or %Q* are used, Twin CAT automatically performs flexible and optimized addressing. Samples: PROGRAM MAIN VAR n OK AT%QW0 : INT; b OK AT%QX5.0 : BOOL; n NOK AT%QD10 : INT; // => SA0005 b NOK AT%QB15 : BOOL; // => SA0005 END_VAR SA0047: Access to direct addresses Function Determines direct address access operations in the implementation code. Reason Symbolic programming is always preferred: A variable has a name that can also have a meaning. An address does not provide an indication of what it is used for. Importance High PLCopen rule N1/CP1 Samples: PROGRAM MAIN VAR b BOOL : BOOL; n BYTE : BYTE; n WORD : WORD; n DWORD : DWORD; END_VAR b BOOL := %IX0.0; // => SA0047 %QX0.0 := b BOOL; // => SA0047 %QW2 := n WORD; // => SA0047 %QD4 := n DWORD; // => SA0047 %MX0.1 := b BOOL; // => SA0047 %MB1 := n BYTE; // => SA0047 %MD4 := n DWORD; // => SA0047 42 Version: 2.9.0 TE1200

## Page 43

Configuration SA0048: AT declarations on direct addresses Function Determines AT declarations on direct addresses. Reason The use of direct addresses in the code is an error source and leads to poorer readability and maintainability of the code. We therefore recommend using the placeholders %I* or %Q*, for which Twin CAT automatically carries out flexible and optimized addressing. Importance High PLCopen rule N1/CP1 Samples: PROGRAMM MAIN VAR b1 AT%IX0.0 : BOOL; // => SA0048 b2 AT%I* : BOOL; // no error END_VAR SA0051: Comparison operations on BOOL variables Function Determines comparison operations on variables of type BOOL. Reason Twin CAT allows such comparisons, but they are rather unusual and can be confusing. The IEC-61131-3 standard does not provide for these comparisons, so you should avoid them. Importance Medium Sample: PROGRAM MAIN VAR b1 : BOOL; b2 : BOOL; b Result : BOOL; END_VAR b Result := (b1 > b2); // => SA0051 b Result := NOT b1 AND b2; b Result := b1 XOR b2; SA0052: Unusual shift operation Function Determines shift operation (bit shift) on signed variables. However, the IEC 61131-3 standard only permits shift operations to bit fields. See also strict rule SA0147 [} 66]. Reason Twin CAT allows shift operations on signed data types. However, such operations are unusual and can be confusing. The IEC-61131-3 standard does not provide for such operations, so you should avoid them. Exception Shift operation on bit array data types (byte, DWORD, LWORD, WORD) do not result in a SA0052 error. Importance Medium Samples: PROGRAM MAIN VAR n INT : INT; n DINT : DINT; n ULINT : ULINT; n SINT : SINT; n USINT : USINT; n LINT : LINT; n DWORD : DWORD; n BYTE : BYTE; END_VAR TE1200 Version: 2.9.0 43

## Page 44

Configuration n INT := SHL(n INT, BYTE#2); // => SA0052 n DINT := SHR(n DINT, BYTE#4); // => SA0052 n ULINT := ROL(n ULINT, BYTE#1); // no error because this is an unsigned data type n SINT := ROL(n SINT, BYTE#2); // => SA0052 n USINT := ROR(n USINT, BYTE#3); // no error because this is an unsigned data type n LINT := ROR(n LINT, BYTE#2); // => SA0052 n DWORD := SHL(n DWORD, BYTE#3); // no error because DWORD is a bit field data type n BYTE := SHR(n BYTE, BYTE#1); // no error because BYTE is a bit field data type SA0053: Too big bitwise shift Function Determines whether the data type width was exceeded in bitwise shift of operands. Reason If a shift operation exceeds the data type width, a constant 0 is generated. If a rotation shift exceeds the data type width, it is difficult to read and the rotation value should therefore be shortened. Importance High Samples: PROGRAM MAIN VAR n BYTE : BYTE; n WORD : WORD; n DWORD : DWORD; n LWORD : LWORD; END_VAR n BYTE := SHR(n BYTE, BYTE#8); // => SA0053 n WORD := SHL(n WORD, BYTE#45); // => SA0053 n DWORD := ROR(n DWORD, BYTE#78); // => SA0053 n LWORD := ROL(n LWORD, BYTE#111); // => SA0053 n BYTE := SHR(n BYTE, BYTE#7); // no error n WORD := SHL(n WORD, BYTE#15); // no error SA0054: Comparisons of REAL/LREAL for equality/inequality Function Determines where the comparison operators = (equality) and <> (inequality) compare operands of type REAL or LREAL. Reason REAL/LREAL values are implemented as floating point numbers in accordance with the IEEE 754 standard. This standard implies that certain seemingly simple decimal numbers cannot be represented exactly. As a result, the same decimal number may have different LREAL representations. Sample: f LREAL_11 := 1.1; f LREAL_33 := 3.3; f LREAL_a := f LREAL_11 + f LREAL_11; f LREAL_b := f LREAL_33 – f LREAL_11; b Test := f LREAL_a = f LREAL_b; b Test will return FALSE in this case, even if the variables f LREAL_a and f LREAL_b both return the monitoring value "2.2". This is not a compiler error, but a property of the floating point units of all common processors. You can avoid this by specifying a minimum value by which the values may differ: b Test := ABS(f LREAL_a – f LREAL_b) < 0.1; Exception A comparison with 0.0 is not reported by this analysis. For 0 there is an exact representation in the IEEE 754 standard and therefore the comparison normally works as expected. For better performance, it therefore makes sense to allow a direct comparison here. Importance High PLCopen rule CP54 44 Version: 2.9.0 TE1200

## Page 45

Configuration Samples: PROGRAM MAIN VAR f REAL1 : REAL; f REAL2 : REAL; f LREAL1 : LREAL; f LREAL2 : LREAL; b Result : BOOL; END_VAR b Result := (f REAL1 = f REAL1); // => SA0054 b Result := (f REAL1 = f REAL2); // => SA0054 b Result := (f REAL1 <> f REAL2); // => SA0054 b Result := (f LREAL1 = f LREAL1); // => SA0054 b Result := (f LREAL1 = f LREAL2); // => SA0054 b Result := (f LREAL2 <> f LREAL2); // => SA0054 b Result := (f REAL1 > f REAL2); // no error b Result := (f LREAL1 < f LREAL2); // no error SA0055: Unnecessary comparison operations of unsigned operands Function Determines unnecessary comparisons with unsigned operands. An unsigned data type is never less than zero. Reason A comparison revealed by this check provides a constant result and indicates an error in the code. Importance High Samples: PROGRAM MAIN VAR n BYTE : BYTE; n WORD : WORD; n DWORD : DWORD; n LWORD : LWORD; n USINT : USINT; n UINT : UINT; n UDINT : UDINT; n ULINT : ULINT; n SINT : SINT; n INT : INT; n DINT : DINT; n LINT : LINT; b Result : BOOL; END_VAR b Result := (n BYTE >= BYTE#0); // => SA0055 b Result := (n WORD < WORD#0); // => SA0055 b Result := (n DWORD >= DWORD#0); // => SA0055 b Result := (n LWORD < LWORD#0); // => SA0055 b Result := (n USINT >= USINT#0); // => SA0055 b Result := (n UINT < UINT#0); // => SA0055 b Result := (n UDINT >= UDINT#0); // => SA0055 b Result := (n ULINT < ULINT#0); // => SA0055 b Result := (n SINT < SINT#0); // no error b Result := (n INT < INT#0); // no error b Result := (n DINT < DINT#0); // no error b Result := (n LINT < LINT#0); // no error SA0056: Constant out of valid range Function Determines literals (constants) outside the valid operator range. Reason The message is output in cases where a variable is compared with a constant that lies outside the value range of this variable. The comparison then returns a constant TRUE or FALSE. This indicates a programming error. Importance High TE1200 Version: 2.9.0 45

## Page 46

Configuration Samples: PROGRAM MAIN VAR n BYTE : BYTE; n WORD : WORD; n DWORD : DWORD; n USINT : USINT; n UINT : UINT; n UDINT : UDINT; b Result : BOOL; END_VAR b Result := n BYTE >= 355; // => SA0056 b Result := n WORD > UDINT#70000; // => SA0056 b Result := n DWORD >= ULINT#4294967300; // => SA0056 b Result := n USINT > UINT#355; // => SA0056 b Result := n UINT >= UDINT#70000; // => SA0056 b Result := n UDINT > ULINT#4294967300; // => SA0056 SA0057: Possible loss of decimal points Function Determines statements with possible loss of decimal points. Reason A piece of code of the following type: n DINT := 1; f REAL := TO_REAL(n DINT / DINT#2); can lead to misinterpretation. This line of code can lead to the assumption that the division would be performed as a REAL operation and the result in this case would be REAL#0.5. However, this is not the case, i.e. the operation is performed as an integer operation, the result is cast to REAL, and f REAL is assigned the value REAL#0. To avoid this, you should use a cast to ensure that the operation is performed as a REAL operation: f REAL := TO_REAL(n DINT) / REAL#2; Importance Medium Samples: PROGRAM MAIN VAR f REAL : REAL; n DINT : DINT; n LINT : LINT; END_VAR n DINT := n DINT + DINT#11; f REAL := DINT_TO_REAL(n DINT / DINT#3); // => SA0057 f REAL := DINT_TO_REAL(n DINT) / 3.0; // no error f REAL := DINT_TO_REAL(n DINT) / REAL#3.0; // no error n LINT := n LINT + LINT#13; f REAL := LINT_TO_REAL(n LINT / LINT#7); // => SA0057 f REAL := LINT_TO_REAL(n LINT) / 7.0; // no error f REAL := LINT_TO_REAL(n LINT) / REAL#7.0; // no error SA0058: Operations of enumeration variables Function Determines operations on variables of type enumeration. Assignments are permitted. Reason Enumerations should not be used as normal integer values. Alternatively, an alias data type can be defined or a subrange type can be used. Exception If an enumeration is marked with the attribute {attribute 'strict'}, the compiler reports such an operation. If an enumeration is declared as a flag via the pragma attribute {attribute 'flags'}, no SA0058 error is issued for operations with AND, OR, NOT, XOR. Importance Medium 46 Version: 2.9.0 TE1200

## Page 47

Configuration Sample 1: Enumeration E_Color: TYPE E_Color : ( e Red := 1, e Blue := 2, e Green := 3 ); END_TYPE MAIN program: PROGRAM MAIN VAR n Var : INT; e Color : E_Color; END_VAR e Color := E_Color.e Green; // no error e Color := E_Color.e Green + 1; // => SA0058 n Var := E_Color.e Blue / 2; // => SA0058 n Var := E_Color.e Green + E_Color.e Red; // => SA0058 Sample 2: Enumeration E_State with attribute 'flags': {attribute 'flags'} TYPE E_State : ( e Unknown := 16#00000001, e Stopped := 16#00000002, e Running := 16#00000004 ) DWORD; END_TYPE MAIN program: PROGRAM MAIN VAR n Flags : DWORD; n State : DWORD; END_VAR IF (n Flags AND E_State.e Unknown) <> DWORD#0 THEN // no error n State := n State AND E_State.e Unknown; // no error ELSIF (n Flags OR E_State.e Stopped) <> DWORD#0 THEN // no error n State := n State OR E_State.e Running; // no error END_IF SA0059: Comparison operations always returning TRUE or FALSE Function Determines comparisons with literals whose result is always TRUE or FALSE and which can already be evaluated during compilation. Reason An operation that consistently returns TRUE or FALSE is an indication of a programming error. Importance High Samples: PROGRAM MAIN VAR n BYTE : BYTE; n WORD : WORD; n DWORD : DWORD; n LWORD : LWORD; n USINT : USINT; n UINT : UINT; n UDINT : UDINT; n ULINT : ULINT; n SINT : SINT; n INT : INT; n DINT : DINT; TE1200 Version: 2.9.0 47

## Page 48

Configuration n LINT : LINT; b Result : BOOL; END_VAR b Result := n BYTE <= 255; // => SA0059 b Result := n BYTE <= BYTE#255; // => SA0059 b Result := n WORD <= WORD#65535; // => SA0059 b Result := n DWORD <= DWORD#4294967295; // => SA0059 b Result := n LWORD <= LWORD#18446744073709551615; // => SA0059 b Result := n USINT <= USINT#255; // => SA0059 b Result := n UINT <= UINT#65535; // => SA0059 b Result := n UDINT <= UDINT#4294967295; // => SA0059 b Result := n ULINT <= ULINT#18446744073709551615; // => SA0059 b Result := n SINT >= -128; // => SA0059 b Result := n SINT >= SINT#-128; // => SA0059 b Result := n INT >= INT#-32768; // => SA0059 b Result := n DINT >= DINT#-2147483648; // => SA0059 b Result := n LINT >= LINT#-9223372036854775808; // => SA0059 SA0060: Zero used as invalid operand Function Determines operations in which an operand with value 0 results in an invalid or meaningless operation. Reason Such an expression may indicate a programming error. In any case, it causes unnecessary runtime. Importance Medium Samples: PROGRAM MAIN VAR n BYTE : BYTE; n WORD : WORD; n DWORD : DWORD; n LWORD : LWORD; END_VAR n BYTE := n BYTE + 0; // => SA0060 n WORD := n WORD - WORD#0; // => SA0060 n DWORD := n DWORD * DWORD#0; // => SA0060 n LWORD := n LWORD / 0; // Compile error: Division by zero SA0061: Unusual operation on pointer Function Determines operations on variables of type POINTER TO, which are not = (equality), <> (inequality), + (addition) or ADR. Reason Pointer arithmetic is generally permitted in Twin CAT and can be used in a meaningful way. The addition of a pointer with an integer value is therefore classified as a common operation on pointers. This makes it possible to process an array of variable length using a pointer. All other (unusual) operations with pointers are reported with SA0061. Importance High PLCopen rule E2/E3 Samples: PROGRAM MAIN VAR p INT : POINTER TO INT; n Var : INT; END_VAR p INT := ADR(n Var); // no error p INT := p INT * DWORD#5; // => SA0061 p INT := p INT / DWORD#2; // => SA0061 p INT := p INT MOD DWORD#3; // => SA0061 p INT := p INT + DWORD#1; // no error p INT := p INT - DWORD#1; // => SA0061 48 Version: 2.9.0 TE1200

## Page 49

Configuration SA0062: Expression is constant Function Determines constant expressions that always return TRUE or FALSE, regardless of the values of any variables used. Reason Such an expression is obviously unnecessary and may indicate an error. In any case, the expression unnecessarily affects the readability and possibly also the runtime. Importance Medium Samples: PROGRAM MAIN VAR b Var1 : BOOL; b Var2 : BOOL; n Var : INT; END_VAR IF MAX(n Var,1) >= 1 THEN // => SA0062 ; END_IF b Var1 := b Var1 AND NOT TRUE; // => SA0062 b Var2 := b Var1 OR TRUE; // => SA0062 b Var2 := b Var1 OR NOT FALSE; // => SA0062 b Var2 := b Var1 AND FALSE; // => SA0062 IF (b Var1 = FALSE) THEN // => SA0062 ; END_IF IF NOT b Var1 THEN // => no error ; END_IF n Var := 0; IF n Var <> 0 THEN // => SA0062 ; END_IF SA0063: Possibly not 16-bit-compatible operations Function Determines 16-bit operations with intermediate results. Background: On 16-bit systems, 32-bit temporary results can be truncated. Reason This message is intended to protect against problems in the very rare case when code is written that is intended to run on both a 16-bit processor and a 32-bit processor. Importance Low Sample: (n Var+10) can exceed 16 bits. PROGRAM MAIN VAR n Var : INT; END_VAR n Var := (n Var + 10) / 2; // => SA0063 SA0064: Addition of pointer Function Determines all pointer additions. Reason In Twin CAT, pointer arithmetic is generally permitted and can be used sensibly. However, this also represents a source of error. Therefore, there are programming rules that prohibit pointer arithmetic. Such a requirement can be verified with this test. Importance Medium Samples: TE1200 Version: 2.9.0 49

## Page 50

Configuration PROGRAM MAIN VAR a Test : ARRAY[0..10] OF INT; p INT : POINTER TO INT; n Idx : INT; END_VAR p INT := ADR(a Test[0]); p INT^ := 0; p INT := ADR(a Test) + SIZEOF(INT); // => SA0064 p INT^ := 1; p INT := ADR(a Test) + 6; // => SA0064 p INT := ADR(a Test[10]); FOR n Idx := 0 TO 10 DO p INT^ := n Idx; p INT := p INT + 2; // => SA0064 END_FOR SA0065: Incorrect pointer addition to base size Function Determines pointer additions in which the value to be added does not match the basic data size of the pointer. Only literals of the base data size and multiples thereof can be added without error. Reason In Twin CAT (in contrast to C and C++), when a pointer with an integer value is added, only this integer value is added as the number of bytes, not the integer value multiplied by the base size. p INT := ADR(array_of_int[0]); p INT := p INT + 2 ; // in Twin CAT zeigt p INT anschließend auf array_of_int[1] This code would work differently in C: short* p Short p Short = &(array_of_short[0]) p Short = p Short + 2; // in C zeigt p Short anschließend auf array_of_short[2] In Twin CAT, a multiple of the basic size of the pointer should therefore always be added to a pointer. Otherwise, the pointer may point to a not aligned memory, which (depending on the processor) can lead to an alignment exception on access. Importance High Samples: PROGRAM MAIN VAR p UDINT : POINTER TO UDINT; n Var : UDINT; p REAL : POINTER TO REAL; f Var : REAL; END_VAR p UDINT := ADR(n Var) + 4; p UDINT := ADR(n Var) + (2 + 2); p UDINT := ADR(n Var) + SIZEOF(UDINT); p UDINT := ADR(n Var) + 3; // => SA0065 p UDINT := ADR(n Var) + 2*SIZEOF(UDINT); // => SA0065 p UDINT := ADR(n Var) + (3 + 2); // => SA0065 p REAL := ADR(f Var); p REAL := p REAL + 4; p REAL := p REAL + (2 + 2); p REAL := p REAL + SIZEOF(REAL); p REAL := p REAL + 1; // => SA0065 p REAL := p REAL + 2; // => SA0065 p REAL := p REAL + 3; // => SA0065 p REAL := p REAL + (SIZEOF(REAL) - 1); // => SA0065 p REAL := p REAL + (1 + 4); // => SA0065 50 Version: 2.9.0 TE1200

## Page 51

Configuration SA0066: Use of temporary results Function Determines applications of intermediate results in statements with a data type that is smaller than the register size. In this case, the implicit cast may lead to undesirable results. Reason For performance reasons, Twin CAT carries out operations across the register width of the processor. Intermediate results are not truncated. This can lead to misinterpretations, as in the following case: usint Test := 0; b Error := usint Test - 1 <> 255; In Twin CAT, b Error is TRUE in this case, because the operation usint Test - 1 is typically executed as a 32-bit operation and the result is not cast to the size of bytes. In the register the value 16#ffffffff is then displayed and this is not equal to 255. To avoid this, you have to explicitly cast the intermediate result: b Error := TO_USINT(usint Test - 1) <> 255; Importance Low If this message is enabled, a large number of rather unproblematic situations in the code will be reported. Although a problem can only arise if the operation produces an overflow or underflow in the data type, the Static Analysis cannot differentiate between the individual situations. If you include an explicit typecast in all reported situations, the code will be much slower and less readable! Sample: PROGRAM MAIN VAR n BYTE : BYTE; n DINT : DINT; n LINT : LINT; b Result : BOOL; END_VAR // ==================================================================================================== = // type size smaller than register size // use of temporary result + implicit casting => SA0066 b Result := ((n BYTE - 1) <> 255); // => SA0066 // correcting this code by explicit cast so that the type size is equal to or bigger than register size b Result := ((BYTE_TO_LINT(n BYTE) - 1) <> 255); // no error b Result := ((BYTE_TO_LINT(n BYTE) - LINT#1) <> LINT#255); // no error // ==================================================================================================== = // result depends on solution platform b Result := ((n DINT - 1) <> 255); // no error on x86 solution platform // => SA0066 on x64 solution platform // correcting this code by explicit cast so that the type size is equal to or bigger than register size b Result := ((DINT_TO_LINT(n DINT) - LINT#1) <> LINT#255); // no error // ==================================================================================================== = // type size equal to or bigger than register size // use of temporary result and no implicit casting => no error b Result := ((n LINT - 1) <> 255); // no error // ==================================================================================================== TE1200 Version: 2.9.0 51

## Page 52

Configuration SA0072: Invalid uses of counter variable Function Determines write access operations to a counter variable within a FOR loop. Reason Manipulating the counter variable in a FOR loop can easily lead to an infinite loop. To prevent the execution of the loop for certain values of the counter variables, use CONTINUE or simply IF. Importance High PLCopen rule L12 Sample: PROGRAM MAIN VAR_TEMP n Index : INT; END_VAR VAR a Sample : ARRAY[1..10] OF INT; n Local : INT; END_VAR FOR n Index := 1 TO 10 BY 1 DO a Sample[n Index] := n Index; // no error n Local := n Index; // no error n Index := n Index - 1; // => SA0072 n Index := n Index + 1; // => SA0072 n Index := n Local; // => SA0072 END_FOR SA0073: Use of non-temporary counter variable Function Determines the use of non-temporary variables in FOR loops. Reason This is a performance warning. A counter variable is always initialized each time a programming block is called. You can create such a variable as a temporary variable (VAR_TEMP). This may result in faster access, and the variable does not occupy permanent storage space. Importance Medium PLCopen rule CP21/L13 Sample: PROGRAM MAIN VAR n Index : INT; n Sum : INT; END_VAR FOR n Index := 1 TO 10 BY 1 DO // => SA0073 n Sum := n Sum + n Index; END_FOR SA0081: Upper border is not a constant Function Determines FOR statements in which the upper limit is not defined with a constant value. Reason If the upper limit of a loop is a variable value, it is no longer possible to see how often a loop is executed. This can lead to serious problems at runtime, in the worst case to an infinite loop. Importance High Samples: PROGRAM MAIN VAR CONSTANT c Max : INT := 10; END_VAR VAR n Index : INT; 52 Version: 2.9.0 TE1200

## Page 53

Configuration n Var : INT; n Max1 : INT := 10; n Max2 : INT := 10; END_VAR FOR n Index := 0 TO 10 DO // no error n Var := n Index; END_FOR FOR n Index := 0 TO c Max DO // no error n Var := n Index; END_FOR FOR n Index := 0 TO n Max1 DO // => SA0081 n Var := n Index; END_FOR FOR n Index := 0 TO n Max2 DO // => SA0081 n Var := n Index; IF n Var = 10 THEN n Max2 := 50; END_IF END_FOR SA0075: Missing ELSE Function Determines CASE statements without ELSE branch. Reason Defensive programming requires the presence of an ELSE in every CASE statement. If no action is required in the ELSE case, you should indicate this with a comment. The reader of the code is then aware that the case was not simply overlooked. Exception A missing ELSE branch is not reported as missing if an enumeration declared with the 'strict' attribute is used in the CASE statement, and if all enumeration constants are listed in that CASE statement. Importance Low PLCopen rule L17 Sample: {attribute 'qualified_only'} {attribute 'strict'} {attribute 'to_string'} TYPE E_Sample : ( e Null, e One, e Two ); END_TYPE PROGRAM MAIN VAR e Sample : E_Sample; n Var : INT; END_VAR CASE e Sample OF E_Sample.e Null: n Var := 0; E_Sample.e One: n Var := 1; E_Sample.e Two: n Var := 2; END_CASE CASE e Sample OF // => SA0075 E_Sample.e Null: n Var := 0; E_Sample.e Two: n Var := 2; END_CASE TE1200 Version: 2.9.0 53

## Page 54

Configuration SA0076: Missing enumeration constant Function Determines whether each enumeration constant is used as a condition in CASE statements and queried in a CASE branch. Reason Defensive programming requires the processing of all possible values of an enumeration. If no action is required for a particular enumeration value, you should indicate this explicitly with a comment. This makes it clear that the value was not simply overlooked. Importance Low Sample: In the following sample the enumeration value e Yellow is not treated as a CASE branch. Enumeration E_Color: TYPE E_Color : ( e Red, e Green, e Blue, e Yellow ); END_TYPE MAIN program: PROGRAM MAIN VAR e Color : E_Color; b Var : BOOL; END_VAR e Color := E_Color.e Yellow; CASE e Color OF // => SA0076 E_Color.e Red: b Var := FALSE; E_Color.e Green, E_Color.e Blue: b Var := TRUE; ELSE b Var := NOT b Var; END_CASE SA0077: Type mismatches with CASE expression Function Determines code positions where the data type of a condition does not match that of the CASE branch. Reason If the data types between the CASE variable and the CASE case do not match, this could indicate an error. Importance Low Sample: Enumeration E_Sample: TYPE E_Sample : ( e Null, e One, e Two ) DWORD; END_TYPE Program MAIN: 54 Version: 2.9.0 TE1200

## Page 55

Configuration PROGRAM MAIN VAR n DINT : DINT; b Var : BOOL; END_VAR n DINT := n DINT + DINT#1; CASE n DINT OF DINT#1: b Var := FALSE; E_Sample.e Two, // => SA0077 DINT#3: b Var := TRUE; ELSE b Var := NOT b Var; END_CASE SA0078: Missing CASE branches Function Determines CASE statements without cases, i.e. with only a single ELSE statement. Reason A CASE statement without cases wastes execution time and is difficult to read. Importance Medium Sample: PROGRAM MAIN VAR n Var : DINT; b Var : BOOL; END_VAR n Var := n Var + INT#1; CASE n Var OF // => SA0078 ELSE b Var := NOT b Var; END_CASE SA0090: POUs should have a only one exit point Function Detects code positions where the RETURN statement is not the last statement in a function, method, property or program. It also recognizes places where there is a RETURN within an IF branch. Reason A RETURN in the code leads to poorer maintainability, testability and readability of the code. A RETURN in the code is easily overlooked. You must insert code, which should be executed in any case when a function exits, before each RETURN. This is often overlooked. Importance Medium PLCopen rule CP14 Sample: FUNCTION F_Test Function : DINT VAR_INPUT b Test : BOOL; END_VAR IF b Test THEN RETURN; // => SA0090 END_IF F_Test Function := 99; TE1200 Version: 2.9.0 55

## Page 56

Configuration SA0095: Assignments in conditions Function Determines assignments in conditions of IF, CASE, WHILE or REPEAT constructs. Reason An assignment (:=) and a comparison (=) can easily be confused. An assignment in a condition can therefore easily be unintentional and is therefore reported. This can also confuse readers of the code. Importance High Samples: PROGRAM MAIN VAR b Test : BOOL; b Result : BOOL; b Value : BOOL; b1 : BOOL; n1 : INT; n2 : INT; n Cond1 : INT := INT#1; n Cond2 : INT := INT#2; b Cond : BOOL := FALSE; n Var : INT; e Sample : E_Sample; END_VAR // IF constructs IF (b Test := TRUE) THEN // => SA0095 Do Something(); END_IF IF (b Result := F_Sample(b Input := b Value)) THEN // => SA0095 Do Something(); END_IF b1 := ((n1 := n2) = 99); // => SA0095 IF INT_TO_BOOL(n Cond1 := n Cond2) THEN // => SA0095 Do Something(); ELSIF (n Cond1 := 11) = 11 THEN // => SA0095 Do Something(); END_IF IF b Cond := TRUE THEN // => SA0095 Do Something(); END_IF IF (b Cond := FALSE) OR (n Cond1 := n Cond2) = 12 THEN // => SA0095 Do Something(); END_IF IF (n Var := n Var + 1) = 120 THEN // => SA0095 Do Something(); END_IF // CASE construct CASE (e Sample := E_Sample.e Member0) OF // => SA0095 E_Sample.e Member0: Do Something(); E_Sample.e Member1: Do Something(); END_CASE // WHILE construct WHILE (b Cond = TRUE) OR (n Cond1 := n Cond2) = 12 DO // => SA0095 Do Something(); END_WHILE // REPEAT construct REPEAT Do Something(); UNTIL (b Cond = TRUE) OR ((n Cond1 := n Cond2) = 12) // => SA0095 END_REPEAT 56 Version: 2.9.0 TE1200

## Page 57

Configuration SA0100: Variables greater than <n> bytes Function Determines variables that use more than n bytes; n is defined by the current configuration. You can configure the parameter that is taken into account in the check by double- clicking on the row for rule 100 in the rule configuration (PLC Project Properties > category "Static Analysis" > "Rules" tab > Rule 100). You can make the following settings in the dialog that appears: • Upper limit in bytes (default value: 1024) Reason Some programming guidelines specify a maximum size for a single variable. This function facilitates a corresponding check. Importance Low Sample: In the following sample the variable a Sample is greater than 1024 bytes. PROGRAM MAIN VAR a Sample : ARRAY [0..1024] OF BYTE; // => SA0100 END_VAR SA0101: Names with invalid length Function Determines names with invalid length. The object names must have a defined length. You can configure the parameters that are taken into account in the check by double- clicking on the row for rule 101 in the rule configuration (PLC Project Properties > category "Static Analysis" > "Rules" tab > Rule 101). You can make the following settings in the dialog that appears: • Minimum number of characters (default value: 5) • Maximum number of characters (default value: 30) • Exceptions Reason Some programming guidelines specify a minimum length for variable names. Compliance can be verified with this analysis. Importance Low PLCopen rule N6 Samples: Rule 101 is configured with the following parameters: • Minimum number of characters: 5 • Maximum number of characters: 30 • Exceptions: MAIN, i Program PRG1: PROGRAM PRG1 // => SA0101 VAR END_VAR Program MAIN: PROGRAM MAIN // no error due to configured exceptions VAR i : INT; // no error due to configured exceptions b : BOOL; // => SA0101 n Var1 : INT; END_VAR PRG1(); TE1200 Version: 2.9.0 57

## Page 58

Configuration SA0102: Access to program/fb variables from the outside Function Determines read accesses from outside to local variables of programs or function blocks. Reason Twin CAT determines external write access operations to local variables of programs or function blocks as compilation errors. Since read access operations to local variables are not intercepted by the compiler and this violates the basic principle of data encapsulation (concealing of data) and contravenes the IEC 61131-3 standard, this rule can be used to determine read access to local variables. Importance Medium Samples: Function block FB_Base: FUNCTION_BLOCK FB_Base VAR n Local : INT; END_VAR Method FB_Base. Sample Method: METHOD Sample Method : INT VAR_INPUT END_VAR n Local := n Local + 1; Function block FB_Sub: FUNCTION_BLOCK FB_Sub EXTENDS FB_Base Method FB_Sub. Sample Method: METHOD Sample Method : INT VAR_INPUT END_VAR n Local := n Local + 5; Program PRG_1: PROGRAM PRG_1 VAR b Local : BOOL; END_VAR b Local := NOT b Local; MAIN program: PROGRAM MAIN VAR b Read : BOOL; n Read Base : INT; n Read Sub : INT; fb Base : FB_Base; fb Sub : FB_Sub; END_VAR b Read := PRG_1.b Local; // => SA0102 n Read Base := fb Base.n Local; // => SA0102 n Read Sub := fb Sub.n Local; // => SA0102 58 Version: 2.9.0 TE1200

## Page 59

Configuration SA0103: Concurrent access on not atomic data Function Determines non-atomic variables (for example with data types STRING, WSTRING, ARRAY, STRUCT, FB instances, 64-bit data types) that are used in more than one task. Reason If no synchronization occurs during access, inconsistent values may be read when reading in one task and writing in another task at the same time. Exception This rule does not apply in the following cases: • If the target system has an FPU (floating point unit), the access of several tasks to LREAL variables is not determined and reported. • If the target system is a 64-bit processor or "Twin CAT RT (x64)" is selected as the solution platform, the rule does not apply for 64-bit data types. Importance Medium See also rule SA0006 [} 24]. Samples: Structure ST_sample: TYPE ST_Sample : STRUCT b Member : BOOL; n Test : INT; END_STRUCT END_TYPE Function block FB_Sample: FUNCTION_BLOCK FB_Sample VAR_INPUT f Input : LREAL; END_VAR GVL: {attribute 'qualified_only'} VAR_GLOBAL f Test : LREAL; // => no error SA0103: Since the target system has a FPU, SA0103 does not apply. n Test : LINT; // => error reporting depends on the solution platform: // - SA0103 error if solution platform is set to "Twin CAT RT(x86)" // - no error SA0103 if solution platform is set to "Twin CAT (x64)" s Test : STRING; // => SA0103 ws Test : WSTRING; // => SA0103 a Test : ARRAY[0..2] OF INT; // => SA0103 a Test2 : ARRAY[0..2] OF INT; // => SA0103 fb Test : FB_Sample; // => SA0103 st Test : ST_Sample; // => SA0103 END_VAR Program MAIN1, called by task Plc Task1: PROGRAM MAIN1 VAR END_VAR GVL.f Test := 5.0; GVL.n Test := 123; GVL.s Test := 'sample text'; GVL.ws Test := "sample text"; GVL.a Test := GVL.a Test2; GVL.fb Test.f Input := 3; GVL.st Test.n Test := GVL.st Test.n Test + 1; Program MAIN2, called by task Plc Task2: PROGRAM MAIN2 VAR f Local : LREAL; n Local : LINT; TE1200 Version: 2.9.0 59

## Page 60

Configuration s Local : STRING; ws Local : WSTRING; a Local : ARRAY[0..2] OF INT; a Local2 : ARRAY[0..2] OF INT; f Local2 : LREAL; n Local2 : INT; END_VAR f Local := GVL.f Test + 1.5; n Local := GVL.n Test + 10; s Local := GVL.s Test; ws Local := GVL.ws Test; a Local := GVL.a Test; a Local2 := GVL.a Test2; f Local2 := GVL.fb Test.f Input; n Local2 := GVL.st Test.n Test; SA0105: Multiple instance calls Function Determines and reports instances of function blocks that are called more than once. To ensure that an error message for a repeatedly called function block instance is generated, the attribute {attribute 'analysis:report-multiple-instance-call'} [} 125] must be added in the declaration part of the function block. Reason Some function blocks are designed such that they can only be called once in a cycle. This test checks whether a call is made at several points. Importance Low PLCopen rule CP16/CP20 Sample: In the following sample the Static Analysis will issue an error for fb2, since the instance is called more than once, and the function block is declared with the required attribute. Function block FB_Test1 without attribute: FUNCTION_BLOCK FB_Test1 Function block FB_Test2 with attribute: {attribute 'analysis:report-multiple-instance-calls'} FUNCTION_BLOCK FB_Test2 MAIN program: PROGRAM MAIN VAR fb1 : FB_Test1; fb2 : FB_Test2; END_VAR fb1(); fb1(); fb2(); // => SA0105 fb2(); // => SA0105 SA0106: Virtual method calls in FB_init Function Determines method calls in the method FB_init of a basic function block, which are overwritten by a function block derived from the basic FB. Reason In such cases it may happen that the variables in overwritten methods are not initialized in the base FB. Importance High Sample: • Function block FB_Base has the methods FB_init and My Init. FB_init calls My Init for initialization. • Function block FB_Sub is derived from FB_Base. 60 Version: 2.9.0 TE1200

## Page 61

Configuration • FB_Sub. My Init overwrites or extends FB_Base. My Init. • MAIN instantiates FB_Sub. During this process it uses the instance variable n Sub before it was initialized, due to the call sequence during the initialization. Function block FB_Base: FUNCTION_BLOCK FB_Base VAR n Base : DINT; END_VAR Method FB_Base. FB_init: METHOD FB_init : BOOL VAR_INPUT b Init Retains : BOOL; b In Copy Code : BOOL; END_VAR VAR n Local : DINT; END_VAR n Local := My Init(); // => SA0106 Method FB_Base. My Init: METHOD My Init : DINT n Base := 123; // access to member of FB_Base My Init := n Base; Function block FB_Sub: FUNCTION_BLOCK FB_Sub EXTENDS FB_Base VAR n Sub : DINT; END_VAR Method FB_Sub. My Init: METHOD My Init : DINT n Sub := 456; // access to member of FB_Sub SUPER^. My Init(); // call of base implementation My Init := n Sub; MAIN program: PROGRAM MAIN VAR fb Base : FB_Base; fb Sub : FB_Sub; END_VAR The instance MAIN.fb Base has the following variable values after the initialization: • n Base is 123 The instance MAIN.fb Sub has the following variable values after the initialization: • n Base is 123 • n Sub is 0 The variable MAIN.fb Sub.n Sub is 0 after the initialization, because the following call sequence is used during the initialization of fb Sub: • Initialization of the basic function block: ◦ implicit initialization ◦ explicit initialization: FB_Base. FB_init ◦ FB_Base. FB_init calls FB_Sub. My Init → SA0106 ◦ FB_Sub. My Init calls FB_Base. My Init (via SUPER pointer) • Initialization of the derived function block: ◦ implicit initialization TE1200 Version: 2.9.0 61

## Page 62

Configuration SA0107: Missing formal parameters Function Determines where formal parameters are missing. Reason Code becomes more readable if the formal parameters are specified when it is called. Importance Low Sample: Function F_Sample: FUNCTION F_Sample : BOOL VAR_INPUT b In1 : BOOL; b In2 : BOOL; END_VAR F_Sample := b In1 AND b In2; MAIN program: PROGRAM MAIN VAR b Return : BOOL; END_VAR b Return := F_Sample(TRUE, FALSE); // => SA0107 b Return := F_Sample(TRUE, b In2 := FALSE); // => SA0107 b Return := F_Sample(b In1 := TRUE, b In2 := FALSE); // no error SA0111: Pointer variables Function Determines variables of type POINTER TO. Reason The IEC 61131-3 standard does not allow pointers. Importance Low Sample: PROGRAM MAIN VAR p INT : POINTER TO INT; // => SA0111 END_VAR SA0112: Reference variables Function Determines variables of type REFERENCE TO. Reason The IEC 61131-3 standard does not allow references. Importance Low Sample: PROGRAM MAIN VAR ref Int : REFERENCE TO INT; // => SA0112 END_VAR SA0113: Variables with data type WSTRING Function Determines variables of type WSTRING. Reason Not all systems support WSTRING. The code becomes easier to port if WSTRING is not used. Importance Low 62 Version: 2.9.0 TE1200

## Page 63

Configuration Sample: PROGRAM MAIN VAR ws Var : WSTRING; // => SA0113 END_VAR SA0114: Variables with data type LTIME Function Determines variables of type LTIME. Reason Not all systems support LTIME. The code becomes more portable if LTIME is not used. Importance Low Sample: PROGRAM MAIN VAR t Var : LTIME; // => SA0114 END_VAR // no error SA0114 for the following code line: t Var := t Var + LTIME#1000D15H23M12S34MS2US44NS; SA0115: Declarations with data type UNION Function Determines declarations of a UNION data type and declarations of variables of the type of a UNION. Reason The IEC-61131-3 standard has no provision for unions. The code becomes easier to port if there are no unions. Importance Low Samples: Union U_Sample: TYPE U_Sample : // => SA0115 UNION f Var : LREAL; n Var : LINT; END_UNION END_TYPE MAIN program: PROGRAM MAIN VAR u Sample : U_Sample; // => SA0115 END_VAR SA0117: Variables with data type BIT Function Determines declarations of variables of type BIT (possible within structure and function block definitions). Reason The IEC-61131-3 has no provision for data type BIT. The code becomes easier to port if BIT is not used. Importance Low Samples: Structure ST_sample: TYPE ST_Sample : STRUCT b BIT : BIT; // => SA0117 TE1200 Version: 2.9.0 63

## Page 64

Configuration b BOOL : BOOL; END_STRUCT END_TYPE Function block FB_Sample: FUNCTION_BLOCK FB_Sample VAR b BIT : BIT; // => SA0117 b BOOL : BOOL; END_VAR SA0119: Object-oriented features Function Determines the use of object-oriented features such as: • Function block declarations with EXTENDS or IMPLEMENTS • Property and interface declarations • Use of the THIS or SUPER pointer Reason Not all systems support object-oriented programming. The code becomes easier to port if object orientation is not used. Importance Low Samples: Interface I_Sample: INTERFACE I_Sample // => SA0119 Function block FB_Base: FUNCTION_BLOCK FB_Base IMPLEMENTS I_Sample // => SA0119 Function block FB_Sub: FUNCTION_BLOCK FB_Sub EXTENDS FB_Base // => SA0119 Method FB_Sub. Sample Method: METHOD Sample Method : BOOL // no error Get function of the property FB_Sub. Sample Property: VAR // => SA0119 END_VAR Set function of the property FB_Sub. Sample Property: VAR // => SA0119 END_VAR SA0120: Program calls Function Determines program calls. Reason According to the IEC 61131-3 standard, programs can only be called in the task configuration. The code becomes easier to port if program calls elsewhere are avoided. Importance Low Sample: Program Sub Program: PROGRAM Sub Program Program MAIN: PROGRAM MAIN Sub Program(); // => SA0120 64 Version: 2.9.0 TE1200

## Page 65

Configuration SA0121: Missing VAR_EXTERNAL declarations Function Determines the use of a global variable in the function block, without it being declared as VAR_EXTERNAL (required according to the standard). Reason According to the IEC 61131-3 standard, access to global variables is only permitted via an explicit import through a VAR_EXTERNAL declaration. Importance Low PLCopen rule CP18 In Twin CAT 3 PLC it is not necessary for variables to be declared as external. The keyword exists in order to maintain compatibility with IEC 61131-3. Sample: Global variables: VAR_GLOBAL n Global : INT; END_VAR Program Prog1: PROGRAM Prog1 VAR n Var : INT; END_VAR n Var := n Global; // => SA0121 Program Prog2: PROGRAM Prog2 VAR n Var : INT; END_VAR VAR_EXTERNAL n Global : INT; END_VAR n Var := n Global; // no error SA0122: Array index defined as expression Function Determines the use of expressions in the declaration of array boundaries. Reason Not all systems allow expressions as array boundaries. Importance Low Sample: PROGRAM MAIN VAR CONSTANT c Sample : INT := INT#15; END_VAR VAR a Sample1 : ARRAY[0..10] OF INT; a Sample2 : ARRAY[0..10+5] OF INT; // => SA0122 a Sample3 : ARRAY[0..c Sample] OF INT; a Sample4 : ARRAY[0..c Sample + 1] OF INT; // => SA0122 END_VAR TE1200 Version: 2.9.0 65

## Page 66

Configuration SA0123: Usages of INI, ADR or BITADR Function Determines the use of the (Twin CAT-specific) operators INI, ADR, BITADR. Reason Twin CAT-specific operators prevent portability of the code. Importance Low Sample: PROGRAM MAIN VAR n Var : INT; p INT : POINTER TO INT; END_VAR p INT := ADR(n Var); // => SA0123 SA0147: Unusual shift operation - strict Function Determines bit shift operations that are not performed on bit field data types (BYTE, WORD, DWORD, LWORD). Reason The IEC 61131-3 standard only allows bit access to bit field data types. However, the Twin CAT 3 compiler also allows bit shift operations with unsigned data types. Importance Low See also non-strict rule SA0052 [} 43]. Samples: PROGRAM MAIN VAR n BYTE : BYTE := 16#45; n WORD : WORD := 16#0045; n UINT : UINT; n DINT : DINT; n Res BYTE : BYTE; n Res WORD : WORD; n Res UINT : UINT; n Res DINT : DINT; n Shift : BYTE := 2; END_VAR n Res BYTE := SHL(n Byte,n Shift); // no error because BYTE is a bit field n Res WORD := SHL(n WORD,n Shift); // no error because WORD is a bit field n Res UINT := SHL(n UINT,n Shift); // => SA0147 n Res DINT := SHL(n DINT,n Shift); // => SA0147 SA0148: Unusual bit access - strict Function Determines bit access operations that are not performed on bit field data types (BYTE, WORD, DWORD, LWORD). Reason The IEC 61131-3 standard only allows bit access to bit field data types. However, the Twin CAT 3 compiler also allows bit access to unsigned data types. Importance Low See also non-strict rule SA0018 [} 29]. Samples: PROGRAM MAIN VAR n INT : INT; 66 Version: 2.9.0 TE1200

## Page 67

Configuration n DINT : DINT; n ULINT : ULINT; n SINT : SINT; n USINT : USINT; n BYTE : BYTE; END_VAR n INT.3 := TRUE; // => SA0148 n DINT.4 := TRUE; // => SA0148 n ULINT.18 := FALSE; // => SA0148 n SINT.2 := FALSE; // => SA0148 n USINT.3 := TRUE; // => SA0148 n BYTE.5 := FALSE; // no error because BYTE is a bitfield SA0118: Initializations not using constants Function Determines initializations that do not assign constants. Reason Initializations should be as consistent as possible and should not refer to other variables. In particular, you should avoid function calls during initialization, since this can lead to access to uninitialized data. Importance Medium Samples: Function F_Return DWORD: FUNCTION F_Return DWORD : DWORD Program MAIN: PROGRAM MAIN VAR CONSTANT c1 : DWORD := 100; END_VAR VAR n1 : DWORD := c1; n2 : DWORD := F_Return DWORD(); // => SA0118 n3 : DWORD := 150; n4 : DWORD := n3; // => SA0118 END_VAR SA0124: Dereference access in initializations Function Determines all code positions where dereferenced pointers are used in the declaration part of POUs. Reason Pointers and references should not be used for initialization because this can lead to access violations at runtime if the pointer has not been initialized. Importance Medium Samples: FUNCTION_BLOCK FB_Test VAR_INPUT p Struct : POINTER TO ST_Test; ref Struct : REFERENCE TO ST_Test; END_VAR VAR b Pointer : BOOL := p Struct^.b Test; // => SA0124: Dereference access in initialization b Ref : BOOL := ref Struct.b Test; // => SA0125: Reference used in initialization END_VAR b Pointer := p Struct^.b Test; // => SA0039: Possible null pointer dereference 'p Struct^' b Ref := ref Struct.b Test; // => SA0145: Possible use of not initialized reference 'ref Struct' IF p Struct <> 0 THEN b Pointer := p Struct^.b Test; // no error SA0039 as the pointer is checked for unequal 0 END_IF IF __ISVALIDREF(ref Struct) THEN TE1200 Version: 2.9.0 67

## Page 68

Configuration b Ref := ref Struct.b Test; // no error SA0145 as the reference is checked via __ISVALIDREF END_IF Overview of the rules on "dereferencing". Pointers: • Dereferencing of pointers in the declaration part => SA0124 [} 67] • Possible null pointer dereferences in the implementation part => SA0039 [} 69] References: • Use of references in the declaration part => SA0125 [} 68] • Possible use of not initialized reference in the implementation part => SA0145 [} 70] Interfaces: • Possible use of not initialized interface in the implementation part => SA0046 [} 70] SA0125: References in initializations Function Determines all reference variables used for initialization in the declaration part of POUs. Reason Pointers and references should not be used for initialization because this can lead to access violations at runtime if the pointer has not been initialized. Importance Medium Samples: FUNCTION_BLOCK FB_Test VAR_INPUT p Struct : POINTER TO ST_Test; ref Struct : REFERENCE TO ST_Test; END_VAR VAR b Pointer : BOOL := p Struct^.b Test; // => SA0124: Dereference access in initialization b Ref : BOOL := ref Struct.b Test; // => SA0125: Reference used in initialization END_VAR b Pointer := p Struct^.b Test; // => SA0039: Possible null pointer dereference 'p Struct^' b Ref := ref Struct.b Test; // => SA0145: Possible use of not initialized reference 'ref Struct' IF p Struct <> 0 THEN b Pointer := p Struct^.b Test; // no error SA0039 as the pointer is checked for unequal 0 END_IF IF __ISVALIDREF(ref Struct) THEN b Ref := ref Struct.b Test; // no error SA0145 as the reference is checked via __ISVALIDREF END_IF Overview of the rules on "dereferencing". Pointers: • Dereferencing of pointers in the declaration part => SA0124 [} 67] • Possible null pointer dereferences in the implementation part => SA0039 [} 69] References: • Use of references in the declaration part => SA0125 [} 68] • Possible use of not initialized reference in the implementation part => SA0145 [} 70] Interfaces: • Possible use of not initialized interface in the implementation part => SA0046 [} 70] 68 Version: 2.9.0 TE1200

## Page 69

Configuration SA0039: Possible null pointer dereferences Function Determines code positions at which a NULL-pointer may be dereferenced. Reason A pointer should be checked before each dereferencing to see if it is not equal to 0. Otherwise, access violations may occur at runtime. Importance High Sample 1: PROGRAM MAIN VAR p Int1 : POINTER TO INT; p Int2 : POINTER TO INT; p Int3 : POINTER TO INT; n Var1 : INT; n Counter : INT; END_VAR n Counter := n Counter + INT#1; p Int1 := ADR(n Var1); p Int1^ := n Counter; // no error p Int2^ := n Counter; // => SA0039 n Var1 := p Int3^; // => SA0039 Sample 2: FUNCTION_BLOCK FB_Test VAR_INPUT p Struct : POINTER TO ST_Test; ref Struct : REFERENCE TO ST_Test; END_VAR VAR b Pointer : BOOL := p Struct^.b Test; // => SA0124: Dereference access in initialization b Ref : BOOL := ref Struct.b Test; // => SA0125: Reference used in initialization END_VAR b Pointer := p Struct^.b Test; // => SA0039: Possible null pointer dereference 'p Struct^' b Ref := ref Struct.b Test; // => SA0145: Possible use of not initialized reference 'ref Struct' IF p Struct <> 0 THEN b Pointer := p Struct^.b Test; // no error SA0039 as the pointer is checked for unequal 0 END_IF IF __ISVALIDREF(ref Struct) THEN b Ref := ref Struct.b Test; // no error SA0145 as the reference is checked via __ISVALIDREF END_IF Overview of the rules on "dereferencing". Pointers: • Dereferencing of pointers in the declaration part => SA0124 [} 67] • Possible null pointer dereferences in the implementation part => SA0039 [} 69] References: • Use of references in the declaration part => SA0125 [} 68] • Possible use of not initialized reference in the implementation part => SA0145 [} 70] Interfaces: • Possible use of not initialized interface in the implementation part => SA0046 [} 70] TE1200 Version: 2.9.0 69

## Page 70

Configuration SA0046: Possible use of not initialized interfaces Function Determines the use of interfaces that may not have been initialized before the use. Reason An interface reference should be checked for <> 0 before it is used, otherwise an access violation may occur at runtime. Importance High Samples: Interface I_Sample: INTERFACE I_Sample METHOD Sample Method : BOOL VAR_INPUT n Input : INT; END_VAR Function block FB_Sample: FUNCTION_BLOCK FB_Sample IMPLEMENTS I_Sample METHOD Sample Method : BOOL VAR_INPUT n Input : INT; END_VAR Program MAIN: PROGRAM MAIN VAR fb Sample : FB_Sample; i Sample : I_Sample; i Sample Not Set : I_Sample; n Param : INT; b Return : BOOL; END_VAR i Sample := fb Sample; b Return := i Sample. Sample Method(n Input := n Param); // no error b Return := i Sample Not Set. Sample Method(n Input := n Param); // => SA0046 Overview of the rules on "dereferencing". Pointers: • Dereferencing of pointers in the declaration part => SA0124 [} 67] • Possible null pointer dereferences in the implementation part => SA0039 [} 69] References: • Use of references in the declaration part => SA0125 [} 68] • Possible use of not initialized reference in the implementation part => SA0145 [} 70] Interfaces: • Possible use of not initialized interface in the implementation part => SA0046 [} 70] SA0145: Possible use of not initialized references Function Determines all reference variables that may not be initialized before they are used and were not checked by the __ISVALIDREF operator. This rule is applied in the implementation part of POUs. Reason A reference should be checked for validity before it is accessed, otherwise an access violation may occur at runtime. Importance High Samples: 70 Version: 2.9.0 TE1200

## Page 71

Configuration FUNCTION_BLOCK FB_Test VAR_INPUT p Struct : POINTER TO ST_Test; ref Struct : REFERENCE TO ST_Test; END_VAR VAR b Pointer : BOOL := p Struct^.b Test; // => SA0124: Dereference access in initialization b Ref : BOOL := ref Struct.b Test; // => SA0125: Reference used in initialization END_VAR b Pointer := p Struct^.b Test; // => SA0039: Possible null pointer dereference 'p Struct^' b Ref := ref Struct.b Test; // => SA0145: Possible use of not initialized reference 'ref Struct' IF p Struct <> 0 THEN b Pointer := p Struct^.b Test; // no error SA0039 as the pointer is checked for unequal 0 END_IF IF __ISVALIDREF(ref Struct) THEN b Ref := ref Struct.b Test; // no error SA0145 as the reference is checked via __ISVALIDREF END_IF Overview of the rules on "dereferencing". Pointers: • Dereferencing of pointers in the declaration part => SA0124 [} 67] • Possible null pointer dereferences in the implementation part => SA0039 [} 69] References: • Use of references in the declaration part => SA0125 [} 68] • Possible use of not initialized reference in the implementation part => SA0145 [} 70] Interfaces: • Possible use of not initialized interface in the implementation part => SA0046 [} 70] SA0140: Statements commented out Function Determines statements that are commented out. Reason Code is often commented out for debugging purposes. When such a comment is enabled, it is not clear at a later point in time whether the code should be deleted or whether it was only commented out for debugging purposes and was inadvertently not commented in again. Importance High PLCopen rule C4 Sample: //b Start := TRUE; // => SA0140 SA0150: Violations of lower or upper limits of the metrics Function Determines function blocks that violate the enabled metrics at the lower or upper limit. Reason Code that adheres to certain metrics is easier to read, easier to maintain and easier to test. Importance High PLCopen rule CP9 Sample: The metric "Number of calls" is enabled and configured in the metrics configuration enabled (PLC Project Properties > category "Static Analysis" > "Metrics" tab). TE1200 Version: 2.9.0 71

## Page 72

Configuration • Lower limit: 0 • Upper limit: 3 • Function block Prog1 is called 5 times During the execution of the Static Analysis the violation of SA0150 is issued as an error or warning in the message window. // => SA0150: Metric violation for 'Prog1'. Result for metric 'Calls' (5) > 3" SA0160: Recursive calls Function Determines recursive calls of programs, actions, methods and properties. Determines possible recursions through virtual function calls and interface calls. Reason Recursions lead to non-deterministic behavior and are therefore a source of errors. Importance Medium PLCopen rule CP13 Sample 1: Method FB_Sample. Sample Method1: METHOD Sample Method1 VAR_INPUT END_VAR Sample Method1(); (* => SA0160: Recursive call: 'MAIN -> FB_Sample. Sample Method1 -> FB_Sample. Sample Method1' *) Method FB_Sample. Sample Method2: METHOD Sample Method2 : BOOL VAR_INPUT END_VAR Sample Method2 := THIS^. Sample Method2();(* => SA0160: Recursive call: 'MAIN -> FB_Sample. Sample Method2 -> FB_Sample. Sample Method2' *) Program MAIN: PROGRAM MAIN VAR fb Sample : FB_Sample; b Return : BOOL; END_VAR fb Sample. Sample Method1(); b Return := fb Sample. Sample Method2(); Sample 2: Please note regarding properties: For a property, a local input variable is implicitly created with the name of the property. The following Set function of a property thus assigns the value of the implicit local input variables to the property of an FB variable. Function block FB_Sample: FUNCTION_BLOCK FB_Sample VAR n Parameter : INT; END_VAR Set function of the property Sample Property: n Parameter := Sample Property; 72 Version: 2.9.0 TE1200

## Page 73

Configuration In the following Set function, the implicit input variable of the property is assigned to itself. The assignment of a variable to itself does not constitute a recursion, so that this Set function does not generate an SA0160 error. Set function of the property Sample Property: Sample Property := Sample Property; // no error SA0160 However, access to a property using the THIS pointer is qualified. By using the THIS pointer, the instance and thus the property is accessed, rather than the implicit local input variable. This means that the shading of implicit local input variables and the property itself is lifted. In the following Set function, a new call to the property is generated, which leads to a recursion and thus to error SA0160. Set function of the property Sample Property: THIS^. Sample Property := Sample Property; // => SA0160 SA0161: Unpacked structure in packed structure Function Determines unpacked structures that are used in packed structures. Reason The compiler normally places an unpacked structure on an address that allows aligned access to all elements within the structure. If you create this structure in a packed structure, aligned access is no longer possible, and access to an element in the unpacked structure can lead to a misalignment exception at runtime. Importance High Sample: The structure ST_Single Data Record is packed but contains instances of the unpacked structures ST_4Byte and ST_9Byte. This results in a SA0161 error message. {attribute 'pack_mode' := '1'} TYPE ST_Single Data Record : STRUCT st9Byte : ST_9Byte; // => SA0161 st4Byte : ST_4Byte; // => SA0161 n1 : UDINT; n2 : UDINT; n3 : UDINT; n4 : UDINT; END_STRUCT END_TYPE Structure ST_9Byte: TYPE ST_9Byte : STRUCT n Rotor Slots : USINT; n Max Current : UINT; n Velocity : USINT; n Acceleration : UINT; n Deceleration : UINT; n Direction Change : USINT; END_STRUCT END_TYPE Structure ST_4Byte: TYPE ST_4Byte : STRUCT f Dummy : REAL; END_STRUCT END_TYPE TE1200 Version: 2.9.0 73

## Page 74

Configuration SA0162: Missing comments Function Detects uncommented locations in the program. Comments are required for: • the declaration of variables. The comments are shown above or to the right. • the declaration of POUs, DUTs, GVLs or interfaces. The comments are shown above the declaration (in the first row). Reason Full commentary is required by many programming guidelines. It increases the readability and maintainability of the code. Importance Low PLCopen rule C2 Samples: The following sample generates the error "SA0162: Missing comment for 'b1'" for variable b1. // Comment for MAIN program PROGRAM MAIN VAR b1 : BOOL; // Comment for variable b2 b2 : BOOL; b3 : BOOL; // Comment for variable b3 END_VAR SA0163: Nested comments Function Determines code positions with nested comments. Reason Nested comments are difficult to read and should be avoided. Importance Low PLCopen rule C3 Samples: The four nested comments identified accordingly in the following sample each result in the error: "SA0163: Nested comment '<…>'". (* That is (* nested comment number 1 *) *) PROGRAM MAIN VAR (* That is // nested comment number 2 *) a : DINT; b : DINT; (* That is (* nested comment number 3 *) *) c : BOOL; n Counter : INT; END_VAR (* That is // nested comment number 4 *) n Counter := n Counter + 1; (* This is not a nested comment *) 74 Version: 2.9.0 TE1200

## Page 75

Configuration SA0164: Multi-line comments Function Determines code positions at which the multi-line comment operator (* *) is used. Only the two single-line comment operators are allowed: // for standard comments, /// for documentation comments. Reason Some programming guidelines prohibit multi-line comments in the code, because the beginning and end of a comment could get out of sight and the closing comment bracket could be deleted by mistake. Importance Low PLCopen rule C5 You can disable this check with the pragma {analysis ...} [} 122], including for comments in the declaration part. Samples: (* This comment leads to error: "SA0164 …" *) PROGRAM MAIN VAR /// Documentation comment not reported by SA0164 n Counter1: DINT; n Counter2: DINT; // Standard single-line comment not reported by SA0164 END_VAR (* This comment leads to error: "SA0164 …" *) n Counter1 := n Counter1 + 1; n Counter2 := n Counter2 + 1; SA0166: Maximum number of input/output/VAR_IN_OUT variables Function The check determines whether a defined number of input variables (VAR_INPUT), output variables (VAR_OUTPUT) or VAR_IN_OUT variables is exceeded in a function block. You can configure the parameters that are taken into account in the check by double- clicking on the row for rule 166 in the rule configuration (PLC Project Properties > category "Static Analysis" > "Rules" tab > Rule 166). You can make the following settings in the dialog that appears: • Maximum number of inputs (default value: 10) • Maximum number of outputs (default value: 10) • Maximum number of inputs/outputs (default value: 10) Reason This is about checking individual programming guidelines. Many programming guidelines stipulate a maximum number of parameters for function blocks. Too many parameters make the code unreadable and the function blocks difficult to test. Importance Medium PLCopen rule CP23 Corresponding metrics available The following metrics are available for calculating the input and output variables as part of the metrics table: Number of input variables [} 98] Number of output variables [} 98] Sample: Rule 166 is configured with the following parameters: TE1200 Version: 2.9.0 75

## Page 76

Configuration • Maximum number of inputs: 0 • Maximum number of outputs: 10 • Maximum number of inputs/outputs: 1 The following function block therefore reports two SA0166 errors, since too many inputs (> 0) and too many inputs/outputs (> 1) are declared. Function block FB_Sample: FUNCTION_BLOCK FB_Sample // => SA0166 VAR_INPUT b In : BOOL; END_VAR VAR_OUTPUT b Out : BOOL; END_VAR VAR_IN_OUT b In Out1 : BOOL; b In Out2 : BOOL; END_VAR SA0167: Report temporary Function Block instances Function Determines function block instances that are declared as temporary variables. This applies to instances that are declared in a method, in a function or as VAR_TEMP, and which are reinitialized in each processing cycle or each function block call. Reason • Function blocks have a state that is usually retained over several PLC cycles. An instance on the stack exists only for the duration of the function call. It is therefore only rarely useful to create an instance as a temporary variable. • Secondly, function block instances are frequently large and require a great deal of space on the stack (which is usually limited on controllers). • Thirdly, the initialization and often also the scheduling of the function block can take up quite a lot of time. Importance Medium Examples: Method FB_Sample. Sample Method: METHOD Sample Method : INT VAR_INPUT END_VAR VAR fb Trigger : R_TRIG; // => SA0167 END_VAR Function F_Sample: FUNCTION F_Sample : INT VAR_INPUT END_VAR VAR fb Sample : FB_Sample; // => SA0167 END_VAR MAIN program: PROGRAM MAIN VAR_TEMP fb Sample : FB_Sample; // => SA0167 n Return : INT; END_VAR n Return := F_Sample(); 76 Version: 2.9.0 TE1200

## Page 77

Configuration SA0168: Unnecessary assignments Function Determines assignments to variables that have no effects in the code. Reason If several values are assigned to a variable without the variable being evaluated between the assignments, the first assignments do not have any effect on the program. Importance Low Sample: PROGRAM MAIN VAR n Var1 : DWORD; n Var2 : DWORD; END_VAR n Var1 := 1; IF n Var2 > 100 THEN n Var2 := 0; n Var2 := n Var2 + 1; END_IF n Var1 := 2; // => SA0168 SA0169: Ignored outputs Function Determines the outputs of methods and functions that are not specified when calling the method or function. Reason Ignored outputs can be an indication of unhandled errors or nonsensical function calls, as the results are not used. Importance Medium Sample: Function F_Sample: FUNCTION F_Sample : BOOL VAR_INPUT b In : BOOL; END_VAR VAR_OUTPUT b Out : BOOL; END_VAR Program MAIN: PROGRAM MAIN VAR b Return : BOOL; b Fun Out : BOOL; END_VAR b Return := F_Sample(b In := TRUE , b Out => b Fun Out); b Return := F_Sample(b In := TRUE); // => SA0169 SA0170: Address of an output variable should not be used Function Determines code positions where the address of an output variable (VAR_OUTPUT, VAR_IN_OUT) of a function block is used. Reason It is not allowed to use the address of a function block output in the following way: • By means of the ADR operator • By means of REF= Exception No error is reported if the output variable is used within the same function block. Importance Medium Sample: TE1200 Version: 2.9.0 77

## Page 78

Configuration Function block FB_Sample: FUNCTION_BLOCK FB_Sample VAR_INPUT n In : INT; END_VAR VAR_OUTPUT n Out : INT; END_VAR VAR p FB : POINTER TO FB_Sample; p INT : POINTER TO INT; END_VAR IF p FB <> 0 THEN p INT := ADR(p FB^.n Out); // => SA0170 END_IF n Out := n In; p INT := ADR(THIS^.n Out); // no error due to internal usage p INT := ADR(n Out); // no error due to internal usage Accesses within another function block, in this case in the MAIN program: PROGRAM MAIN VAR fb Sample : FB_Sample; p External : POINTER TO INT; ref External : REFERENCE TO INT; END_VAR p External := ADR(fb Sample.n Out); // => SA0170 ref External REF= fb Sample.n Out; // => SA0170 SA0171: Enumerations should have the 'strict' attribute Function Detects declarations of enumerations which are not provided with the {attribute 'strict'} attribute. Reason The {attribute 'strict'} attribute causes compiler errors to be issued if the code violates strict programming rules for enumerations. By default, when a new enumeration is created, the declaration is automatically assigned the 'strict' attribute. Importance High For more information see: PLC > Reference programming > Pragmas > Attribute pragmas > Attribute 'strict' Sample: {attribute 'qualified_only'} {attribute 'strict'} TYPE E_Traffic Light : ( e Red := 0, e Yellow, e Green ); END_TYPE {attribute 'qualified_only'} TYPE E_Machine States : // => SA0171 ( e Stopped := 0, e Running, e Error ); END_TYPE 78 Version: 2.9.0 TE1200

## Page 79

Configuration SA0172: Possible attempt to access outside the array limits Function Determines possible accesses to an array index outside the array limits. Reason The range of the array index is often exceeded in FOR loops in which the index variable is used to access an array index. Importance High Sample: PROGRAM MAIN VAR_TEMP n Index : INT; END_VAR VAR a Sample : ARRAY[0..10] OF INT; END_VAR FOR n Index := INT#0 TO INT#50 DO a Sample[n Index] := 0; // => SA0172 END_FOR SA0175: Suspicious operation on string Function Determines code positions that are suspicious for UTF-8 encoding. Captured 1. Index access to a single-byte string constructs ◦ Example: s Var[2] ◦ Message: Suspicious operation on string: index access '<expression>' 2. Address access to a single-byte string ◦ Example: ADR(s Var) ◦ Message: Suspicious operation on string: Possible index access '<expression>' 3. Call of a string function of the Tc2_Standard library except CONCAT and LEN ◦ Example: FIND(s Var, 'a'); ◦ Message: Suspicious operation on string: Possible index access '<expression>' 4. Single byte literal containing non-ASCII characters ◦ Examples: s Var := '99€'; s Var := 'Ä'; ◦ Message: Suspicious operation on string: literal '<literal>' contains non-ASCII characters Importance Medium Examples: VAR s Var : STRING; p Var : POINTER TO STRING; n Var : INT; END_VAR // 1) SA0175: Suspicious operation on string: Index access s Var[2]; // => SA0175 // 2) SA0175: Suspicious operation on string: Possible index access p Var := ADR(s Var); // => SA0175 // 3) SA0175: Suspicious operation on string: Possible index access n Var := FIND(s Var, 'a'); // => SA0175 // 4) SA0175: Suspicious operation on string: Literal '<...>' contains Non-ASCII character s Var := '99€'; // => SA0175 s Var := 'Ä'; // => SA0175 TE1200 Version: 2.9.0 79

## Page 80

Configuration SA0178: Cognitive complexity Function The check determines whether a defined limit of cognitive complexity is exceeded in a function block. You can configure the parameter that is taken into account in the check by double- clicking on the row for rule 178 in the rule configuration (PLC Project Properties > category "Static Analysis" > "Rules" tab > Rule 178). You can make the following settings in the dialog that appears: • Complexity limit (default value: 20) Reason This is about checking individual programming guidelines. Some programming guidelines stipulate a maximum value for the cognitive complexity of function blocks. Excessive cognitive complexity makes the code difficult to read and maintain. Importance Medium Corresponding metric available The following metric is available for calculating cognitive complexity as part of the metrics table: Cognitive complexity [} 101] Sample: See metric: Cognitive complexity [} 101] SA0179: Coupling between objects Function The check determines whether a defined limit of the coupling between objects in a function block is exceeded. You can configure the parameter that is taken into account in the check by double- clicking on the row for rule 179 in the rule configuration (PLC Project Properties > category "Static Analysis" > "Rules" tab > Rule 179). You can make the following settings in the dialog that appears: • Coupling limit (default value: 30) Reason This is about checking individual programming guidelines. Some programming guidelines stipulate a maximum value for the coupling between objects for function blocks. Too much coupling between objects makes the code difficult to maintain. Importance Medium Synonym CBO: Coupling Between Objects Corresponding metric available The following metric is available for calculating cognitive complexity as part of the metrics table: Coupling Between Objects (CBO) [} 105] Sample: See metric: Coupling Between Objects (CBO) [} 105] SA0180: Index range does not cover the entire array Function Determines arrays with an index range that is not completely covered. Reason Arrays are often handled in loops, with the loop index indexing the array in such a way that all components of the array are accessed without gaps. This is the case if the loop index and the array index are the same in all dimensions. If the index range does not completely cover the array, this indicates components in the array that have not been processed. Importance Medium 80 Version: 2.9.0 TE1200

## Page 81

Configuration Sample: PROGRAM MAIN VAR_TEMP n Index : INT; END_VAR VAR a Sample : ARRAY[0..10] OF INT; END_VAR FOR n Index := INT#1 TO INT#10 DO a Sample[n Index] := 0; // => SA0180 END_FOR 4.3 Naming conventions In the Naming Conventions tab you can define naming conventions. Their compliance is accounted for in the Static Analysis execution [} 111]. You define mandatory prefixes for the different data types of variables as well as for different scopes, function block types, and data type declarations. The names of all objects for which a convention can be specified are displayed in the project properties as a tree structure. The objects are arranged below organizational nodes. In the Naming Conventions tab, you will also find options [} 90] that extend the configuration of the prefixes. You can use these options to configure how the expected overall prefix for variables/declarations should be composed. TE1200 Version: 2.9.0 81

## Page 82

Configuration Configuration of the naming conventions Names Nodes and elements for which a prefix can be defined The number in brackets after each element, for example "PROGRAM (102)", is the prefix convention number that is output if the naming convention is not followed. Prefix You can define the naming conventions by entering the required prefix in this column. Please note the following notes and options: • Several possible prefixes per line ◦ Multiple prefixes can be entered separated by commas. ◦ Example: "x, b" as prefixes for variables of data type BOOL. "x" and "b" may be used as prefix for Boolean variables. • Regular expressions ◦ You can also use regular expressions (Reg Ex) for the prefix. In this case you have to use @ as additional prefix. ◦ Example: "@b[a-d A-D]" as prefix for variables of data type BOOL. The name of the boolean variable must start with "b", and may be followed by a character in the range "a-d A-D". • Data type placeholder ◦ For variables of the Alias data type and for properties you can use the data type placeholder "{datatype}" as prefix. ◦ Example: Prefix for the variable data type Alias (33) = "{datatype}" Prefixes for variables Organizational node for all variables for which a prefix dependent on their data type or scope can be defined Prefixes for POUs Organizational node for all POU types and method validity ranges for which a prefix can be defined Prefixes for DUTs Organizational node for the DUT data types Structure, Enumeration, Alias or Union for which a prefix can be defined Prefixes for user- Available from TC3.1 Build 4026 defined types (NC0160) Organizational node for special user-defined types, especially those from libraries or for read-only types (e.g. PVOID, HRESULT) • You can expand the list with conventions: click the blank line below. Then enter the name of a user-defined type or select a user-defined type in the "Input Assistant" dialog. • You can delete a convention by selecting it and choosing the [Del] key. Note: These conventions take priority over the prefixes defined with the {attribute 'nameprefix' := '<prefix>'} attribute. Sample: • In the "Name" column, enter the read-only system data type "PVOID" in an empty line below the prefixes for user-defined types. In the same line in the "Prefix" column, enter the desired prefix, e.g. "p". Variables of type PVOID are checked for this prefix when running Static Analysis. • More examples of user-defined types whose desired prefix you can configure at this point: ◦ System data type HRESULT ◦ TON function block from the Tc2_System library 82 Version: 2.9.0 TE1200

## Page 83

Configuration Formation of the expected prefix The prefix expected for the different declarations is formed depending on the configuration of the options found in the Options [} 90] dialog. On the Options [} 90] page you will also find explanations on how the expected prefix is formed, as well as some samples. Placeholder {datatype} with alias variables and properties Please also note the possibilities of the placeholder {datatype} [} 93], which you can use for the prefix definition of alias variables and properties. Local prefix definition for structured types For variables of structured types, you can specify a prefix locally in the data type declaration using the 'nameprefix' attribute [} 124]. Syntax of convention violations in the message window Each naming convention has a unique number (shown in parentheses after the convention in the naming convention configuration view). If a violation of a convention or a preset is detected during the static analysis, the number is output in the error list together with an error description based on the following syntax. The abbreviation "NC" stands for "Naming Convention". Syntax: "NC<prefix convention number>: <convention description>" Sample for convention number 151 (DUTs of type Structure): "NC0151: Invalid type name 'STR_Sample'. Expected prefix 'ST_'" Temporary deactivation of naming conventions Individual conventions can be disabled temporarily, i.e. for particular code lines. To this end you can add a pragma or an attribute in the declaration or implementation part of the code. For variables of structured types you may specify a prefix locally via an attribute in the data type declaration. For more information see: Pragmas and attributes [} 121]. Overview of naming conventions For an overview of naming conventions, see Naming conventions – overview and description [} 83]. 4.3.1 Naming conventions – overview and description Overview - Prefixes for variables - Prefixes for types - NC0003: BOOL [} 86] - NC0004: BIT [} 86] - NC0005: BYTE [} 86] - NC0006: WORD [} 86] - NC0007: DWORD [} 86] - NC0008: LWORD [} 86] - NC0013: SINT [} 86] TE1200 Version: 2.9.0 83

## Page 84

Configuration - NC0014: INT [} 86] - NC0015: DINT [} 86] - NC0016: LINT [} 86] - NC0009: USINT [} 86] - NC0010: UINT [} 86] - NC0011: UDINT [} 86] - NC0012: ULINT [} 86] - NC0017: REAL [} 86] - NC0018: LREAL [} 86] - NC0019: STRING [} 86] - NC0020: WSTRING [} 86] - NC0021: TIME [} 86] - NC0022: LTIME [} 86] - NC0023: DATE [} 86] - NC0024: DATE_AND_TIME [} 86] - NC0025: TIME_OF_DAY [} 86] - NC0026: POINTER [} 86] - NC0027: REFERENCE [} 86] - NC0028: SUBRANGE [} 87] - NC0030: ARRAY [} 87] - NC0031: Function block instance [} 87] - NC0036: Interface [} 87] - NC0032: Structure [} 88] - NC0029: ENUM [} 88] - NC0033: Alias [} 88] - NC0034: Union [} 88] - NC0035: __XWORD [} 86] - NC0037: __UXINT [} 86] - NC0038: __XINT [} 86] - Prefixes for scopes - NC0051: VAR_GLOBAL [} 89] - NC0070: VAR_GLOBAL CONSTANT [} 89] - NC0071: VAR_GLOBAL RETAIN [} 89] 84 Version: 2.9.0 TE1200

## Page 85

Configuration - NC0072: VAR_GLOBAL PERSISTENT [} 89] - NC0073: VAR_GLOBAL RETAIN PERSISTENT [} 89] - VAR - NC0053: Program variables [} 89] - NC0054: Function block variables [} 89] - NC0055: Function/method variables [} 89] - NC0056: VAR_INPUT [} 89] - NC0057: VAR_OUTPUT [} 89] - NC0058: VAR_IN_OUT [} 89] - NC0059: VAR_STAT [} 89] - NC0061: VAR_TEMP [} 89] - NC0062: VAR CONSTANT [} 89] - NC0063: VAR PERSISTENT [} 89] - NC0064: VAR RETAIN [} 89] - NC0065: I/O variables [} 89] - Prefixes for POUs - Prefixes for POU type - NC0102: PROGRAM [} 89] - NC0103: FUNCTIONBLOCK [} 89] - NC0104: FUNCTION [} 89] - NC0105: METHOD [} 89] - NC0106: ACTION [} 89] - NC0107: PROPERTY [} 89] - NC0108: INTERFACE [} 89] - Method/property scope - NC0121: PRIVATE [} 90] - NC0122: PROTECTED [} 90] - NC0123: INTERNAL [} 90] - NC0124: PUBLIC [} 90] - Prefixes for DUTs - NC0151: Structure [} 90] - NC0152: Enumeration [} 90] - NC0153: Union [} 90] - NC0154: Alias [} 90] TE1200 Version: 2.9.0 85

## Page 86

Configuration - Prefixes for user-defined types - NC0160: User-defined type [} 90] Detailed description The following sections contain explanations and examples of which declarations (i.e. at which point in the project) use the individual naming conventions. The declarations samples illustrate cases for which the corresponding prefix would be expected if a prefix was defined with the corresponding naming convention. It should become clear where and how a type or variable can be declared so that the naming convention NC<xxxx> is checked at this point. However, the samples do not show which concrete prefix is defined for the individual naming conventions and would therefore be expected in the sample declarations. There is therefore no OK/NOK comparison. For concrete examples with a defined prefix, please refer to the page Options [} 90]. Basic data types: NC0003: BOOL Configuration of a prefix for a variable declaration of type BOOL. Sample declarations: For the following variable declarations the prefix configured for NC0003 is used for the formation of the overall prefix, compliance with which is checked during execution of the static analysis [} 111]. b Status : BOOL; ab Var : ARRAY[1..2] OF BOOL; Ib Input AT%I* : BOOL; The description of "NC0003: BOOL" is transferrable to the other basic data types: - NC0004: BIT, NC0005: BYTE - NC0006: WORD, NC0007: DWORD, NC0008: LWORD - NC0013: SINT, NC0014: INT, NC0015: DINT, NC0016: LINT, NC0009: USINT, NC0010: UINT, NC0011: UDINT, NC0012: ULINT - NC0017: REAL, NC0018: LREAL - NC0019: STRING, NC0020: WSTRING - NC0021: TIME, NC0022: LTIME, NC0023: DATE, NC0024: DATE_AND_TIME, NC0025: TIME_OF_DAY - NC0035: __XWORD, NC0037: __UXINT, NC0038: __XINT Nested data types: NC0026: POINTER Configuration of a prefix for a variable declaration of type POINTER TO. Sample declaration: For the following variable declaration the prefix configured for NC0026 is used for the formation of the overall prefix, compliance with which is checked during execution of the static analysis [} 111]. pn ID : POINTER TO INT; NC0027: REFERENCE Configuration of a prefix for a variable declaration of type REFERENCE TO. 86 Version: 2.9.0 TE1200

## Page 87

Configuration Sample declaration: For the following variable declaration the prefix configured for NC0027 is used for the formation of the overall prefix, compliance with which is checked during execution of the static analysis [} 111]. reff Current Position : REFERENCE TO REAL; NC0028: SUBRANGE Configuration of a prefix for a variable declaration of a subrange type. A subrange type is a data type whose value range only covers a subset of a base type. Possible basic data types for a subrange type: SINT, USINT, INT, UINT, DINT, UDINT, BYTE, WORD, DWORD, LINT, ULINT, LWORD. Sample declarations: For the following variable declaration the prefix configured for NC0028 is used for the formation of the overall prefix, compliance with which is checked during execution of the static analysis [} 111]. subi Range : INT(3..5); sublw Range : LWORD(100..150); NC0030: ARRAY Configuration of a prefix for a variable declaration of type ARRAY[…] OF. Sample declaration: For the following variable declaration the prefix configured for NC0030 is used for the formation of the overall prefix, compliance with which is checked during execution of the static analysis [} 111]. an Target Positions : ARRAY[1..10] OF INT; Instance-based data types: NC0031: Function block instance Configuration of a prefix for a variable declaration of a function block type. Sample declaration: Declaration of a function block: FUNCTION_BLOCK FB_Sample … For the following variable declaration the prefix configured for NC0031 is used for the formation of the overall prefix, compliance with which is checked during execution of the static analysis [} 111]. fb Sample : FB_Sample; NC0036: Interface Configuration of a prefix for a variable declaration of an interface type. Sample declaration: Interface declaration: INTERFACE I_Sample For the following variable declaration the prefix configured for NC0036 is used for the formation of the overall prefix, compliance with which is checked during execution of the static analysis [} 111]. i Sample : I_Sample; TE1200 Version: 2.9.0 87

## Page 88

Configuration NC0032: Structure Configuration of a prefix for a variable declaration of a structure type. Sample declaration: Declaration of a structure: TYPE ST_Sample : STRUCT b Var : BOOL; s Var : STRING; END_STRUCT END_TYPE For the following variable declaration the prefix configured for NC0032 is used for the formation of the overall prefix, compliance with which is checked during execution of the static analysis [} 111]. st Sample : ST_Sample; NC0029: ENUM Configuration of a prefix for a variable declaration of an enumeration type. Sample declaration: Declaration of an enumeration: TYPE E_Sample : ( e Member1 := 1, e Member2 ); END_TYPE For the following variable declaration the prefix configured for NC0029 is used for the formation of the overall prefix, compliance with which is checked during execution of the static analysis [} 111]. e Sample : E_Sample; NC0033: Alias Configuration of a prefix for a variable declaration of an alias type. Sample declaration: Declaration of an alias: TYPE T_Message : STRING; END_TYPE For the following variable declaration the prefix configured for NC0033 is used for the formation of the overall prefix, compliance with which is checked during execution of the static analysis [} 111]. t Message : T_Message; NC0034: Union Configuration of a prefix for a variable declaration of a union type. Sample declaration: Declaration of a union: TYPE U_Sample : UNION n1 : WORD; n2 : INT; END_UNION END_TYPE For the following variable declaration the prefix configured for NC0034 is used for the formation of the overall prefix, compliance with which is checked during execution of the static analysis [} 111]. u Sample : U_Sample; 88 Version: 2.9.0 TE1200

## Page 89

Configuration Scopes of variable declarations: NC0051: VAR_GLOBAL Configuration of a prefix for a variable declaration between the keywords VAR_GLOBAL and END_VAR. Sample declaration: For the following declaration of a global variable, the prefix configured for NC0051 is used for the formation of the overall prefix, compliance with which is checked during execution of the static analysis [} 111]. VAR_GLOBAL gb Error Acknowledge : BOOL; END_VAR The description of "NC0051: VAR_GLOBAL" is transferrable to other scopes of variable declarations: - NC0070: VAR_GLOBAL CONSTANT - NC0071: VAR_GLOBAL RETAIN - NC0072: VAR_GLOBAL PERSISTENT - NC0073: VAR_GLOBAL RETAIN PERSISTENT - NC0053: Program variables (VAR within a program) - NC0054: Function block variables (VAR within a function block) - NC0055: Function/method variables (VAR within a function/method) - NC0056: VAR_INPUT - NC0057: VAR_OUTPUT - NC0058: VAR_IN_OUT - NC0059: VAR_STAT - NC0061: VAR_TEMP - NC0062: VAR CONSTANT - NC0063: VAR PERSISTENT - NC0064: VAR RETAIN NC0065: I/O variables Configuration of a prefix for a variable declaration with AT declaration. Sample declarations: For the following variable declarations with AT declaration, the prefix configured for NC0065 is used for the formation of the overall prefix, compliance with which is checked during execution of the static analysis [} 111]. io Var1 AT%I* : INT; io Var2 AT%IX1.0 : BOOL; io Var3 AT%Q* : INT; io Var4 AT%QX2.0 : BOOL; POU types: NC0102: PROGRAM Configuration of a prefix for the declaration of a program (name of the program in the project tree). TE1200 Version: 2.9.0 89

## Page 90

Configuration The description of "NC0102: PROGRAM" is transferrable to the other POU types: - NC0103: FUNCTIONBLOCK - NC0104: FUNCTION - NC0105: METHOD - NC0106: ACTION - NC0107: PROPERTY - NC0108: INTERFACE Scopes of methods and properties: NC0121: PRIVATE Configuration of a prefix for the declaration of a method or a property (name of the method/property in the project tree), whose access modifier is PRIVATE. The description of "NC121: PRIVATE" is transferrable to the other scopes of methods and properties: - NC0122: PROTECTED - NC0123: INTERNAL - NC0124: PUBLIC DUTs: NC0151: Structure Configuration of a prefix for the declaration of a structure (name of the structure in the project tree). The description of "NC0151: Structure" is transferrable to the other DUT types: - NC0152: Enumeration - NC0153: Union - NC0154: Alias User-defined types: NC0160: User defined type Configuration of a prefix for a user-defined type, e.g. for variables of type PVOID or for instances of the library function block Tc2_System. TON. For more information on the input options in this area, visit Naming conventions [} 81]. 4.3.2 Options In the Naming Conventions tab, you will find options that extend the configuration of the prefixes. You can use these options to configure how the expected overall prefix for variables/declarations should be composed. 1) First character after prefix should be an upper case letter • If enabled: The static code analysis reports an error for a variable if the first character of the variable name after the defined prefix is not an upper case letter. 90 Version: 2.9.0 TE1200

## Page 91

Configuration • If disabled: Upper case/lower case spelling is not checked. • Default setting: disabled Samples: • Variable "bvar" with the expected prefix "b" • Function block "FB_sample" with the expected prefix "FB_" Option State Result of the static analysis First character after Enabled For the definitions mentioned above, an error will be reported in each prefix should be an case that the first letter after the prefix must be an upper case letter. upper case letter Correct identifiers would be "b Var" and "FB_Sample". Disabled The identifiers "bvar" and "FB_sample" are permissible. No upper/ lower case error is output. 2) Recursive prefixes for combinable data types • If enabled: Variables of combinable data types (POINTER, REFRENCE, ARRAY, SUBRANGE) must have a composite data type prefix. The composite prefix is formed from the individual prefixes configured for the individual components of the combined data type. • If disabled: Only the prefix of the outermost data type is expected as the date type prefix. • Default setting: enabled • Examples: see below 3) Combine scope prefix with data type prefix (namespace = scope) • If enabled: A variable must have the prefix for its scope defined in the naming conventions, followed by its data type prefix. • If disabled: The expected overall prefix depends on whether or not a scope prefix is defined for a variable. ◦ If the associated scope prefix is defined for a variable, the variable must have only the prefix for its scope defined in the naming conventions. The data type prefix is not expected after the scope prefix. ◦ If the associated scope prefix is not defined for a variable, the variable must have only the data type prefix defined for it. • Default setting: enabled • Examples: see below Samples • Prefix configuration for data types: ◦ POINTER (26) = "p" ◦ ARRAY (30) = "a" ◦ INT (14) = "n" ◦ BOOL (3) = "b" • Prefix configuration for scope ◦ Case 1: Function block variables (54) = "_local_" ◦ Case 2: Function block variables (54) = empty field/not configured ◦ INFO: Further examples of a scope include VAR_GLOBAL (51), VAR_INPUT (56) and VAR CONSTANT (62). • Declaration: FUNCTION_BLOCK FB_Sample VAR var1 : POINTER TO ARRAY[1..3] OF INT; var2 : ARRAY[10..20] OF ARRAY[3..5] OF BOOL; END_VAR TE1200 Version: 2.9.0 91

## Page 92

Configuration Option scenario 1: Option State Expected overall prefix for Expected overall prefix for case 1 case 2 (NC0054 = "_local_") (NC0054 = empty) Recursive prefixes for Enabled For var1: '_local_pan' For var1: 'pan' combinable data types For var2: '_local_aab' For var2: 'aab' Combine scope prefix with Enabled data type prefix Explanation: • As the option "Recursive prefixes for combinable data types" is enabled, the prefix composed of the individual prefixes is expected as the data type prefix. Consequently, the sub-prefixes "p" for POINTER, "a" for ARRAY and "n" for INT are combined to form the data type prefix "pan", or the sub- prefixes "a" for ARRAY, "a" for ARRAY again and "b" for BOOL are combined to form the data type prefix "aab". • As the option "Combine scope prefix with data type prefix" is also enabled, the combination of scope prefix and data type prefix is expected as the overall prefix. ◦ Case 1: _local_ + pan = _local_pan ◦ Case 2: <empty> + pan = pan Option scenario 2: Option State Expected overall prefix for Expected overall prefix for case 1 case 2 (NC0054 = "_local_") (NC0054 = empty) Recursive prefixes for Disabled For var1: '_local_p' For var1: 'p' combinable data types For var2: '_local_a' For var2: 'a' Combine scope prefix with Enabled data type prefix Explanation: • As the option "Recursive prefixes for combinable data types" is disabled, only the prefix of the outermost data type is expected as the data type prefix. The expected data type prefix is therefore "p" or "a". • As the option "Combine scope prefix with data type prefix" is enabled, the combination of scope prefix and data type prefix is expected as the overall prefix for variables. ◦ Case 1: _local_ + p = _local_p ◦ Case 2: <empty> + p = p Option scenario 3: Option State Expected overall prefix for Expected overall prefix for case 1 case 2 (NC0054 = "_local_") (NC0054 = empty) Recursive prefixes for Enabled For var1: '_local_' For var1: 'pan' combinable data types For var2: '_local_' For var2: 'aab' Combine scope prefix with Disabled data type prefix Explanation: • See option scenario 1: As the option "Recursive prefixes for combinable data types" is enabled, the prefix composed of the individual prefixes is expected as the data type prefix. This results in "pan" or "aab" as the data type prefix. • As the option "Combine scope prefix with data type prefix" is disabled, the expected overall prefix depends on whether or not a scope prefix is defined for a variable. 92 Version: 2.9.0 TE1200

## Page 93

Configuration ◦ If scope prefix is defined (case 1): The variable must only have the scope prefix. The data type prefix is not expected after the scope prefix. This results for both variables in "_local_" as the expected overall prefix. ◦ If scope prefix is not defined (case 2): The variable must only have the data type prefix. This results in "pan" or "aab" as the expected overall prefix. Option scenario 4: Option State Expected overall prefix for Expected overall prefix for case 1 case 2 (NC0054 = "_local_") (NC0054 = empty) Recursive prefixes for Disabled For var1: '_local_' For var1: 'p' combinable data types For var2: '_local_' For var2: 'a' Combine scope prefix with Disabled data type prefix Explanation: • See option scenario 2: As the option "Recursive prefixes for combinable data types" is disabled, only the prefix of the outermost data type is expected as the data type prefix. This results in "p" or "a" as the data type prefix. • As the option "Combine scope prefix with data type prefix" is disabled, the expected overall prefix depends on whether or not a scope prefix is defined for a variable. ◦ If scope prefix is defined (case 1): The variable must only have the scope prefix. The data type prefix is not expected after the scope prefix. This results for both variables in "_local_" as the expected overall prefix. ◦ If scope prefix is not defined (case 2): The variable must only have the data type prefix. This results in "p" or "a" as the expected overall prefix. Further notes/examples: For POUs with an access modifier (methods or properties), the combination of the prefix for the scope (NC0121-NC0124: PRIVATE/PROTECTED/INTERNAL/PUBLIC) and the prefix for the POU type (NC0105 for method, NC0107 for property) is expected as the overall prefix. Samples: • If the prefix "priv_" has been configured for PRIVATE (121) and the prefix "M_" for METHOD (105), the overall prefix "priv_M_" is expected for a PRIVATE method. • If the prefix "M_" is still configured for METHOD (105), but no prefix has been configured for PRIVATE (121), that is, if the field is empty in the naming conventions, the overall prefix "M_" is expected for a PRIVATE method. 4.3.3 Placeholder {datatype} For variables of type Alias and for properties, the placeholder "{datatype}" can be defined as a prefix in the "Naming Conventions" tab. The placeholder {datatype} is thereby replaced by the prefix that is defined for the data type of the alias or for the data type of the property. The static analysis thus reports errors for all alias variables that do not possess the prefix for the data type of the alias or for all properties that do not possess the prefix for the data type of the property. The placeholder "{datatype}" can also be combined with further prefixes in the prefix definition, e.g. to "P_{datatype}_". Example 1 for an alias variable: • In the project there is an alias "TYPE My Message Type : STRING; END_TYPE" as well as a variable of this type (var : My Message Type;). • Prefix definitions ◦ Prefix for the variable data type alias (33) = "{datatype}" ◦ Prefix for the variable data type STRING (19) = "s" TE1200 Version: 2.9.0 93

## Page 94

Configuration • In the prefix definitions mentioned the data type prefix "s" is expected for a variable of the alias type "My Message Type" (e.g. for the variable "var"). Example 2 for an alias variable: • Same situation as in example 1 for an alias variable, the only difference being: ◦ Prefix for the variable data type alias (33) = "al_{datatype}" • In this case the data type prefix "al_s" is expected for a variable of the alias type "My Message Type". Example of a property: • Prefix definitions ◦ Prefix for the method/property scope PRIVATE (121) = "priv_" ◦ Prefix for the POU type PROPERTY (107) = "P_{datatype}" ◦ Prefix for the variable data type LREAL (18) = "f" • Note: For POUs with an access modifier (methods or properties), the combination of the prefix for the scope (NC0121-NC0124: PRIVATE/PROTECTED/INTERNAL/PUBLIC) and the prefix for the POU type (NC0105 for method, NC0107 for property) is expected as the overall prefix. • With the prefix definitions mentioned the overall prefix "priv_P_f" is thus expected for a property with the access modifier PRIVATE and the data type LREAL. 4.4 Metrics In the Metrics tab you can select and configure the metrics to be displayed for each function block in the Standard Metrics view when the command 'View Standard Metrics' [} 114] is executed. You have over 20 metrics at your disposal to analyze and characterize the underlying source code. When calculated regularly, the metrics can indicate negative trends and deviations from quality targets. The key figures therefore represent an indicator for assessing software quality. For example, the tabular output contains metrics for the number of statements or the proportion of comments. Analysis of libraries The following metrics are also output for the libraries integrated in the project: code size, variable size, stack size and number of calls. Compilation errors for violations of upper/lower limits You can use rule SA0150 of the static code analysis to output violations of the upper and lower limits of the activated metrics as compilation errors. Configuration of the metrics Active You can enable or disable the individual metrics using the checkbox for the respective row. When command 'View Standard Metrics' [} 114] is executed, the metrics that are enabled in the respective configuration are shown for each programming block in the Standard Metrics view. • : The metric is disabled and is not displayed in the Standard Metrics view when the command View Standard Metrics is executed. • : The metric is enabled and is displayed in the Standard Metrics view when the command View Standard Metrics is executed. Lower limit For each metric you can define an individual upper and lower limit by entering the required number in the respective metric row. Upper limit If a metric is only limited in one direction, you can leave the configuration for the other direction blank. In other words, you may specify either only the lower limit or only the upper limit. 94 Version: 2.9.0 TE1200

## Page 95

Configuration Evaluation of the upper and lower limits The set upper and lower limits you can be evaluated in two ways. • Standard Metrics view: ◦ Enable the metric whose configured upper and lower limits you want to evaluate. ◦ Execute the Command 'View Standard Metrics' [} 114]. ◦ Twin CAT shows the enabled metrics for each programming block in the tabular Standard Metrics view. ◦ If a value is outside the range defined by an upper and/or lower limit in the configuration, the table cell is shown in red. • Static Analysis: ◦ Enable rule 150 as error or warning in the Rules [} 16] tab. ◦ Run the Static Analysis (see: Command 'Run static analysis' [} 111]). ◦ Violations of the upper and/or lower limits are issued as error or warning in the message window. Overview and description of the metrics An overview of the metrics and a detailed description of the rules can be found in the next chapter. 4.4.1 Metrics - overview and description Title in the “Standard metrics” view Description Code size Code size [number of bytes] [} 96] Variables size Variables size [number of bytes] [} 96] Stack size Stack size [number of bytes] [} 96] Calls Number of calls [} 97] Tasks Called in tasks [} 97] Globals Number of global variables used [} 98] IOs Number of address accesses [} 98] Locals Number of local variables [} 98] Inputs Number of input variables [} 98] Outputs Number of output variables [} 98] NOS Number Of Statements (NOS) [} 99] Comments Percentage of comment [} 100] Mc Cabe Complexity (Mc Cabe) [} 100] Complexity Cognitive complexity [} 101] DIT Depth of Inheritance Tree (DIT) [} 103] NOC Number Of Children (NOC) [} 103] RFC Response For Class (RFC) [} 104] CBO Coupling Between Objects (CBO) [} 105] Elshof Complexity of reference (Elshof) [} 105] LCOM Lack of Cohesion Of Methods - LCOM [} 106] SFC branches Number of SFC branches [} 107] SFC steps Number of SFC steps [} 107] Detailed description TE1200 Version: 2.9.0 95

## Page 96

Configuration Code size [number of bytes] Title short form Code size Categories Informative, efficiency Definition Number of bytes that a function block contributes to the application code Further The number also depends on the code generator. For example, the code generator for information Arm® processors generally generates more bytes than the code generator for x86 processors. Variables size [number of bytes] Title short form Variables size Categories Informative, efficiency Definition Size of the static memory used by the object Further For function blocks, this is the size used for an instance of this function block (which may information also contain memory gaps depending on the memory alignment). For programs, functions and global variable lists, this is the sum of the size of all static variables. Sample: FUNCTION F_Sample : INT VAR_INPUT a,b : INT; END_VAR VAR c,d : INT; END_VAR VAR_STAT f,g,h : INT; END_VAR The function has three static variables of type INT (f, g, h), each of which requires 2 bytes of memory. F_Sample therefore has a variable size of 6 bytes. Stack size [number of bytes] Title short form Stack size Categories Informative, efficient, reliable Definition Number of bytes required to call a function or function block Further Input variables and output variables are aligned with the memory. This can create a gap information between these variables and the local variables. This gap is counted. Return values from called functions that do not fit into a register are pushed onto the stack. The largest of these values determines the additionally allocated memory, which is also counted. Functions or function blocks that are called within the POUs under consideration have their own stack frame. Therefore, the memory for such calls does not count. Depending on the code generator used, intermediate results of calculations also use the stack. These results are not counted. Sample: FUNCTION F_Sample : INT VAR_INPUT a,b : INT; END_VAR VAR c,d,e : INT; END_VAR VAR_STAT f,g,h : INT; END_VAR 96 Version: 2.9.0 TE1200

## Page 97

Configuration c := b; d := a; e := a + b; Assumption: The "Twin CAT RT (x86)" solution platform is used for the calculation. The device has a stack alignment of 4 bytes, which can result in gaps between the variables. The total stack size of F_Sample is 16 bytes and consists of: • 2 input variables with 2 bytes each = 4 bytes • No padding bytes • Return value INT = 2 bytes • Padding bytes for the stack alignment = 2 bytes • 3 local variables with 2 bytes each = 6 bytes • Padding bytes for the stack alignment = 2 bytes VAR_STAT is not stored on the stack and therefore does not increase the stack size of a POU. Number of calls Title short form Calls Categories Informative Definition Number of calls to the program organization unit (POU) within the application Further If a program is called in a task, this call is also counted. information Called in tasks Title short form Tasks Categories Maintainability, reliability Definition Number of tasks in which the program organization unit (POU) is called up Further For function blocks, the number of tasks in which the function block itself or any function information block in the function block's inheritance tree is called is counted. For methods and actions, the number of tasks in which the (higher-level) function block is called is displayed. Sample: FUNCTION_BLOCK FB1 FUNCTION_BLOCK FB2 EXTENDS FB1 FUNCTION_BLOCK FB3 EXTENDS FB2 Each function block is instantiated and called in a separate program. In addition, each program is called in a separate task. The metric Called in tasks therefore results: • For FB3: 1 • For FB2: 2, as the calls from FB2 and FB3 (EXTENDS FB2) are counted • For FB1: 3, as the calls from FB1, FB2 and FB3 are counted TE1200 Version: 2.9.0 97

## Page 98

Configuration Number of global variables used Title short form Globals Categories Maintainability, reusability Definition Number of different global variables used in the program organization unit (POU) Number of address accesses Title short form IOs Categories Reusability, maintainability Definition Number of address accesses in the implementation of the object Sample: PROGRAM MAIN VAR b Var : BOOL; b In AT%I* : BOOL; b Out AT%Q* : BOOL; END_VAR b Var := TRUE; b Out := b In; b Out := NOT b Out AND b In; The number of address accesses for the program MAIN is 5 and is made up of 2 write and 3 read accesses. Number of local variables Title short form Locals Categories Informative, efficiency Definition Number of variables declared in the VAR area of the program organization unit (POU) Further Inherited local variables are not counted. information Number of input variables Number of input variables of the function block (VAR_INPUT). Title short form Inputs Categories Maintainability, reusability Definition Number of variables declared in the VAR_INPUT area of the program organization unit (POU) Further Inherited input variables are not counted. information Standard upper 10 limit for the associated rule SA0166 [} 75] Number of output variables Number of output variables of the function block (VAR_OUTPUT). 98 Version: 2.9.0 TE1200

## Page 99

Configuration Title short form Outputs Categories Maintainability, reusability Definition Number of variables declared in the VAR_OUTPUT area of the program organization unit (POU) Further For function blocks, this is the number of user-defined output variables (VAR_OUTPUT). information For methods and functions, this is the number of user-defined output variables (VAR_OUTPUT) plus one if they have a return value. The return value is also counted. Inherited output variables are not counted. A high number of output variables is a sign of a violation of the principle of clear responsibility. Standard upper 10 limit for the associated rule SA0166 [} 75] Sample: METHOD METH : BOOL VAR_OUTPUT a : INT; b : LREAL; END_VAR The method METH has three outputs: • Return value METH • a • b METHOD METH1 VAR_OUTPUT a : ARRAY[0..10] OF INT; b : LREAL; END_VAR The method METH1 has two outputs: • a • b Number Of Statements (NOS) Title short form NOS Categories Informative Definition Number of executable statements in the implementation of a function block, function or method Further NOS = Number Of executable Statements information Statements in the declaration, empty statements or pragmas are not counted. Sample: FUNCTION_BLOCK FB_Sample VAR_OUTPUT n Test : INT; i : INT; END_VAR VAR b Var : BOOL; c : INT := 100; // statements in the declaration are not counted END_VAR IF b Var THEN //if statement: +1 n Test := 0; // +1 END_IF TE1200 Version: 2.9.0 99

## Page 100

Configuration WHILE n Test = 1 DO //while statement: +1 ; // empty statements do not add to the statement count END_WHILE FOR c := 0 TO 10 BY 2 DO //for statement: +1 i := i+i; // +1 END_FOR {text 'simple text pragma'} //pragmas are not counted n Test := 2; //+1 The sample has six statements. Percentage of comment Title short form Comments Categories Maintainability Definition Percentage of comments in the source code This number is calculated using the following formula: Percentage = 100 * <letters in comments> / <letters in source code and comments together> Further Multiple consecutive spaces in the source code are counted as one space, which information prevents a high weighting of indented source code. A percentage of 0 is returned for empty objects (no source code and no comments). The statements also include declaration statements, for example. Complexity (Mc Cabe) Title short form Mc Cabe Categories Testability Definition Number of binary branches in the control flow of the POU (for example, the number of branches for IF and CASE statements and loops) Further Mc Cabe's cyclomatic complexity is a measure of the readability and testability of source information code. It is calculated by counting the number of binary branches in the control flow of the POU. Cyclomatic complexity penalizes high branching because high branching increases the number of test cases required for high test coverage. Recommended 10 upper limit The following samples show how complexity is calculated according to Mc Cabe. Sample: IF statement // every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch IF b1 THEN // +1 for the THEN branch ; ELSIF b2 THEN // +1 for the THEN branch of the IF inside the ELSE ; ELSE IF b3 OR b4 THEN // +1 for the THEN branch ; END_IF END_IF The code snippet has a cyclomatic complexity of 4. Sample: CASE statement // every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch CASE a OF 1: ; // +1 2: ; // +1 100 Version: 2.9.0 TE1200

## Page 101

Configuration 3,4,5: ; // +1 ELSE // the ELSE statement does not increase the cyclomatic complexity ; END_CASE The code snippet has a cyclomatic complexity of 4. Sample: Loop statement // every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch WHILE b1 DO // +1 for the WHILE loop ; END_WHILE REPEAT // +1 for the REPEAT loop ; UNTIL b2 END_REPEAT FOR a := 0 TO 100 BY 2 DO // +1 for the REPEAT loop ; END_FOR The code snippet has a cyclomatic complexity of 4. Sample: Other statements The following statements also lead to an increase in cyclomatic complexity: FUNCTION FUN : STRING VAR_INPUT b Return : BOOL; b Jump : BOOL; END_VAR // every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch JMP(b Jump) lbl; //Conditional jumps increase the cyclomatic complexity by 1 FUN := 'u'; RETURN(condition_return); //Conditional returns increase the cyclomatic complexity by 1, too lbl: FUN := 't'; The code snippet has a cyclomatic complexity of 3. Cognitive complexity Title short form Cognitive complexity Categories Maintainability Definition Sum of partial complexities resulting, for example, from branches in the control flow of the POU and from sophisticated Boolean expressions Further Cognitive complexity is a measure of the readability and comprehensibility of source information code introduced by Sonarsource™ in 2016. It penalizes a strong nesting of the control flow and sophisticated Boolean expressions. The cognitive complexity is only calculated for structured text implementations. Standard upper 20 limit for the associated rule SA0178 [} 80] Tip You can also use Command 'Show cognitive complexity for current editor' [} 119] to display the increments for Structured Text directly in the editor. The following samples show how cognitive complexity is calculated. Sample: Control flow TE1200 Version: 2.9.0 101

## Page 102

Configuration Statements that manipulate the control flow increase the cognitive complexity by 1. IF TRUE THEN //+1 cognitive complexity ; END_IF WHILE TRUE DO //+1 cognitive complexity ; END_WHILE FOR i := 0 TO 10 BY 1 DO //+1 cognitive complexity ; END_FOR REPEAT //+1 cognitive complexity ; UNTIL TRUE END_REPEAT The code snippet has a cognitive complexity of 4. Sample: Nesting of the control flow When nesting the control flow, an increment of 1 is added for each level of nesting. IF TRUE THEN //+1 cognitive complexity WHILE TRUE DO //+2 (+1 for the loop itself, +1 for the nesting inside the IF) FOR i := 0 TO 10 BY 1 DO //+3 (+1 for the FOR loop itself, +2 for the nesting inside the WHILE and the IF) ; END_FOR END_WHILE REPEAT //+2 (+1 for the loop itself, +1 for the nesting inside the IF) ; UNTIL TRUE END_REPEAT END_IF The code snippet has a cognitive complexity of 8. Sample: Boolean expression Since Boolean expressions play a major role in understanding source code, they are also taken into account when calculating cognitive complexity. Understanding Boolean expressions that are connected with the same Boolean operator is not as difficult as understanding a Boolean expression that contains alternating Boolean operators. Therefore, each chain of equal Boolean operators in an expression increases the cognitive complexity. b := b1; //+0: a simple expression, containing no operators, has no increment The simple expression without operator has an increment of 0. b := b1 AND b2; //+1: one chain of AND operators The expression with an AND operation has an increment of 1. b := b1 AND b2 AND b3; //+1: one more AND, but the number of chains of operators does not change The expression has an AND more. But since it is the same operator, the number of chains formed with identical operators does not change. b := b1 AND b2 OR b3; //+2: one chain of AND operators and one chain of OR operators 102 Version: 2.9.0 TE1200

## Page 103

Configuration The expression has a chain of AND operators and a chain of OR operators. This results in an increment of 2. b := b1 AND b2 OR b3 AND b4 AND b5; //+3: one chain of AND operators, one chain of OR operators and another chain of AND operators The code snippet has an increment of 3. b := b1 AND NOT b2 AND b3; //+1: the unary NOT operator is not considered in the cognitive complexity The unary operator NOT is not taken into account in the cognitive complexity. Sample: Further statements with increment Structured Text has additional statements and expressions that change the control flow. The following statements are penalized with an increment in cognitive complexity: a New Label: x := MUX(i, a,b,c); //+1 for MUX operator y := SEL(b, i,j); //+1 for SEL operator JMP a New Label; //+1 for JMP to label EXIT and RETURN statements do not increase cognitive complexity. Depth of Inheritance Tree (DIT) Title short form DIT Categories Maintainability Definition Number of inheritances until a function block is reached that does not extend any other function block Further DIT = Depth of Inheritance Tree information Sample: FUNCTION_BLOCK FB_Base FUNCTION_BLOCK FB_Sub EXTENDS FB_Base FUNCTION_BLOCK FB_Sub Sub EXTENDS FB_Sub The metric Depth of Inheritance Tree is: • For FB_Base: 0, as it is itself a function block that does not extend any other function block. • For FB_Sub: 1, as one step is required to get to FB_Base. • For FB_Sub Sub: 2, as one step to FB_Sub and another to FB_Base is required. Number Of Children (NOC) Title short form NOC Categories Reusability, maintainability Definition Number of function blocks that extend the given basic function block. Function blocks that indirectly extend a basic function block are not counted. Further NOC = Number Of Children information Sample: FUNCTION_BLOCK FB_Base TE1200 Version: 2.9.0 103

## Page 104

Configuration FUNCTION_BLOCK FB_Sub EXTENDS FB_Base FUNCTION_BLOCK FB_Sub Sub1 EXTENDS FB_Sub FUNCTION_BLOCK FB_Sub Sub2 EXTENDS FB_Sub The metric Number Of Children is: • For FB_Base: 1 child (FB_Sub) • For FB_Sub: 2 children (FB_Sub Sub1, FB_Sub Sub2) • For FB_Sub Sub1: 0 children • For FB_Sub Sub2: 0 children Response For Class (RFC) Title short form RFC Categories Maintainability, reusability Definition Number of different POUs, methods or actions that can be called by a POU Further RFC = Response For Class information The value is used for measuring the complexity (in terms of testability and maintainability). All possible direct and indirect method calls can be reached via associations are taken into account. These can be used to respond to an incoming message or to respond to an event that has occurred. Sample: Function block FB1: FUNCTION_BLOCK FB1 VAR d,x,y : INT; END_VAR x := METH(d+10); y := FUN(42, 0.815); Method FB1. METH: METHOD METH : INT VAR_INPUT i : INT; END_VAR METH := FUN(CUBE(i), 3.1415); Function Cube: FUNCTION CUBE : INT VAR_INPUT i : INT; END_VAR CUBE := i*i*i; Function FUN: FUNCTION FUN : INT VAR_INPUT a : INT; f : LREAL; END_VAR FUN := LREAL_TO_INT(f*10)*a; • FUN, CUBE: These functions have an RFC of 0, as neither function calls other functions, function blocks or methods for their calculations. • FB1. METH: The method uses FUN and CUBE, which results in an RFC of 2. • FB1: ◦ The function block FB1 calls METH and FUN, which increases its RFC by 2. 104 Version: 2.9.0 TE1200

## Page 105

Configuration ◦ For FB1, its method METH must also be taken into account. METH uses FUN and CUBE. FUN has already been added to the RFC of FB1 (see previous point). Thus, only the use of CUBE in METH increases the RFC for FB1 to 3. Coupling Between Objects (CBO) Title short form CBO Categories Maintainability, reusability Definition Number of additional function blocks that are instantiated and used in a function block Further CBO = Coupling Between Objects information A function block with a high level of coupling between objects is likely to be involved in many different tasks and therefore violates the principle of clear responsibility. Standard upper 30 limit for the associated rule SA0179 [} 80] Sample: FUNCTION_BLOCK FB_Base VAR fb3 : FB3; // +1 instantiated here END_VAR FUNCTION_BLOCK FB_Sub EXTENDS FB_Base // +0 for EXTENDS VAR fb1 : FB1; // +1: instantiated here fb2 : FB2; // +1: instantiated here END_VAR fb3(); // +0: instantiated in FB_Base, no increment for call • The extension of a function block does not increase the coupling between objects. • fb3 is instantiated in the implementation of FB_Base and inherited by FB_Sub. The call in FB_Sub does not increase the coupling between the objects. • The metric Coupling Between Objects for FB_Sub is therefore : 2 Complexity of reference (Elshof) Complexity of reference = referenced data (number of variables) / number of data references Title short form Elshof Categories Efficiency, maintainability, reusability Definition Complexity of the data flow of a POU The complexity of reference is calculated using the following formula: <Number of variables used> / <Number of variable accesses> Further Only variable accesses in the implementation part of the POU are taken into account. information Sample: PROGRAM MAIN VAR i, j : INT; k : INT := GVL.m; b, c : BOOL; fb : FB_Sample; END_VAR fb(param A := b); // +3 accesses (fb, param A and b) i := j; // +2 accesses (i and j) j := GVL.d; // +2 accesses (j and GVL.d) TE1200 Version: 2.9.0 105

## Page 106

Configuration For the metric Complexity of reference (Elshof), MAIN: • Number of variables used = 6 • Number of variable accesses = 7 • Complexity of reference (Elshof) = number of variables used/number of variable accesses = 6/7 = 0.85 Attention: • c and k are not used and therefore do not count as "variables used". • The assignment k : INT := GVL.m; is not counted as it is part of the declaration of the program. Lack of Cohesion Of Methods - LCOM Title short form LCOM Categories Maintainability, reusability Definition Cohesion = pairs of methods without common instance variables minus pairs of methods with common instance variables The metric is calculated using the following formula: MAX(0, <number of object pairs without cohesion> - <number of object pairs with cohesion> ) Further LCOM: Lack of Cohesion of Methods information The cohesion between function blocks, their actions, transitions and methods describes whether they access the same variables. The lack of cohesion of methods describes how strongly the objects of a function block are connected to each other. The lower the lack of cohesion, the stronger the connection between the objects. Function blocks with a high lack of cohesion are likely to be involved in many different tasks and therefore violate the principle of unambiguous responsibility. Sample: Function block FB: FUNCTION_BLOCK FB VAR_INPUT a : BOOL; END_VAR VAR i,b : BOOL; END_VAR Action FB. ACT: i := FALSE; Method FB. METH: METHOD METH : BOOL VAR_INPUT c : BOOL; END_VAR METH := c; i := TRUE; Method FB. METH2: METHOD METH2 : INT VAR_INPUT END_VAR METH2 := SEL(b,3,4); For the metric Lack of Cohesion Of Methods (LCOM) , the result for FB: • Object pairs without cohesion (5 pairs): ◦ FB, FB. ACT 106 Version: 2.9.0 TE1200

## Page 107

Configuration ◦ FB, FB. METH ◦ FB, FB. METH2 ◦ FB. ACT, FB. METH2 ◦ FB. METH, FB. METH2 • Object pairs with cohesion (1 pair): ◦ FB. ACT, FB. METH (both use i) • LCOM = number of object pairs without cohesion - number of object pairs with cohesion = 5 - 1 = 4 Number of SFC branches Title short form SFC branches Categories Testability, maintainability Definition Number of alternative and parallel branches of a POU of the implementation language SFC (Sequential Function Chart) Sample: The above code snippet in SFC has 4 branches: 3 alternative and 1 parallel branch. Number of SFC steps If the function block is implemented in Sequential Function Chart (SFC), this code metric indicates the number of steps in the function block. Title short form SFC steps Categories Maintainability Definition Number of steps in a POU of the implementation language SFC (Sequential Function Chart) Further Only the steps contained in the POU programmed in SFC are counted. Steps in the information implementations of actions or transitions called in POUs are not counted. TE1200 Version: 2.9.0 107

## Page 108

Configuration Sample: The above code snippet in SFC has 10 steps. Metrics that are available in Twin CAT versions < 3.1.4026.14: Column abbreviation in Standard Metrics view Description Prather Complexity of nesting (Prather) [} 108] n1 (Halstead) Halstead – number of different used operators (n1) [} 108] N1 (Halstead) Halstead – number of operators (N1) [} 108] n2 (Halstead) Halstead – number of different used operands (n2) [} 108] N2 (Halstead) Halstead – number of operands (N2) [} 108] HL (Halstead) Halstead – length (HL) [} 108] HV (Halstead) Halstead – volume (HV) [} 108] D (Halstead) Halstead – difficulty (D) [} 108] Complexity of nesting (Prather) Nesting weight = statements * nesting depth Complexity of nesting = nesting weight / number statements Nesting through IF/ELSEIF or CASE/ELSE statements, for example. Halstead (n1, N1, n2, N2, HL, HV, D) The following metrics are part of the "Halstead" range: 108 Version: 2.9.0 TE1200

## Page 109

Configuration - Number of different used operators - Halstead (n1) - Number of operators - Halstead (N1) - Number of different used operands - Halstead (n2) - Number of operands - Halstead (N2) - Length - Halstead (HL) - Volume - Halstead (HV) - Difficulty - Halstead (D) Background information: • Relationship between operators and operands (number, complexity, test effort) • Based on the assumption that executable programs consist of operators and operands. • Operands in Twin CAT: variables, constants, components, literals and IEC addresses. • Operators in Twin CAT: keywords, logical and comparison operators, assignments, IF, FOR, BY, ^, ELSE, CASE, Caselabel, BREAK, RETURN, SIN, +, labels, calls, pragmas, conversions, SUPER, THIS, index access, component access, etc. For each program the following basic parameters are formed: • Number of different operators used - Halstead (n1), Number of different operands used - Halstead (n2): ◦ Number of different used operators (h ) and operands (h ); together they form the vocabulary size 1 2 h. • Number of operators - Halstead (N1), Number of operands - Halstead (N2): ◦ Number of total used operators (N ) and operands (N ); together they form the implementation 1 2 class N. • (Language complexity = operators/operator occurrences * operands/operand occurrences) These parameters are used to calculate the Halstead length (HL) and Halstead volume (HV): • Length - Halstead (HL), Volume - Halstead (HV): ◦ HL = h * log h + h * log h 1 2 1 2 2 2 ◦ HV = N* log h 2 Various key figures are calculated from the basic parameters: • Difficulty - Halstead (D): ◦ Describes the difficulty to write or understand a program (during a code review, for example) ◦ D = h /2 *N2/h 1 2 • Effort: ◦ E = D*V The key figures usually match the actual measured values very well. The disadvantage is that the method only applies to individual functions and only measures lexical/textual complexity. TE1200 Version: 2.9.0 109

## Page 110

Configuration 4.5 Forbidden symbols In the Forbidden symbols tab, you can specify the keywords, symbols and identifiers that must not be used in the project code. The forbidden symbols are checked during the static analysis [} 111]. Configuration of forbidden symbols You can enter these symbols directly in the row or select them via the input assistant. During the static analysis the code is checked for the presence of these terms. Any hits result in an error being issued in the message window. Syntax of symbol violations in the message window If a symbol is used in the code that is configured as a forbidden symbol, an error is issued in the message window after the static analysis has been performed. Syntax: "Forbidden symbol '<symbol>'“ Sample for the symbol XOR: "Forbidden symbol 'XOR'“ 110 Version: 2.9.0 TE1200

## Page 111

Commands 5 Commands 5.1 Command 'Run static analysis' Symbol: Function: The command starts the static code analysis for the currently active PLC project and outputs the results in the message window. Call: Build menu or context menu of the PLC project object During execution of the static analysis, compliance with the coding rules, naming conventions and forbidden symbols is checked. This command can be used to trigger a static analysis manually (explicit execution), or the analysis can be performed automatically during code generation (implicit execution, see below for more information). Twin CAT issues the result of the static analysis, i.e. messages relating to rule violations, in the message window. The rules [} 16], naming conventions [} 81] and forbidden symbols [} 110] to be taken into account in the static analysis can be configured [} 14] in the PLC project properties. You can also define whether the violation of a coding rule should appear as an error or a warning in the message window (see: Rules [} 16]). See also: Syntax in the message window [} 112] Please note that the selected PLC project is created before this command is executed. Checking via the static analysis is only started if the code generation was successful, i.e. if the compiler did not detect any compilation errors. Please also note the Command 'Run static analysis [Check all objects]' [} 113] and the differences between the two commands described in the following table. TE1200 Version: 2.9.0 111

## Page 112

Commands Differences 'Run static analysis' command 'Run static analysis [Check all objects]' command Scope of application/ Objects used: Objects used: mode of operation The activated rules are applied to the The activated rules are applied to the objects that are used in the PLC project. objects that are used in the PLC project. Unused objects: Unused objects: Unused objects are not checked with this The rules that are activated and that can command. be checked in the precompile are applied to the unused objects. See also: Quick Fix/Precompile [} 130] Note If you also wish to have the unused The command is primarily useful when objects checked by the static analysis, you creating libraries or when processing can use the 'Run static analysis [check library projects. all objects]' command. Execution options Static analysis can be performed either The "Check all objects" variant cannot be for the command explicitly using the command or implicitly. executed implicitly. It can only be executed explicitly via the command. Implicit execution of the static analysis during each code generation can be The command can also be called up via enabled or disabled in the PLC project the Automation Interface. See also: properties (Settings [} 14] tab). If the Automation Interface support [} 132] Perform static analysis automatically option is enabled, Twin CAT performs the static analysis after each successful code generation (with the Build project command, for example). The command can also be called up via the Automation Interface. See also: Automation Interface support [} 132] 5.1.1 Syntax in the message window Syntax of rule violations in the message window Each rule has a unique number (shown in parentheses after the rule in the rule configuration view). If a rule violation is detected during the static analysis, the number together with an error or warning description is issued in the message window, based on the following syntax. The abbreviation "SA" stands for "Static Analysis". Syntax: "SA<rule number>: <rule description>" Sample for rule number 33 (unused variables): "SA0033: Not used: variable 'b Sample'" Syntax of convention violations in the message window Each naming convention has a unique number (shown in parentheses after the convention in the naming convention configuration view). If a violation of a convention or a preset is detected during the static analysis, the number is output in the error list together with an error description based on the following syntax. The abbreviation "NC" stands for "Naming Convention". Syntax: "NC<prefix convention number>: <convention description>" Sample for convention number 151 (DUTs of type Structure): "NC0151: Invalid type name 'STR_Sample'. Expected prefix 'ST_'" Syntax of symbol violations in the message window If a symbol is used in the code that is configured as a forbidden symbol, an error is issued in the message window after the static analysis has been performed. 112 Version: 2.9.0 TE1200

## Page 113

Commands Syntax: "Forbidden symbol '<symbol>'“ Sample for the symbol XOR: "Forbidden symbol 'XOR'“ 5.2 Command 'Run static analysis [Check all objects]' Symbol: Function: The command starts the static code analysis for all objects of the currently active PLC project and outputs the results in the message window. Call: Build menu or context menu of the PLC project object During execution of the static analysis, compliance with the coding rules, naming conventions and forbidden symbols is checked. This command can be used to trigger the static analysis manually (explicit execution). Twin CAT issues the result of the static analysis, i.e. messages relating to rule violations, in the message window. The rules [} 16], naming conventions [} 81] and forbidden symbols [} 110] to be taken into account in the static analysis can be configured [} 14] in the PLC project properties. You can also define whether the violation of a coding rule should appear as an error or a warning in the message window (see: Rules [} 16]). See also: Syntax in the message window [} 112] Please note that the selected PLC project is created before this command is executed. Checking via the static analysis is only started if the code generation was successful, i.e. if the compiler did not detect any compilation errors. Please also note the Command 'Run static analysis' [} 111] and the differences between the two commands described in the following table. TE1200 Version: 2.9.0 113

## Page 114

Commands Differences 'Run static analysis' command 'Run static analysis [Check all objects]' command Scope of application/ Objects used: Objects used: mode of operation The activated rules are applied to the The activated rules are applied to the objects that are used in the PLC project. objects that are used in the PLC project. Unused objects: Unused objects: Unused objects are not checked with this The rules that are activated and that can command. be checked in the precompile are applied to the unused objects. See also: Quick Fix/Precompile [} 130] Note If you also wish to have the unused The command is primarily useful when objects checked by the static analysis, you creating libraries or when processing can use the 'Run static analysis [check library projects. all objects]' command. Execution options Static analysis can be performed either The "Check all objects" variant cannot be for the command explicitly using the command or implicitly. executed implicitly. It can only be executed explicitly via the command. Implicit execution of the static analysis during each code generation can be The command can also be called up via enabled or disabled in the PLC project the Automation Interface. See also: properties (Settings [} 14] tab). If the Automation Interface support [} 132] Perform static analysis automatically option is enabled, Twin CAT performs the static analysis after each successful code generation (with the Build project command, for example). The command can also be called up via the Automation Interface. See also: Automation Interface support [} 132] 5.3 Command 'View Standard Metrics' Symbol: Function: The command starts the static metric code analysis for the currently active PLC project and represents the metrics for the programming blocks used in a table. Call: Build menu or context menu of the PLC project object The command starts the code generation for the selected PLC project (with the command Build project, for example). In a tabular view, Standard Metrics, Twin CAT then displays the desired metrics (parameters) for each programming block used. The metrics to be displayed are activated in the project properties (see Configuration of the metrics [} 94]). If a value is outside the range defined by a lower and/or upper limit in the configuration, the table cell is shown in red. The table can be sorted by columns by clicking on the respective column header. Please note that the selected PLC project is created before this command is executed. Creation of the standard metrics is only started if the code generation was successful, i.e. if the compiler did not detect any compilation errors. Please also note the Command 'View Standard Metrics [Check all objects]' [} 116] and the differences between the two commands are described in the following table. 114 Version: 2.9.0 TE1200

## Page 115

Commands Differences Command 'View Standard Command 'View Standard Metrics' Metrics [Check all objects]' Scope The standard metrics are created The standard metrics are created for the objects used in the PLC for all objects located in the project project. Objects that are not used tree of the PLC project. are not considered with this This is primarily useful when command. creating libraries or when The scope of this command thus processing library projects. corresponds to the build The scope of this command thus commands Build Project/Solution corresponds to the build command or Rebuild Project/Solution Check all objects. respectively. If you want to create default metrics for unused objects, which is useful when editing library projects, you can use the command 'View Standard Metrics [Check all objects]'. 5.3.1 Commands in the context menu of the 'Standard Metrics' view Right-click in the Standard Metrics view to open a context menu that offers several commands. The context menu offers options for updating, printing or exporting the metrics table, or to copy to the clipboard. Via the context menu you can also navigate to a view for configuring the metrics – just like in the PLC project properties. In addition, you can generate a Kiviat diagram for the selected function blocks or open the block in the corresponding editor. A prerequisite for generating a Kiviat diagram is that at least three metrics are configured with a defined value range (lower and upper limit). The following commands are available: • Calculate: The values are updated. • Print table: The standard dialog for setting up the print job appears. • Copy table: The data are copied to the clipboard, separated by tabs. From there you can paste the table directly in a spreadsheet or a word processor. • Export table: The data are exported into a text file (*.csv), separated by semicolons. • Kiviat diagram: A radar chart is created for the selected function block. This is a graphical representation of the function blocks, for which the metrics define a lower and upper limit. It is used to visualize how well the code for the programming unit matches a particular standard. Each metric is shown as an axis in a circle, which starts in the center (value 0) and runs through three ring zones. The inner ring zone represents the range below the lower limit defined for the metric, the outer ring zone represents the range above the upper limit. The axes for the respective metrics are distributed evenly around the circle. The current values for the individual metrics on their axes are linked with lines. Ideally, the whole line should be within the central ring zone. Prerequisite for using a Kiviat diagram At least three metrics with a define value range must be configured. The following diagram shows an example for 3 metrics with defined ranges (the name of the metric is shown at the end of each axis, the name of the function block at the top right): TE1200 Version: 2.9.0 115

## Page 116

Commands • Configure: A table opens in which the metrics can be configured. The view, functionality and settings correspond to the metrics configuration [} 94] in the PLC project properties. If you make a change in this table, it is automatically applied to the PLC project properties. • Open POU: The programming block opens in the corresponding editor. 5.4 Command 'View Standard Metrics [Check all objects]' Symbol: Function: The command starts the static metric code analysis for the currently active PLC project and displays the metrics for all programming blocks in a table. Call: Menu Build or context menu of the PLC project object The command starts the code generation for the selected PLC project (with the command Build project, for example). Twin CAT shows the selected metrics for each programming block in the tabular Standard Metrics view. The metrics to be displayed are activated in the project properties (see Configuration of the metrics [} 94]). If a value is outside the range defined by a lower and/or upper limit in the configuration, the table cell is shown in red. The table can be sorted by columns by clicking on the respective column header. Please note that the selected PLC project is built before this command is executed. Creation of the standard metrics is only started if the code generation was successful, i.e. if the compiler did not detect any compilation errors. Calculation of the "Code size" metric not possible using this command The calculation of the Code size [number of bytes] [} 96] metric is only possible via the 'View Standard Metrics' command [} 114]. When executing the View Standard Metrics [Check all objects] command, the Code size field remains empty. 116 Version: 2.9.0 TE1200

## Page 117

Commands Please also note the command 'View Standard Metrics' [} 114] and the differences between the two commands, which are described in the following table. Differences Command 'View Standard Command 'View Standard Metrics' Metrics [Check all objects]' Scope The standard metrics are created The standard metrics are created for the objects used in the PLC for all objects located in the project project. Objects that are not used tree of the PLC project. are not considered with this This is primarily useful when command. creating libraries or when The scope of this command thus processing library projects. corresponds to the build The scope of this command thus commands Build Project/Solution corresponds to the build command or Rebuild Project/Solution Check all objects. respectively. If you want to create default metrics for unused objects, which is useful when editing library projects, you can use the command 'View Standard Metrics [Check all objects]'. 5.4.1 Commands in the context menu of the 'Standard Metrics' view Right-click in the Standard Metrics view to open a context menu that offers several commands. The context menu offers options for updating, printing or exporting the metrics table, or to copy to the clipboard. Via the context menu you can also navigate to a view for configuring the metrics – just like in the PLC project properties. In addition, you can generate a Kiviat diagram for the selected function blocks or open the block in the corresponding editor. A prerequisite for generating a Kiviat diagram is that at least three metrics are configured with a defined value range (lower and upper limit). The following commands are available: • Calculate: The values are updated. • Print table: The standard dialog for setting up the print job appears. • Copy table: The data are copied to the clipboard, separated by tabs. From there you can paste the table directly in a spreadsheet or a word processor. • Export table: The data are exported into a text file (*.csv), separated by semicolons. • Kiviat diagram: A radar chart is created for the selected function block. This is a graphical representation of the function blocks, for which the metrics define a lower and upper limit. It is used to visualize how well the code for the programming unit matches a particular standard. Each metric is shown as an axis in a circle, which starts in the center (value 0) and runs through three ring zones. The inner ring zone represents the range below the lower limit defined for the metric, the outer ring zone represents the range above the upper limit. The axes for the respective metrics are distributed evenly around the circle. The current values for the individual metrics on their axes are linked with lines. Ideally, the whole line should be within the central ring zone. Prerequisite for using a Kiviat diagram At least three metrics with a define value range must be configured. The following diagram shows an example for 3 metrics with defined ranges (the name of the metric is shown at the end of each axis, the name of the function block at the top right): TE1200 Version: 2.9.0 117

## Page 118

Commands • Configure: A table opens in which the metrics can be configured. The view, functionality and settings correspond to the metrics configuration [} 94] in the PLC project properties. If you make a change in this table, it is automatically applied to the PLC project properties. • Open POU: The programming block opens in the corresponding editor. 5.5 'Show constant propagation values for current editor' command Available from Twin CAT 3.1.4026.14 Symbol: Function: The command starts the static code analysis and calculates a measured value for the constant propagation of the code in the current editor. The dialog that opens visualizes the result. The analyzed code is listed and the determined measured values are displayed. Call: Build menu or context menu of the ST editor Requirement: A programming object in the ST implementation language is open in the editor. For more information, see: Constant propagation [} 126] Dialog: Results of constant propagation Sample: 118 Version: 2.9.0 TE1200

## Page 119

Commands 5.6 Command 'Show cognitive complexity for current editor' Available from Twin CAT 3.1.4026.14 Symbol: Function: The command starts the static code analysis and calculates an increment for the cognitive complexity of the code in the current editor. The dialog that opens visualizes the result and specifies the measured value sum in the title. The analyzed code is listed and displayed with the detected complexities. Call: Build menu or context menu of the ST editor Requirement: A programming object in the ST implementation language is open in the editor. For more information, see also the documentation of the Cognitive Complexity [} 101] metric. Dialog: Cognitive complexity Sample: "Cognitive complexity of FB_Sample: 3" TE1200 Version: 2.9.0 119

## Page 120

Commands 120 Version: 2.9.0 TE1200

## Page 121

Pragmas and attributes 6 Pragmas and attributes A pragma and various attributes are available to temporarily disable individual rules or naming conventions for the static analysis, i.e. to exclude certain code lines or program units from the evaluation. Requirement: The rules or conventions are enabled or defined in the PLC-project properties. See also: • Rules [} 16] • Naming conventions [} 81] Attributes are inserted in the declaration part of a programming block in order to deactivate certain rules for a complete programming object. Pragmas are used in the implementation part of a programming block in order to deactivate certain rules for individual code lines. The exception to this is rule SA0164, which can also be deactivated in the declaration part by a pragma. Rules that are disabled in the project properties cannot be activated by a pragma or attribute. Rule SA0004 cannot be disabled by a pragma or an attribute. Pragmas in the implementation editor If you want to use a pragma in the implementation editor, this is currently possible in the ST and FBD/LD/IL editors. In FBD/LD/IL the desired pragma must be entered in a label. The following section provides an overview and a detailed description of the available pragmas and attributes. Overview • Pragma {analysis ...} [} 122] ◦ for disabling coding rules in the implementation part ◦ can be used for individual code lines • Attribute {attribute 'no-analysis'} [} 122] ◦ for excluding programming objects (e.g. POU, GVL, DUT) from the static analysis (coding rules, naming conventions, forbidden symbols) ◦ can only be used for whole programming objects • Attribute {attribute 'analysis' := '...'} [} 123] ◦ for disabling coding rules in the declaration part ◦ can be used for individual declarations or for whole programming objects • Attribute {attribute 'naming' := '...'} [} 123] ◦ for disabling naming conventions in the declaration part ◦ can be used for individual declarations or for whole programming objects • Attribute {attribute 'nameprefix' := '...'} [} 124] ◦ for defining prefixes for instances of a structured data type ◦ can be used in the declaration part of a structured data type • Attribute {attribute 'analysis:report-multiple-instance-calls'} [} 125] ◦ for specifying that a function block instance should only be called once TE1200 Version: 2.9.0 121

## Page 122

Pragmas and attributes ◦ can be used in the declaration part of a function block Detailed description Pragma {analysis ...} You can use the pragma {analysis -/+<rule number>} in the implementation part of a programming block in order to disregard individual coding rules for the following code lines. Coding rules are deactivated by specifying the rule numbers preceded by a minus sign ("-"). For activation they are preceded by a plus sign ("+"). You can specify any number of rules in the pragma with the help of comma separation. Insertion location: • Deactivation of rules: In the implementation part of the first code line from which the code analysis is disabled with {analysis - ...}. • Activation of rules: After the last line of the deactivation with {analysis + ...}. • For rule SA0164, the pragma can also be inserted in the declaration part before a comment. Syntax: • Deactivation of rules: ◦ one rule: {analysis -<rule number>} ◦ several rules: {analysis -<rule number>, -<further rule number>, -<further rule number>} • Activation of rules: ◦ one rule: {analysis +<rule number>} ◦ several rules: {analysis +<rule number>, +<further rule number>, +<further rule number>} Samples: Rule 24 (only typed literals permitted) is to be disabled for one line (i.e. in these lines it is not necessary to write "n Test := DINT#99") and then enabled again: {analysis -24} n Test := 99; {analysis +24} n Var := INT#2; Specification of several rules: {analysis -10, -24, -18} Attribute {attribute 'no-analysis'} You can use the {attribute 'no-analysis'} attribute to exclude an entire programming object from the static analysis check. For this programming object no checks are carried out for the coding rules, naming conventions and forbidden symbols. Insertion location: above the declaration of a programming object Syntax: {attribute 'no-analysis'} Samples: {attribute 'qualified_only'} {attribute 'no-analysis'} VAR_GLOBAL … END_VAR {attribute 'no-analysis'} PROGRAM MAIN VAR … END_VAR 122 Version: 2.9.0 TE1200

## Page 123

Pragmas and attributes Attribute {attribute 'analysis' := '...'} You can use the attribute {attribute 'analysis' := '-<rule number>'} to switch off certain rules for individual declarations or for a complete programming object. The code rule is deactivated by specifying the rule number(s) with a minus sign in front. You can specify any number of rules in the attribute. Insertion location: above the declaration of a programming object or in the line above a variable declaration Syntax: • one rule: {attribute 'analysis' := '-<rule number>'} • several rules: {attribute 'analysis' := '-<rule number>, -<further rule number>, -<further rule number>'} Samples: Rule 33 (unused variables) is to be disabled for all variables of the structure. {attribute 'analysis' := '-33'} TYPE ST_Sample : STRUCT b Member : BOOL; n Member : INT; END_STRUCT END_TYPE Checking of rules 28 (overlapping memory areas) and 33 (unused variables) is to be disabled for variable n Var1. PROGRAM MAIN VAR {attribute 'analysis' := '-28, -33'} n Var1 AT%QB21 : INT; n Var2 AT%QD5 : DWORD; n Var3 AT%QB41 : INT; n Var4 AT%QD10 : DWORD; END_VAR Rule 6 (concurrent access) is to be disabled for a global variable, so that no error message is generated if write access to the variable occurs from more than one task. VAR_GLOBAL {attribute 'analysis' := '-6'} n Var : INT; b Var : BOOL; END_VAR Attribute {attribute 'naming' := '...'} The attribute {attribute 'naming' := '...'} can be used in the declaration part in order to exclude individual declaration lines from the check for compliance with the current naming conventions. Insertion location: • Deactivation: in the declaration part above the relevant lines • Activation: after the last line of the deactivation Syntax: {attribute 'naming' := '<off|on|omit>'} • off, on: the check is disabled for all rows between the "off" and "on" statements • omit: only the next row is excluded from the check Sample: It is assumed that the following naming conventions are defined: TE1200 Version: 2.9.0 123

## Page 124

Pragmas and attributes • The identifiers of INT variables must have a prefix "n" (naming convention NC0014), e.g. "n Var1". • Function block names must start with "FB_" (naming convention NC0103), e.g. "FB_Sample". For the code shown below, the static analysis then only issues messages for the following variables: c Var, a Variable, b Variable. PROGRAM MAIN VAR {attribute 'naming' := 'off'} a Var : INT; b Var : INT; {attribute 'naming' := 'on'} c Var : INT; {attribute 'naming' := 'omit'} d Var : INT; fb1 : Sample FB; fb2 : FB; END_VAR {attribute 'naming' := 'omit'} FUNCTION_BLOCK Sample FB … {attribute 'naming' := 'off'} FUNCTION_BLOCK FB VAR {attribute 'naming' := 'on'} a Variable : INT; b Variable : INT; … Attribute {attribute 'nameprefix' := '...'} The attribute {attribute 'nameprefix' := '...'} defines a prefix for variables of a structured data type. A naming convention then applies to the effect that identifiers for instances of this type must have this prefix. Insertion location: above the declaration of a structured data type Syntax: {attribute ‘nameprefix’ := '<prefix>'} Example: The following naming conventions are defined in the category Naming conventions [} 81] in the PLC project properties: • Variables of the type of a structure (NC0032): st • Structures (NC0151): ST_ Conversely, variables of the type "ST_Point" should not begin with the prefix "st", but with the prefix "pt". In the following sample, the statistic analysis will output a message for "a1" and "st1" of the type "ST_Point" because the variable names do not begin with "pt". For variables of the type "ST_Test", conversely, the prefix "st" is expected. TYPE ST_Test : STRUCT … END_STRUCT END_TYPE {attribute 'nameprefix' := 'pt'} TYPE ST_Point : STRUCT x : INT; y : INT; END_STRUCT END_TYPE 124 Version: 2.9.0 TE1200

## Page 125

Pragmas and attributes PROGRAM MAIN VAR a1 : ST_Point; // => Invalid variable name 'a1'. Expect prefix 'pt' st1 : ST_Point; // => Invalid variable name 'st1'. Expect prefix 'pt' pt1 : ST_Point; a2 : ST_Test; // => Invalid variable name 'a2'. Expect prefix 'st' st2 : ST_Test; pt2 : ST_Test; // => Invalid variable name 'st2'. Expect prefix 'st' END_VAR Attribute {attribute 'analysis:report-multiple-instance-calls'} The attribute {attribute 'analysis:report-multiple-instance-calls'} identifies a function block for a check for rule 105: Only function blocks with this attribute are checked to ascertain whether the instances of the function block are called several times. The attribute has no effect if rule 105 is disabled in the Rules [} 16] category in the PLC project properties. Insertion location: above the declaration of a function block Syntax: {attribute 'analysis:report-multiple-instance-calls'} Sample: In the following sample the static analysis will issue an error for fb2, since the instance is called more than once. Function block FB_Test1 without attribute: FUNCTION_BLOCK FB_Test1 … Function block FB_Test2 with attribute: {attribute 'analysis:report-multiple-instance-calls'} FUNCTION_BLOCK FB_Test2 … Program MAIN: PROGRAM MAIN VAR fb1 : FB_Test1; fb2 : FB_Test2; END_VAR fb1(); fb1(); fb2(); // => SA0105: Instance 'fb2' called more than once fb2(); // => SA0105: Instance 'fb2' called more than once TE1200 Version: 2.9.0 125

## Page 126

Constant propagation 7 Constant propagation Available from Twin CAT 3.1.4026.14 Static code analysis is based on constant propagation, the results of which are used for various checks. For example, it checks whether pointers are not equal to 0 or whether array indices are outside the valid range. They can effectively support static analysis if they know how this analysis works and where its limits lie. See also: 'Show constant propagation values for current editor' command [} 118] Constant propagation Static analysis attempts to determine the value of a variable based on its use. Sample: PROGRAM MAIN VAR x : INT; b Test : BOOL; END_VAR x := 99; IF x < 100 THEN b Test := TRUE; END_IF In the implementation in line 1, the constant propagation sets the value 99 for the variable x in order to use this value for further analyses. The analysis then recognizes that the expression in the subsequent IF statement is constantly TRUE. Locally performed constant propagation A value is only determined locally in the function block. It is irrelevant how an input is transferred. The results of function calls are also irrelevant. Sample: FUNCTION Func : BOOL VAR_INPUT b Test : BOOL; END_VAR IF b Test THEN Func := Other Func(TRUE); END_IF If the parameter b Test is set to TRUE for each call, this has no effect on the constant propagation. Even if Other Func(TRUE) always returns TRUE, this has no effect on the constant propagation. Only temporary variables have initial values Static local variables in programs and function blocks do not have an assumed initial value. The variables retain their values from the last call and can therefore be "anything" in principle. Local variables in functions and temporary variables have an initial value each time they are called. The constant propagation calculates with this initial value. Sample: PROGRAM MAIN VAR x : INT := 6; b Test : BOOL; END_VAR VAR_TEMP y : INT := 8; END_VAR 126 Version: 2.9.0 TE1200

## Page 127

Constant propagation b Test := x < y; The variable y will have the value 8 each time MAIN is executed. However, the variable x will not necessarily. Therefore, the constant propagation will only assume a value for y, but not for x. It is advisable to declare variables that are always written first and then read as temporary variables. Constant propagation determines value ranges for numerical data types To reduce complexity, a value range with upper and lower limits is determined for each variable. Sample: PROGRAM MAIN VAR x : INT := 6; b Test : BOOL; y : INT; END_VAR IF b Test THEN x := 1; ELSE x := 100; END_IF IF x = 77 THEN y := 13; END_IF The value range [1..100] is determined here for the variable x. As a result, the comparison x = 77 is not recognized as a constant expression in line 7, as 77 is within the value range. Recurring sophisticated expressions are not recognized as the same variable Sophisticated expressions may not have a value assigned. If such expressions occur more than once, it is helpful to introduce an auxiliary variable. Sample: PROGRAM MAIN VAR x : DINT; py : POINTER TO INT; y : INT; test Array : ARRAY [0..4] OF DINT; END_VAR IF py <> 0 THEN IF py^ >= 0 AND py^<= 4 THEN x := test Array[py^]; END_IF y := py^; IF y <= 0 AND y <=4 THEN x := test Array[y]; END_IF END_IF In line 3, an error is output for a possible access to a value via pointer, although the area to which the pointer points is checked. If the value is first copied into a local variable and its range is checked, then the constant propagation can determine the value range for this variable and allows access to the array in line 9. Branches For branches, individual branches are calculated separately. Value ranges from the individual ranges are then combined to form a new value range. Sample: IF func(TRUE) THEN x := 1; ELSE x := 10; END_IF TE1200 Version: 2.9.0 127

## Page 128

Constant propagation IF func(FALSE) THEN y := x; ELSE y := 2*x; END_IF In line 6, x has the range [1..10]. After line 11, y has the value range [1..20]. This results from the union of the two value ranges [1..10] and [2..20]. Conditions Sample: Conditions can restrict the value range of a variable in a code block. Several conditions can be combined. Mutually exclusive conditions can also result in an empty value range. IF y > 0 AND y < 10 THEN x := y; ELSE x:= 0; END_IF IF x < 0 THEN i := 99; END_IF y has the value range [1..9] in line 2. This results in the value range [0..9] for x in line 6. Combined with the condition x < 0, this results in an empty set of possible values in line 9 for x. The code is not accessible. The static analysis will report that the condition x < 0 always results in FALSE at this point. Loops The constant propagation will execute loops in the code until the values of the variables in the loop no longer change. It is assumed that a loop can be run through as often as required. The values determined so far are combined with the previous values. Variables that are changed within the loop have a successively growing range. The constant propagation does not assume all possible values for ranges, but only uses limits that occur in the code and also the values 0, 1, 2, 3 and 10, as these often play a role. The easiest way to illustrate the procedure is with an example. Sample: PROGRAM MAIN VAR x : DINT; i : DINT; y : DINT; END_VAR x := 0; y := 0; FOR i := 0 TO 5 DO x := x + 1; y := i; END_FOR The constant propagation knows the following about the loop: i, x, and y are 0 at the beginning of the first execution of the loop. The condition i <= 5 applies to the code in the loop. The condition i > 5 applies to the code after the loop. The constant propagation determines the following values for the variables in the loop: i x y [0..5] [0.. MAXDINT] [0..5] The following intermediate steps are carried out in detail: 128 Version: 2.9.0 TE1200

## Page 129

Constant propagation Run i x y 1 0 [0..1] 0 i was initialized with 0, y always gets the same values as i 2 [0..1] [0..2] [0..1] 6 [0..5] [0..6] [0..5] First, the range [0..6] is actually calculated for i. However, it is known that i < 5 is a condition. Therefore, the value for the code in the loop is limited to this value. 7 [0..5] [0..7] [0..5] 10 [0..5] [0..10] [0..5] x is always incremented. From 10, however, the value is "rounded up" to MAXDINT. 11 [0..5] [0.. MAXDINT] [0..5] MAXDINT + 1 results in MAXDINT from 11 From the 11th run, the values in the loop will no longer change. The propagation is finished. In addition, the following applies to the code after this loop: i = 6. The range [0..6] is determined in the loop and this is combined with the condition i > 5, which results in the exact value 6. TE1200 Version: 2.9.0 129

## Page 130

Quick Fix/Precompile 8 Quick Fix/Precompile Available from Twin CAT 3.1 Build 4026 Some rules from Static Analysis can already be checked during precompilation. For the detection of such rule violations no explicit execution of the Static Analysis is necessary, but the check already takes place on the basis of the precompile information during editing. The checking of a rule during precompilation takes place only if the rule is enabled in the Static Analysis settings. Precompile: Wavy underline and display in the message window When a rule violation occurs, it is immediately indicated by wavy underline in the declaration editor or in the ST editor. Additionally - as long as the editor is open - error messages or warnings appear in the message window in the category "Intelli Sense". These contain the note “(precompile)” before the rule number. Quick Fix commands In addition, for some rules that can be checked during precompilation, there is the possibility of a Quick Fix in the declaration editor and the ST editor. You can perform automatic, immediate error handling directly at the affected code positions. For quick error handling, click on the wavy underlined code in the editor and then click on the light bulb icon. Depending on the error, the following Quick Fix commands are offered: • Ignore error message/warning: The command causes pragmas or attributes to be automatically inserted into the code that exclude checking the associated rule for that line of code. • Ignore error message/warning globally for the POU: The command causes an attribute to be automatically inserted at the beginning of the declaration part of the programming object. Then a check of the associated rule for this programming object is excluded. • Disable checking: The command causes the checking of the associated rule to be disabled in the settings. • Fix error by suggesting to change ST code: Example for "SA0033: Unused variables": The declaration of the unused variables is removed from the declaration editor. Available rules Not available: Please note that the following rules cannot be checked during precompilation. • SA0004 • SA0006 • SA0013 • SA0016 • SA0027 • SA0028 • SA0042 • SA0100 • SA0103 • SA0105 • SA0150 • SA0160 • SA0161 130 Version: 2.9.0 TE1200

## Page 131

Quick Fix/Precompile • SA0175 Available: All other rules are checked on the basis of the precompile information. TE1200 Version: 2.9.0 131

## Page 132

Automation Interface support 9 Automation Interface support The Static Analysis can partly be operated via the Automation Interface (AI). AI support includes the following commands/actions: • Explicit execution of Static Analysis via the Automation Interface [} 132] • Implicit execution of Static Analysis via the Automation Interface [} 132] • Save settings/configuration via Automation Interface [} 132] • Load settings/configuration via Automation Interface [} 133] • Export metrics [} 133] Please also refer to the Automation Interface documentation: Product description Explicit execution of Static Analysis via the Automation Interface The two following commands can be called explicitly via the Automation Interface: • Command 'Run static analysis' [} 111] • Command 'Run static analysis [Check all objects]' [} 113] b Check All can be specified as optional parameter for the method Run Static Analysis(). However, the method can also be called without parameters. Parameter Call Run Static Analysis() Execution of the Run static analysis [Check all objects] command Run Static Analysis(b Check All = TRUE) Run Static Analysis(b Check All = FALSE) Execution of the Run static analysis command Power Shell sample: $p = $sys Man. Lookup Tree Item("TIPC^My Plc Project^My Plc Project Project") $p. Run Static Analysis() C# sample for TC3.1 version >= Build 4024: ITc Plc IECProject3 plc Iec3 = sys Man. Lookup Tree Item("TIPC^Untitled1^Untitled1 Project") as ITc Plc IECProject3; plc Iec3. Run Static Analysis(); C# sample for TC3.1 version >= Build 4026: ITc Plc IECProject4 plc Iec4 = sys Man. Lookup Tree Item("TIPC^Untitled1^Untitled1 Project") as ITc Plc IECProject4; plc Iec4. Run Static Analysis(); Implicit execution of Static Analysis via the Automation Interface Alternatively, the setting [} 14] Perform static analysis automatically can be enabled, and the project can be created via the Automation Interface, so that the Static Analysis is implicitly performed during the project creation process. Save settings/configuration via Automation Interface Available from Twin CAT 3.1 Build 4026 The settings [} 14] from Static Analysis can be saved or exported to a *.csa file via Automation Interface. For the method Save Static Analysis Settings(string bstr Filename) the destination path of the file must be specified as a transfer parameter. 132 Version: 2.9.0 TE1200

## Page 133

Automation Interface support The Run Static Analysis method is available from the ITc Plc IECProject3 interface. The methods Save Static Analysis Settings and Load Static Analysis Settings are offered from the interface ITc Plc IECProject4. C# sample for TC3.1 version >= Build 4026: // Path to the location to export the SAN configuration string save Csa Path = @"C:\Users\User Name\Desktop\Save Test.csa"; […] // Navigate to PLC project ITc Plc IECProject4 plc Iec4 = sys Man. Lookup Tree Item("TIPC^Untitled1^Untitled1 Project") as ITc Plc IECProject4; // Save SAN configuration plc Iec4. Save Static Analysis Settings(save Csa Path); Load settings/configuration via Automation Interface Available from Twin CAT 3.1 Build 4026 A ready-made Static Analysis configuration (*.csa file) can be loaded into the PLC project via Automation Interface. The settings [} 14] loaded by this can then be checked by AI by running the Static Analysis (see above). For the method Load Static Analysis Settings(string bstr Filename) the path of the file to be loaded must be specified as a transfer parameter. The Run Static Analysis method is available from the ITc Plc IECProject3 interface. The methods Save Static Analysis Settings and Load Static Analysis Settings are offered from the interface ITc Plc IECProject4. C# sample for TC3.1 version >= Build 4026: // Path to load a SAN configuration string load Csa Path = @"C:\Users\User Name\Desktop\Load Test.csa"; […] // Navigate to PLC project ITc Plc IECProject4 plc Iec4 = sys Man. Lookup Tree Item("TIPC^Untitled1^Untitled1 Project") as ITc Plc IECProject4; // Load SAN configuration plc Iec4. Load Static Analysis Settings(load Csa Path); // Optionally run SAN afterwards plc Iec4. Run Static Analysis(); Export metrics Available from Twin CAT 3.1 Build 4026.4 The standard metrics can be exported to a text file (*.csv) via the Automation Interface. A current calculation of the metrics is performed implicitly. If this process was executed manually, it would include the following two commands: • Command 'View Standard Metrics' [} 114] • Export table command, see Commands in the context menu of the 'Standard Metrics' view [} 115] For the Export Standard Metrics(string bstr Filename) method, the path that the export file is saved on must be specified as a parameter value. The Export Standard Metrics method is available from the ITc Plc IECProject5 interface. C# sample for TC3.1 version >= Build 4026.4: TE1200 Version: 2.9.0 133

## Page 134

Automation Interface support // Path to save the csv file string save Path = @"C:\Users\User Name\Desktop\Metrics.csv"; […] // Navigate to PLC project ITc Plc IECProject5 plc Iec5 = sys Man. Lookup Tree Item("TIPC^Untitled1^Untitled1 Project") as ITc Plc IECProject5; // Export standard metrics plc Iec5. Export Standard Metrics(save Path); 134 Version: 2.9.0 TE1200

## Page 135

Examples 10 Examples 10.1 Static analysis During execution of the static analysis [} 111], compliance with the coding rules [} 16], naming conventions [} 81] and forbidden symbols [} 110] is checked. The following section provides a sample for each of these aspects. 1) Coding rules In this sample some coding rules are configured as error. The violations of this coding rules are therefore reported as an error after the static analysis has been performed. Further information is shown in the following diagram. 2) Naming conventions The following naming conventions are configured: • Prefix "b" for variables of type BOOL (NC0003) • Prefix "fb" for function block instances (NC0031) • Prefix "FB_" for function blocks (NC0103) • Prefix "I_" for interfaces (NC0108) This naming conventions are not adhered to in the declaration of Boolean variables ("x"), the instantiation of function block ("f") and the declaration of the interface type ("ITF_"). These code positions are reported as an error after the static analysis has been performed. TE1200 Version: 2.9.0 135

## Page 136

Examples 3) Forbidden symbols The bit string operator XOR and the bit shift-operators SHL, SHR, ROL and ROR are configured as forbidden symbols. These operators should not be used in the code. Accordingly, any use of these operators is reported as an error after the static analysis has been performed. 10.2 Standard metrics A sample for dealing with the standard metrics is provided below. In this sample "650" (= 650 bytes) is defined as upper limit for the metric "code size" and "5" as upper limit for the metric "number of input variables" (see: Configuration of the metrics [} 94]). In addition, rule 150 (SA0150: Violation of lower or upper metrics limits) is enabled and configured as warning. When the command 'View Standard Metrics' [} 114] is issued, the metric view opens and the indicators that were determined are displayed in tabular form. Since the size of the MAIN program is 688 bytes and the program Sample Program has 7 input variables, these indicators exceed the defined upper limit in each case, so that the corresponding table cells are shown in red. In this sample, the fact that the defined upper limits are exceeded is not only apparent in the metric view. Since rule 150 is configured as warning, the static analysis checks for violations of lower and upper metric limits. After the static analysis [} 111] has been performed, the violation of the two upper limits is therefore reported as a warning in the message window. 136 Version: 2.9.0 TE1200

## Page 137

Examples TE1200 Version: 2.9.0 137

## Page 138

Support and Service 11 Support and Service Beckhoff and their partners around the world offer comprehensive support and service, making available fast and competent assistance with all questions related to Beckhoff products and system solutions. Download finder Our download finder contains all the files that we offer you for downloading. You will find application reports, technical documentation, technical drawings, configuration files and much more. The downloads are available in various formats. Beckhoff's branch offices and representatives Please contact your Beckhoff branch office or representative for local support and service on Beckhoff products! The addresses of Beckhoff's branch offices and representatives round the world can be found on our internet page: www.beckhoff.com You will also find further documentation for Beckhoff components there. Beckhoff Support Support offers you comprehensive technical assistance, helping you not only with the application of individual Beckhoff products, but also with other, wide-ranging services: • support • design, programming and commissioning of complex automation systems • and extensive training program for Beckhoff system components Hotline: +49 5246 963-157 e-mail: support@beckhoff.com Beckhoff Service The Beckhoff Service Center supports you in all matters of after-sales service: • on-site service • repair service • spare parts service • hotline service Hotline: +49 5246 963-460 e-mail: service@beckhoff.com Beckhoff Headquarters Beckhoff Automation Gmb H & Co. KG Huelshorstweg 20 33415 Verl Germany Phone: +49 5246 963-0 e-mail: info@beckhoff.com web: www.beckhoff.com 138 Version: 2.9.0 TE1200

## Page 139

Trademark statements Beckhoff®, Twin CAT®, Twin CAT/BSD®, TC/BSD®, Ether CAT®, Ether CAT G®, Ether CAT G10®, Ether CAT P®, Safety over Ether CAT®, Twin SAFE®, XFC®, XTS® and XPlanar® are registered trademarks of and licensed by Beckhoff Automation Gmb H. Third-party trademark statements Arm, Arm9 and Cortex are trademarks or registered trademarks of Arm Limited (or its subsidiaries or affiliates) in the US and/or elsewhere. Intel, the Intel logo, Intel Core, Xeon, Intel Atom, Celeron and Pentium are trademarks of Intel Corporation or its subsidiaries. Microsoft, Microsoft Azure, Microsoft Edge, Power Shell, Visual Studio, Windows and Xbox are trademarks of the Microsoft group of companies.

## Page 140

More Information: www.beckhoff.com/te1200 Beckhoff Automation Gmb H & Co. KG Hülshorstweg 20 33415 Verl Germany Phone: +49 5246 9630 info@beckhoff.com www.beckhoff.com
