---
title: "Twin CAT 3 C/C++ 2025-10-22"
product: "TE1000"
category: "Engineering_Tools"
tags: ["CAT", "TWIN"]
language: "EN"
document_type: "Manual"
version: "1.18.0"
source_pdf: "https://download.beckhoff.com/download/Document/automation/twincat3/TE1000_TC3_C_EN.pdf"
release_date: "2025-10-22"
---
Manual | EN Twin CAT 3 C/C++ 2025-10-22 | Version: 1.18.0

## Page 3

Table of contents Table of contents 1 Foreword.................................................................................................................................................... 9 1.1 Notes on the documentation............................................................................................................. 9 1.2 For your safety.................................................................................................................................. 9 1.3 Notes on information security.......................................................................................................... 11 1.4 Documentation issue status............................................................................................................ 11 2 Overview.................................................................................................................................................. 12 3 Introduction............................................................................................................................................. 13 3.1 Difference between user mode and real time programming........................................................... 15 4 Installation............................................................................................................................................... 21 4.1 System requirements...................................................................................................................... 21 4.2 Installation....................................................................................................................................... 21 5 Preparation - only once.......................................................................................................................... 23 5.1 Visual Studio - Twin CAT XAE Base toolbar.................................................................................... 23 5.2 Module signing................................................................................................................................ 23 5.2.1 Twin CAT.......................................................................................................................... 24 5.2.2 Operating system............................................................................................................. 33 6 Modules.................................................................................................................................................... 38 6.1 The Twin CAT Component Object Model (Tc COM) concept........................................................... 38 6.1.1 Twin CAT module properties............................................................................................. 40 6.1.2 Twin CAT module state machine...................................................................................... 47 6.2 Module-to-module communication.................................................................................................. 49 7 Modules - Handling................................................................................................................................. 52 7.1 Versioned C++ Projects.................................................................................................................. 52 7.2 Starting Modules............................................................................................................................. 53 7.3 Twin CAT Loader............................................................................................................................. 53 7.3.1 Test signing...................................................................................................................... 54 7.3.2 Encrypting Modules.......................................................................................................... 56 7.3.3 Return Codes................................................................................................................... 57 7.3.4 Tc Sign Tool - Storage of the certificate password outside the project.............................. 58 8 Twin CAT C++ development.................................................................................................................... 59 9 Quick Start............................................................................................................................................... 61 9.1 Create Twin CAT 3 project............................................................................................................... 61 9.2 Create Twin CAT 3 C++ project....................................................................................................... 62 9.3 Twin CAT 3 C++ Configure project.................................................................................................. 66 9.4 Implement Twin CAT 3 C++ project................................................................................................. 67 9.5 Publish Twin CAT 3 C++ project in version 0.0.0.1.......................................................................... 69 9.6 Implement and publish Twin CAT 3 C++ project version 0.0.0.2..................................................... 69 9.7 Create Twin CAT 3 C++ Module instance........................................................................................ 71 9.8 Twin CAT 3 enable C++ debugger................................................................................................... 73 9.9 Create a Twin CAT task and apply it to the module instance.......................................................... 74 9.10 Activating a Twin CAT 3 project....................................................................................................... 76 9.11 Twin CAT 3 C++ Implement project Online Change........................................................................ 77 Twin CAT 3 Version: 1.18.0 3

## Page 4

Table of contents 10 Debugging................................................................................................................................................ 78 10.1 Details of Conditional Breakpoints.................................................................................................. 81 10.2 Visual Studio tools........................................................................................................................... 82 10.3 Working with Twin CAT Task Dumps............................................................................................... 84 10.4 Debugging the state machine with the Usermode Runtime............................................................ 85 11 Wizards.................................................................................................................................................... 87 11.1 Twin CAT C++ Project Wizard......................................................................................................... 87 11.2 Twin CAT Module Class Wizard...................................................................................................... 88 11.3 Twin CAT Module Class Editor (TMC)............................................................................................. 90 11.3.1 Overview.......................................................................................................................... 92 11.3.2 Basic Information............................................................................................................. 93 11.3.3 Data Types....................................................................................................................... 93 11.3.4 Modules.......................................................................................................................... 111 11.4 Twin CAT Module Instance Configurator....................................................................................... 133 11.4.1 Object............................................................................................................................. 134 11.4.2 Context........................................................................................................................... 135 11.4.3 Parameter (Init).............................................................................................................. 135 11.4.4 Data Area....................................................................................................................... 136 11.4.5 Interfaces....................................................................................................................... 136 11.4.6 Interface Pointer............................................................................................................. 136 11.4.7 Data Pointer................................................................................................................... 136 11.5 Customer-specific project templates............................................................................................. 137 11.5.1 Overview........................................................................................................................ 137 11.5.2 Files involved................................................................................................................. 138 11.5.3 Transformations............................................................................................................. 138 11.5.4 Notes on handling.......................................................................................................... 140 12 Programming Reference...................................................................................................................... 143 12.1 Twin CAT C++ Project properties.................................................................................................. 144 12.1.1 Tc SDK........................................................................................................................... 146 12.1.2 Tc Extract Version.......................................................................................................... 147 12.1.3 Tc Publish...................................................................................................................... 147 12.1.4 Tc Sign........................................................................................................................... 148 12.2 File Description............................................................................................................................. 149 12.3 Online Change.............................................................................................................................. 152 12.4 Limitations..................................................................................................................................... 153 12.5 Memory allocation......................................................................................................................... 154 12.6 Static variables.............................................................................................................................. 156 12.7 Multi-task data access synchronization......................................................................................... 157 12.7.1 Critical Sections.............................................................................................................. 158 12.7.2 Semaphores................................................................................................................... 160 12.7.3 FIFO template classes................................................................................................... 161 12.8 Interfaces...................................................................................................................................... 162 12.8.1 Interface ITc Post Cyclic Caller......................................................................................... 163 12.8.2 Return values................................................................................................................. 165 12.8.3 Interface ITc Cyclic.......................................................................................................... 166 4 Version: 1.18.0 Twin CAT 3

## Page 5

Table of contents 12.8.4 Interface ITc Cyclic Caller................................................................................................ 166 12.8.5 Interface ITc File Access.................................................................................................. 168 12.8.6 Interface ITc File Access Async........................................................................................ 175 12.8.7 Interface ITc Io Cyclic....................................................................................................... 176 12.8.8 Interface ITc Io Cyclic Caller............................................................................................. 178 12.8.9 ITCom Online Change interface....................................................................................... 180 12.8.10 ITCom Object interface................................................................................................... 181 12.8.11 ITCom Object interface (C++ convenience).................................................................... 185 12.8.12 Interface ITc Post Cyclic.................................................................................................. 186 12.8.13 Interface ITc RTime Task................................................................................................. 187 12.8.14 Interface ITc Task........................................................................................................... 188 12.8.15 Interface ITc Task Notification.......................................................................................... 191 12.8.16 Interface ITc Unknown.................................................................................................... 191 12.9 Runtime Library (Rtl R0.h)............................................................................................................. 193 12.10 ADS Communication..................................................................................................................... 194 12.10.1 Ads Read Device Info....................................................................................................... 195 12.10.2 Ads Read........................................................................................................................ 197 12.10.3 Ads Write......................................................................................................................... 199 12.10.4 Ads Read Write................................................................................................................ 201 12.10.5 Ads Read State................................................................................................................ 203 12.10.6 Ads Write Control............................................................................................................. 205 12.10.7 Ads Add Device Notification.............................................................................................. 207 12.10.8 Ads Del Device Notification............................................................................................... 209 12.10.9 Ads Device Notification.................................................................................................... 210 12.11 Mathematical Functions................................................................................................................ 212 12.12 Time Functions.............................................................................................................................. 214 12.13 STL / Containers........................................................................................................................... 215 12.14 Error messages - understanding................................................................................................... 215 12.15 Module messages for the Engineering (logging / tracing)............................................................. 216 13 How to...?............................................................................................................................................... 220 13.1 Using the Automation Interface..................................................................................................... 220 13.2 Windows 10 as target system up to Twin CAT 3.1 Build 4022.2................................................... 220 13.3 Publishing modules on the command line..................................................................................... 220 13.4 Clone............................................................................................................................................. 220 13.5 Access Variables via ADS............................................................................................................. 221 13.6 Tc Call After Output Update for C++ modules.................................................................................. 221 13.7 Order determination of the execution in a task............................................................................. 221 13.8 Setting version/vendor information................................................................................................ 222 13.9 Renaming Twin CAT C++ projects................................................................................................. 223 13.10 Delete Module............................................................................................................................... 226 13.11 Add revision control and Online Change subsequently................................................................ 227 13.11.1 C++ Project -> Revision control..................................................................................... 227 13.11.2 C++ Module -> Online Change....................................................................................... 230 13.12 Initialization of TMC-member variables......................................................................................... 235 13.13 Using PLC strings as method parameters.................................................................................... 235 13.14 Third Party Libraries...................................................................................................................... 236 Twin CAT 3 Version: 1.18.0 5

## Page 6

Table of contents 13.15 Linking via TMC editor (Tc Link To)................................................................................................ 236 13.16 Online Change per ADS................................................................................................................ 238 14 Troubleshooting.................................................................................................................................... 240 14.1 Build - "The target ... does not exist in the project"....................................................................... 240 14.2 Debug - "Unable to attach"............................................................................................................ 240 14.3 Activation – “invalid object id” (1821/0x71d)................................................................................. 241 14.4 Using C++ classes in Twin CAT C++ module................................................................................ 242 15 C++-samples.......................................................................................................................................... 243 15.1 Sample01: Cyclic module with IO................................................................................................. 247 15.2 Sample02: Cyclic C++ logic, which uses IO from the IO Task...................................................... 247 15.3 Sample03: C++ as ADS server..................................................................................................... 248 15.3.1 Sample03: TC3 ADS Server written in C++................................................................... 249 15.3.2 Sample03: ADS client UI in C#...................................................................................... 253 15.4 Sample05: C++ Co E access via ADS........................................................................................... 257 15.5 Sample06: UI-C#-ADS client uploading the symbolic from module.............................................. 258 15.6 Sample07: Receiving ADS Notifications....................................................................................... 263 15.7 Sample08: provision of ADS-RPC................................................................................................ 264 15.8 Sample10: module communication: Using data pointer................................................................ 267 15.9 Sample11: Module communication: method call PLC module to C++ module............................. 268 15.9.1 Twin CAT 3 C++ module providing methods.................................................................. 269 15.9.2 Calling methods offered by another module via PLC..................................................... 283 15.10 Sample11a: Module communication: Method call C++ module to C++ module........................... 295 15.11 Sample12: module communication: Using IO mapping................................................................ 296 15.12 Sample13: Module communication: Method call C++ module to PLC module............................. 297 15.13 Sample19: Synchronous File Access............................................................................................ 300 15.14 Sample20: File IO-Write................................................................................................................. 301 15.15 Sample20a: File IO-Cyclic Read / Write......................................................................................... 301 15.16 Sample22: Automation Device Driver (ADD): Access DPRAM..................................................... 303 15.17 Sample23: Structured Exception Handling (SEH)......................................................................... 304 15.18 Sample24: Semaphores................................................................................................................ 306 15.19 Sample25: Static Library............................................................................................................... 307 15.20 Sample26: Order of execution in a task........................................................................................ 309 15.21 Sample30: Timing Measurement.................................................................................................. 311 15.22 Sample31: Functionblock TON in Twin CAT3 C++........................................................................ 312 15.23 Sample35: Access Ethernet.......................................................................................................... 313 15.24 Sample37: Archive data................................................................................................................ 314 15.25 Tc COM samples............................................................................................................................ 315 15.25.1 Tc COM_Sample01_Plc To Plc........................................................................................ 315 15.25.2 Tc COM_Sample02_Plc To Cpp....................................................................................... 325 15.25.3 Tc COM_Sample03_Plc Creates Cpp.............................................................................. 329 16 Appendix................................................................................................................................................ 334 16.1 ADS Return Codes........................................................................................................................ 334 16.2 Retain data.................................................................................................................................... 338 16.3 Creating and handling C++ projects and modules........................................................................ 341 16.4 Creating and handling Tc COM modules....................................................................................... 344 6 Version: 1.18.0 Twin CAT 3

## Page 7

Table of contents 16.5 Third-party components................................................................................................................ 349 Twin CAT 3 Version: 1.18.0 7

## Page 8

Table of contents 8 Version: 1.18.0 Twin CAT 3

## Page 9

Foreword 1 Foreword 1.1 Notes on the documentation This description is intended exclusively for trained specialists in control and automation technology who are familiar with the applicable national standards. The documentation and the following notes and explanations must be complied with when installing and commissioning the components. The trained specialists must always use the current valid documentation. The trained specialists must ensure that the application and use of the products described is in line with all safety requirements, including all relevant laws, regulations, guidelines, and standards. Disclaimer The documentation has been compiled with care. The products described are, however, constantly under development. We reserve the right to revise and change the documentation at any time and without notice. Claims to modify products that have already been supplied may not be made on the basis of the data, diagrams, and descriptions in this documentation. Trademarks Beckhoff®, ATRO® , Ether CAT®, Ether CAT G®, Ether CAT G10®, Ether CAT P®, MX-System®, Safety over Ether CAT®, TC/BSD®, Twin CAT®, Twin CAT/BSD®, Twin SAFE®, XFC®, XPlanar®, and XTS® are registered and licensed trademarks of Beckhoff Automation Gmb H. If third parties make use of the designations or trademarks contained in this publication for their own purposes, this could infringe upon the rights of the owners of the said designations. Ether CAT® is a registered trademark and patented technology, licensed by Beckhoff Automation Gmb H, Germany. Copyright © Beckhoff Automation Gmb H & Co. KG, Germany. The distribution and reproduction of this document, as well as the use and communication of its contents without express authorization, are prohibited. Offenders will be held liable for the payment of damages. All rights reserved in the event that a patent, utility model, or design are registered. Third-party trademarks Trademarks of third parties may be used in this documentation. You can find the trademark notices here: https://www.beckhoff.com/trademarks. 1.2 For your safety Safety regulations Read the following explanations for your safety. Always observe and follow product-specific safety instructions, which you may find at the appropriate places in this document. Exclusion of liability All the components are supplied in particular hardware and software configurations which are appropriate for the application. Modifications to hardware or software configurations other than those described in the documentation are not permitted, and nullify the liability of Beckhoff Automation Gmb H & Co. KG. Twin CAT 3 Version: 1.18.0 9

## Page 10

Foreword Personnel qualification This description is only intended for trained specialists in control, automation, and drive technology who are familiar with the applicable national standards. Signal words The signal words used in the documentation are classified below. In order to prevent injury and damage to persons and property, read and follow the safety and warning notices. Personal injury warnings DANGER Hazard with high risk of death or serious injury. WARNING Hazard with medium risk of death or serious injury. CAUTION There is a low-risk hazard that could result in medium or minor injury. Warning of damage to property or environment NOTICE The environment, equipment, or data may be damaged. Information on handling the product This information includes, for example: recommendations for action, assistance or further information on the product. 10 Version: 1.18.0 Twin CAT 3

## Page 11

Foreword 1.3 Notes on information security The products of Beckhoff Automation Gmb H & Co. KG (Beckhoff), insofar as they can be accessed online, are equipped with security functions that support the secure operation of plants, systems, machines and networks. Despite the security functions, the creation, implementation and constant updating of a holistic security concept for the operation are necessary to protect the respective plant, system, machine and networks against cyber threats. The products sold by Beckhoff are only part of the overall security concept. The customer is responsible for preventing unauthorized access by third parties to its equipment, systems, machines and networks. The latter should be connected to the corporate network or the Internet only if appropriate protective measures have been set up. In addition, the recommendations from Beckhoff regarding appropriate protective measures should be observed. Further information regarding information security and industrial security can be found in our https://www.beckhoff.com/secguide. Beckhoff products and solutions undergo continuous further development. This also applies to security functions. In light of this continuous further development, Beckhoff expressly recommends that the products are kept up to date at all times and that updates are installed for the products once they have been made available. Using outdated or unsupported product versions can increase the risk of cyber threats. To stay informed about information security for Beckhoff products, subscribe to the RSS feed at https:// www.beckhoff.com/secinfo. 1.4 Documentation issue status Version Change 1.18.x New: Working with Twin CAT Task Dumps [} 84] Installation [} 21] Online Change per ADS [} 238] Third-party components [} 349] Twin CAT 3 Version: 1.18.0 11

## Page 12

Overview 2 Overview This chapter deals with the implementation of Twin CAT 3 in C/C++. The most important chapters are: • Basics Which platforms are supported? Are additional programs required to implement Twin CAT 3 C++ modules? The answers can be found in Requirements [} 21] and Preparation [} 23], the following limitations [} 153] apply. • Quick start [} 61] This is a "less than five minute example" to implement a simple, cyclic counter in C++. The counter value is monitored and overwritten, debugging options are described, etc. • MODULE [} 40] Modularity is the basic philosophy of Twin CAT 3. An understanding of the modular concept of Twin CAT 3 is the basic requirement, especially for C++ modules. Basic knowledge of the architecture of Twin CAT modules is required. • Wizards [} 87] Documentation of the visual components of the Twin CAT C++ environment. This includes tools for creating projects and tools for editing modules and configuring module instances. • Programming reference [} 143] This chapter contains detailed information on programming in Twin CAT C++. Here you will find interfaces and other Twin CAT functions for ADS communication and auxiliary methods. • The "How to ...? [} 220]" chapter contains useful tips for working with Twin CAT C++. • Samples Some interfaces and their use are described in detail in the form of an executable program, which is provided as a download with source code and solution. 12 Version: 1.18.0 Twin CAT 3

## Page 13

Introduction 3 Introduction The method of emulating classic automation devices such as programmable logic controllers (PLC) and numerical controllers (NC) as software on powerful standard hardware has been the state of the art for many years and is now practiced by many manufacturers. There are many benefits, but the most important is without doubt the fact that the software is mostly hardware-independent. This means, firstly, that the performance of the hardware can be specially adapted to the application and, secondly, that you can automatically benefit from its further development. This particularly applies to PC hardware, whose performance is still increasingly at a dramatically fast rate. The relative independence from a supplier that results from this separation of software and hardware is also very important for the user. Since the PLC and Motion Control – and possibly other automation components – remain independent logic function blocks with this method, there are only a few changes in the application architecture in comparison with classic automation technology. The PLC determines the machine's logical processes and transfers the implementation of certain axis functions to the Motion Control. On account of the improved performance of the controllers and the possibility to use higher-level programming languages (IEC 61131-3), even complex machines can be automated in this way. Modularization In order to master the complexity of modern machines and at the same time to reduce the necessary engineering expenditure, many machine manufacturers have begun to modularize their machines. Individual functions, assemblies or machine units are thereby regarded as modules, which are as independent as possible and are embedded into the overall system via uniform interfaces. Ideally a machine is then structured hierarchically, whereby the lowest modules represent the simplest, continually reusable basic elements. Joined together they form increasingly complex machine units, up to the highest level where the entire machine is created. Different approaches are followed when it comes to the control system aspects of machine modularization. These can be roughly divided into a decentralized and a centralized approach. In the local approach, each machine module is given its own controller, which determines the PLC functions and possibly also the motion functions of the module. The individual modules can be put into operation and maintained separately from one another and scaled relatively independently. The necessary interactions between the controllers are coordinated via communication networks (fieldbuses or Ethernet) and standardized via appropriate profiles. The central approach concentrates all control functions of all modules in the common controller and uses only very little pre-processing intelligence in the local I/O devices. The interactions can occur much more directly within the central control unit, as the communication paths become much shorter. Dead times do not occur and use of the control hardware is much more balanced, which reduces overall costs. However, the central method also has the disadvantage that the necessary modularization of the control software is not automatically specified. At the same time, the possibility of being able to access any information from other parts of the program in the central controller obstructs the module formation and the reusability of this control software in other applications. Since no communication channel exists between the control units, an appropriate profile formation and standardization of the control units frequently fall by the wayside. The best of both worlds The ideal controller for modular machines uses elements from decentralized and centralized control architecture. A central, powerful computer platform of the most general kind possible serves 'as always' as the control hardware. The benefits of centralized control technology: • low overall costs • available Twin CAT 3 Version: 1.18.0 13

## Page 14

Introduction • fast, modular fieldbus system (keyword: Ether CAT) • and the possibility to access all information in the system without loss of communication are decisive arguments. The above-mentioned benefits of a decentralized approach can be implemented in the centralized control system by means of suitable modularization of the control software. Instead of allowing a large, complex PLC program and an NC with many axes to run, many small ‘controllers’ can co-exist in a common runtime on the same hardware with relative independence from one another. The individual control modules are self-contained and make their functions available to the environment via standard interfaces, or they use corresponding functions of other modules or the runtime. A significant profile is created through the definition of these interfaces and the standardization of the corresponding parameters and process data. Since the individual modules are implemented in a runtime, direct calls of other modules are also possible – once again via corresponding standard interfaces. In this way the modularization can take place within sensible limits without communication losses occurring. During the development or commissioning of individual machine modules, the associated control modules can be created and tested on any control hardware with the appropriate runtime. Missing connections to other modules can be emulated during this phase. On the complete machine they are then instanced together on the central runtime, which only needs to be dimensioned such that the resource requirements of all instanced modules (memory, tasks and computing power) are fulfilled. Twin CAT 3 runtime Twin CAT Runtime offers a software environment in which the Twin CAT modules are loaded, implemented and managed. It provides more basic functions so that system resources (memory, tasks, fieldbus and hardware access, etc.) can be used. The individual modules must not have been created with the same compiler. This means that they can be independent of each other and come from different suppliers. When the runtime starts, some system modules are automatically loaded so that their properties are available to other modules. However, the properties of the system modules are accessed in the same way as the properties of normal modules, so it does not matter to the modules whether the respective property is provided by a system module or a normal module. 14 Version: 1.18.0 Twin CAT 3

## Page 15

Introduction Unlike the PLC, where the user-defined program is executed in a runtime environment, Twin CAT C++ modules are not in such a hosted environment. This causes Twin CAT C++ modules (.tmx) to be executed as kernel modules, which are loaded by Twin CAT. 3.1 Difference between user mode and real time programming This article describes the conceptual differences between standard user mode programming in a programming language such as C++, C# or Java, and real-time programming in Twin CAT. The article particularly focuses on real-time programming with Twin CAT C++, because this is where previous knowledge with C++ programming comes to the fore and the sequence characteristics of the Twin CAT real- time system have to be taken into account. Twin CAT 3 Version: 1.18.0 15

## Page 16

Introduction With conventional user mode programming, e.g. in C#, a program is created, which is then executed by an operating system. The program is started by the operating system and can run independently, i.e. it has full control over its own execution, including aspects such as threading and memory management. In order to enable multitasking, the operating system interrupts such a program at any time and for any period. The program does not register such an interruption. The operating system must ensure that such interruptions remain unnoticed by the user. The data exchange between the program and its environment is event-driven, i.e. non-deterministic and often blocking. 16 Version: 1.18.0 Twin CAT 3

## Page 17

Introduction The behavior is not adequate for execution under real-time conditions, because the application itself must be able to rely on the available resources in order to be able to ensure real-time characteristics (response guarantees). The basic idea of PLC is therefore adopted for Twin CAT C++: the Twin CAT real-time system manages the real-time tasks, handles the scheduling and cyclically calls an entry point in the program code. The program execution must be completed within the available cycle length and return the control. The Twin CAT system makes the data from the I/O area available in the process images, so that consistent access can be guaranteed. This means that the program code itself cannot use mechanisms such as threading. Twin CAT 3 Version: 1.18.0 17

## Page 18

Introduction Concurrency With conventional programming in user mode, concurrency is controlled by the program. This is where threads are started, which communicate with each other. All these mechanisms require resources, which have to be allocated and enabled, which can compromise the real-time capability. The communication between the threads is event-based, so that a calling thread has no control over the processing time in the called thread. In Twin CAT, tasks are used for calling modules, which therefore represents concurrency. Tasks are assigned to a core; they have cycle times and priorities, with the result that a higher-priority task can interrupt a lower-priority task. If several cores are used, tasks are executed concurrently in practice. 18 Version: 1.18.0 Twin CAT 3

## Page 19

Introduction Modules can communicate with each other, so that data consistency has to be ensured in concurrency mode. Data exchange across task boundaries is enabled through mapping, for example. When direct data access via methods is used, it must be protected through Critical sections, for example. Startup/shutdown behavior The Twin CAT C++ code is executed in the so-called "kernel context" and the "Twin CAT real-time context", not as a user mode application. During startup/shutdown of the modules, code for (de)initialization is initially executed in the kernel context; only the last phase and the cyclic calls are executed in the Twin CAT real-time context. Details are described in chapter Module state machine [} 47]. Memory management Twin CAT has its own memory management, which can also be used in the real-time context. This memory is obtained from what is referred to as the "non-paged pool", which is provided by the operating system. In this memory the Tc COM modules are instantiated with their memory requirement. In addition, the so-called "router memory" is provided by Twin CAT in this memory area, from which the Tc COM modules can allocate memory dynamically in the real-time context (e.g. with the New operator). Twin CAT 3 Version: 1.18.0 19

## Page 20

Introduction If possible, memory should generally be allocated in advance, not in the cyclic code. During each allocation a check is required to verify that the memory is actually available. For allocations in the cyclic code, the execution therefore depends on the memory availability. 20 Version: 1.18.0 Twin CAT 3

## Page 21

Installation 4 Installation 4.1 System requirements Engineering (XAE) Technical data Requirements Operating system Windows 10/11 Target platform x64 Twin CAT version Twin CAT 3.1 Build 4024 | Build 4026 Required Twin CAT license None (Visual Studio license from Microsoft) Runtime (XAR) Technical data Requirements Operating system Windows 10, Twin CAT/BSD Target platform x64 Twin CAT version Twin CAT 3.1 Build 4024 | Build 4026 Required Twin CAT license TC1300 4.2 Installation Engineering prerequisites Microsoft Visual Studio® Professional/Enterprise 2017, 2019 or 2022 must be installed on the engineering PC. In the Visual Studio® Installer, the Desktop development with C++ option must be selected, as this option is not selected in automatic installation: Twin CAT 3 Version: 1.18.0 21

## Page 22

Installation XAE Shell is sufficient for integrating and using existing binary C++ modules in a Twin CAT 3 PLC environment (Visual Studio® is not required). Runtime prerequisites Microsoft Visual Studio® does not have to be installed. • For Twin CAT 3.1 Build 4024.x: Twin CAT 3.1 XAR • For Twin CAT 3.1 Build 4026.x: Twin CAT Standard Runtime Twin CAT Package Manager: Installation (Twin CAT 3.1 Build 4026) Detailed instructions on installing products can be found in the chapter Installing workloads in the Twin CAT 3.1 Build 4026 installation instructions. Install the following workload to be able to use the product: TC1300 | Twin CAT 3 C/C++ Twin CAT setup: Installation (Twin CAT 3.1 Build 4024 and earlier) Is included in the Twin CAT 3.1 Full setup. Twin CAT/BSD: No installation necessary 22 Version: 1.18.0 Twin CAT 3

## Page 23

Preparation - only once 5 Preparation - only once A PC for the engineering of Twin CAT C++ modules must be prepared. You only have to carry out these steps once: • Configure the Twin CAT Basis [} 23] as well as the configuration and platform toolbar. • Sign modules so that they can be executed; see Documentation for setting up a test signing [} 23]. 5.1 Visual Studio - Twin CAT XAE Base toolbar Efficient engineering through Twin CAT XAE base toolbar Twin CAT 3 integrates its own toolbar in the Visual Studio menu for better efficiency. It assists you in the creation of C++ projects. This toolbar is automatically added to the Visual Studio menu by the Twin CAT 3 setup. If you wish to add it manually, however, do the following: 1. Open the View menu and select Toolbars\Twin CAT XAE Base ð The selected toolbar appears below the menu. 5.2 Module signing Twin CAT C++ modules must be signed with a certificate so that they can be executed. The signature ensures that only C++ software whose origin can be traced is executed on productive systems. The C++ modules are loaded by the Twin CAT runtime system and must be signed with a Twin CAT user certificate. For test purposes, certificates that cannot be verified can be used for signing. However, this is only possible if the operating system is in test mode so that these certificates are not used on productive systems. Engineering requires no signing Only the execution requires certificates - the engineering does not. Organizational separation of development and production software Beckhoff recommends working organizationally with (at least) two certificates. 1. A certificate which is not countersigned, thus the test mode is needed for the development process. This certificate can also be issued individually by each developer. The test systems are then set to test mode. 2. Only the software that has passed the corresponding final tests is signed by a countersigned certificate. This software can thus also be installed on machines and delivered. Twin CAT 3 Version: 1.18.0 23

## Page 24

Preparation - only once Such a separation of development and operation ensures that only tested software runs on productive systems. Also see about this 2 Online Change [} 152] 2 Versioned C++ Projects [} 52] 5.2.1 Twin CAT Versioned C++ projects are stored as binary in a TMX file (Twin CAT Module Executeable). For the implementation of Twin CAT 3 C++ modules, this compiled, executable TMX file must be signed with a Twin CAT user certificate if it is to be loaded by the Twin CAT Runtime. Signing Twin CAT TMX files can only be loaded after a successful signing. NOTICE Signing on 32-bit and 64-bit systems In contrast to the operating system signing, Twin CAT signing is intended for both 32-bit and 64-bit systems. Thus, the test mode is also assumed for a test signing on 32-bit systems. For signing a TMX file, a Twin CAT user certificate is required [} 24], which is configured accordingly in the project for signing [} 148]. Test signing The user certificate can be created locally in Twin CAT. As long as it is not countersigned by Beckhoff, it is necessary to activate the test mode [} 24]. As soon as the Twin CAT user certificate has been countersigned by Beckhoff [} 26], the test mode can be dispensed with accordingly. It can be deactivated in the same way as it is activated. 5.2.1.1 Test signing The test signing for Twin CAT can be carried out with the same Twin CAT user certificate as for the actual delivery (see Request Twin CAT 3 user certificate [} 27]). 24 Version: 1.18.0 Twin CAT 3

## Page 25

Preparation - only once 1. For test operation, e.g., during software development, it is sufficient to create a Twin CAT user certificate [} 28]. Make sure that you select the purpose "Sign Twin CAT C++ executable (*.tmx)". For this the Crypto version 2 is required, a message appears. On XAR (and XAE, if it is a local test), activate the test mode so that the operating system can accept the self-signed certificates. This can be done on both engineering systems (XAE) and runtime systems (XAR). For Windows Use the administrator prompt to execute the following: bcdedit /set testsigning yes and reboot the target system. You may have to switch off "Secure Boot" for this, which can be done in the bios. If test signing mode is enabled, this is displayed at the bottom right of the desktop. The system now accepts all signed drivers for execution. For Twin CAT/BSD In the file /usr/local/etc/Twin CAT/3.1/Tc Registry.xml enter "<Value Name="Enable Test Signing" Type="DW"1</Value>" under Key "System". <Key Name="System"> <Value Name="Run As Device" Type="DW">1</Value> <Value Name="RTime Mode" Type="DW">0</Value> Twin CAT 3 Version: 1.18.0 25

## Page 26

Preparation - only once <Value Name="Ams Net Id" Type="BIN">052445B00101</Value> <Value Name="Locked Mem Size" Type="DW">33554432</Value> <Value Name="Enable Test Signing" Type="DW">1</Value> </Key> Then restart the Twin CAT system service: doas service Tc System Service restart After the respective procedure, the system accepts all signed drivers for execution. 1. During the first activation (Activate Configuration) with a Twin CAT user certificate, the target system detects that the certificate is not trusted and the activation process is aborted: For Windows: A local user with administration rights can trust the certificate via the created REG file by simply executing it: For Twin CAT/BSD: If the "Tcimportcert" package is not installed, install it: pkg install tcimportcert Trust the certificate via doas tcimportcert /usr/local/etc/Twin CAT/3.1/Target/ Oem Certificates/<Created File>.reg. Then restart the Twin CAT System Service or reboot the system: doas service Tc System Service restart ð This process only enables C++ modules with a signature from the trusted Twin CAT user certificates to run. 2. Following this process you can use the Twin CAT user certificate for signing with the test mode of the operating system. This is configured in the project properties [} 148]. Use the Tc Sign Tool [} 58] to avoid storing the password of the Twin CAT user certificate in the project, where it would also end up in version management, for example. If you want to use the Twin CAT user certificate without Test Mode for delivery, you must have the certificate countersigned by Beckhoff [} 26]. 5.2.1.2 User certificates for delivery without test mode System requirements - Min. Twin CAT 3.1 Build 4024 - Min. Windows 10 or Twin CAT/BSD (on the target system) With Twin CAT Build 4024, Beckhoff offers existing customers the issuing of a "Twin CAT 3 OEM user certificate", which can be used for signing TMX files created with Twin CAT 3 in C++. 26 Version: 1.18.0 Twin CAT 3

## Page 27

Preparation - only once • This certificate requires secure validation of the applicant data, since it is used in the Windows environment. Twin CAT 3 user certificates must therefore be officially ordered for validation of the address and contact data, and are only issued to existing Beckhoff customers. • Order number: TC0008 • The issuing of this Twin CAT 3 user certificate is free of charge. • Directory for saving the certificate: C:\Twin CAT\3.1\Custom Config\Certificates The Twin CAT 3 user certificate is not required for using the Twin CAT 3 TMX files The Twin CAT 3 user certificate is used exclusively for the one-time signing of the TMX files and is not required for the use of the TMX files signed with it. On which computers is the Twin CAT 3 user certificate TC0008 required? The Twin CAT 3 user certificate should be located exclusively on the engineering computer on which the TMX files are signed - i.e. NOT on each target system. Validity of the Twin CAT 3 user certificate The validity of the Twin CAT 3 user certificate is limited to two years for security reasons. What happens if the certificate has expired? You can no longer sign new TMX files. However, the use of already signed TMX files is still possible without any restrictions. You can apply for a renewal of your certificate before the expiry of the two years (and even after that). To extend a Twin CAT 3 user certificate, the same process applies as for requesting a new certificate. In this case, the certificate must also be ordered (the order numbers for a certificate extension are the same as for a new certificate request). In contrast to a new certificate, you do not generate a new OEM Certificate Request File but send your existing certificate to the Beckhoff certificate section for renewal. Please notify us in the email that this is a certificate extension and not a new issue. Otherwise, the same criteria apply regarding the content of the email as for the application for a new certificate. The existing certificate receives a new expiration date, is then re-signed and is valid for another 2 years. The newly signed certificate is thus fully compatible with the original version. 5.2.1.2.1 Request Twin CAT 3 user certificate Overview of the ordering and validation process An official order is required to request a Twin CAT user certificate. • Order number: TC0008 (Twin CAT 3 Certificate Extended Validation) • The issuing (and renewal) of a Twin CAT 3 user certificate is free of charge. • Since a Twin CAT 3 user certificate is a digital ID card, verification of the inquirer's contact data is required according to the usual market standards. • A Twin CAT 3 user certificate is therefore only issued to existing Beckhoff customers. Overview of the ordering and validation process Your email address must be a company email account (freemailers such as GMail or similar are not permitted) and correspond with the company name of the inquirer. 1. Contact your Beckhoff sales contact and announce the request of a Twin CAT 3 OEM certificate. Order "TC0007" or "TC0008". Twin CAT 3 Version: 1.18.0 27

## Page 28

Preparation - only once 2. Important: as the inquirer, please provide your contact details as the delivery address (= contact name and email address) and the area of use of the certificate (company name, address). 3. The contact details provided in the order will be verified and you (the inquirer named in the delivery address) will be contacted by Beckhoff Sales. 4. When requesting a new OEM certificate, Creation of the Certificate Request file for TC0008 [} 28]. 5. Determine the "File Fingerprint" of the OEM certificate file using Twin CAT Engineering (see Determining the file fingerprint of the OEM certificate file [} 31]). Please inform the Beckhoff sales contact of this File Fingerprint as part of your contact data verification. The transmission of the File Fingerprint must be done by a different communication channel than the one used for sending the OEM certificate request file. 6. Now send the "OEM certificate file" to the Beckhoff sales contact. 7. After signing the certificate file at the Beckhoff headquarters, you will receive it by e-mail from your contact person. Please note that it may take a few days to validate your contact details and issue the certificate. 5.2.1.2.2 Creation of the Certificate Request file for TC0008 System requirements - Min. Twin CAT 3.1 Build 4024 - Min. Windows 10 or Twin CAT/BSD (on the target system) 1. Call up the Software Protection configurator. To do this, select the menu item Software Protection in the main menu below the item Twin CAT: 28 Version: 1.18.0 Twin CAT 3

## Page 29

Preparation - only once 2. In the window that opens, select the Certificates tab. Click Create New....: 3. The Create OEM Certificate input window opens: 4. Enter the required data: • Enter your company name in the OEM Name text field. The name must have a clear reference to your company or your business unit. Twin CAT 3 Version: 1.18.0 29

## Page 30

Preparation - only once • Enter a Unique Name. The "OEM Unique Name" must be a unique name that uniquely identifies the owner of the certificate worldwide, preferably the URL of your company's website or your email address. The email address must be a company email address, i.e. it must be possible to assign it unambiguously to your company. • Check the checkbox Sign Twin CAT C++ executables: If you only want to sign Twin CAT driver software with this certificate, uncheck the other two checkboxes. (These are only used in the PLC area) • Make sure that Crypto version 2 (for the encrypted content of the certificate content) is set. (default setting) 5. Once you have entered the data, click Start and select a directory to save the file. You can simply accept the suggested directory "c:\twincat\3.1\customconfig\certificates". You need the newly created file in this directory in order to be able to read out the "File Fingerprint" for this file [} 31] in a subsequent step. ð A dialog for selecting a password for the OEM Private Key opens. 6. Issue a password for the OEM Private Key. Password security - Be sure to use a strong password for your certificate! Take suitable measures to protect your password so that it cannot fall into the wrong hands! Password cannot be recovered if lost - Beckhoff cannot recover or reset your password. If you forget or lose the password for your certificate, you can no longer use it and have to request a new certificate. 30 Version: 1.18.0 Twin CAT 3

## Page 31

Preparation - only once 7. Confirm the password by entering it again and close the dialog with OK. ð The file is saved. The "Certificate Request File" generated in this way must now be signed by the Beckhoff certificate section in order to be valid. The procedure is described in chapter Requesting a certificate [} 27]. 5.2.1.2.3 Determining the file fingerprint of the OEM certificate file You need this functionality to request a Twin CAT OEM Certificate Extended Validation (TC0008). System requirements This functionality requires Twin CAT 3.1 Build 4024 of higher. The OEM Certificate Request File becomes the Twin CAT OEM certificate once it is signed by Beckhoff. The files do not differ except for this signature. For this reason, the term "Twin CAT OEM certificate file" is used for both file versions in the following sections. Reading the "file fingerprint" of an OEM certificate file via Twin CAT 3 Engineering For this function it is necessary that the OEM certificate file is located in this directory: "c: \twincat\3.1\customconfig\certificates". This directory contains your OEM certificate, if you already have a certificate and want to renew it. If you did not change the suggested directory when creating the "OEM Certificate Request File", the file is already in this directory. Procedure: Twin CAT 3 Version: 1.18.0 31

## Page 32

Preparation - only once 1. Call up the Twin CAT 3 Software Protection configurator. 2. Select the Certificates tab. 3. Check the Extended Info checkbox. 4. In the window scroll to the right until you see the Fingerprint column. (As an alternative, you can simply double-click the certificate line. The Fingerprint file is then displayed in a pop-up window: The shortcut [Ctrl] + [C] can be used to copy the fingerprint data from the message window to the Windows clipboard. 5.2.1.2.4 Saving the signed Twin CAT user certificate Recommended directory for saving the certificate: C:\Twin CAT\3.1\Custom Config\Certificates System requirements - Min. Twin CAT 3.1 Build 4024 - Min. Windows 10 or Twin CAT/BSD (on the target system) 32 Version: 1.18.0 Twin CAT 3

## Page 33

Preparation - only once The Twin CAT 3 user certificate is not required for using the Twin CAT 3 TMX files The Twin CAT 3 user certificate is used exclusively for the one-time signing of the TMX files and is not required for the use of the TMX files signed with it. On which computers is the Twin CAT 3 user certificate TC0008 required? The Twin CAT 3 user certificate should be located exclusively on the engineering computer on which the TMX files are signed - i.e. NOT on each target system. 5.2.2 Operating system NOTICE Migration to TMX with Twin CAT Loader recommended Since Twin CAT 3.1 4024.0 versioned C++ projects are available, whose binaries can be loaded directly from Twin CAT. Migration is recommended! For the implementation of Twin CAT 3 C++ modules on x64 platforms, the driver (*.sys file) must be signed with a certificate if it is to be loaded by the operating system. The signature, which is automatically executed during the Twin CAT 3 build process, is used by 64-bit Windows operating systems for the authentication of the drivers. A certificate is required to sign a driver. This Microsoft documentation describes the process and background knowledge for obtaining a test and release certificate that is accepted by 64-bit Windows operating systems. To use such a certificate in Twin CAT 3, configure the step after compiling your x64 build target as documented in "Creating a test certificate for test mode [} 33]". Test certificates For testing purposes, self-signed test certificates can be created and used without technical limitations. The following tutorials describe how to enable this option. To create drivers with real certificates for production machines, this option must be disabled. • Creating a test certificate for test mode [} 33] • Delete (test) certificates [} 35] Further references: MSDN, Make Cert test certificates (Windows drivers), https://docs.microsoft.com/en-us/windows-hardware/drivers/install/makecert-test-certificate 5.2.2.1 Test signing Overview Implementing Twin CAT 3 C++ modules for x64 platforms requires signing the driver with a certificate. This article describes how to create and install a test certificate for testing a C++ driver. Note the procedure when creating test certificates Developers may have a wide range of tools for creating certificates themselves. Please follow this description exactly to activate the test certificate mechanism. The following commands must be executed from a command line that has been opened in either way: Twin CAT 3 Version: 1.18.0 33

## Page 34

Preparation - only once • Command prompt from Microsoft Visual Studio® 2010 / 2012 with administrator rights. (Via: All Programs -> Microsoft Visual Studio 2010/2012 -> Visual Studio Tools -> Visual Studio Command Prompt, then right-click Run as administrator) • Developer Command Prompt from Microsoft Visual Studio® 2017 / 2019 with administrator rights.. (Via: All Programs -> Visual Studio 2017 -> Visual Studio Command Prompt for VS 2017/2019, then right-click on Run as administrator) • Only if the WINDDK has been installed: Normal prompt (Start ->Command Prompt) with administrator rights, then change to directory %WINDDK7%\bin\x86\, which contains the corresponding tools. 1. On XAE: In the engineering system, enter the following command in the Microsoft Visual Studio® 2010 / 2012 command prompt with administrator rights (see note above): makecert -r -pe -ss Private Cert Store -n CN=My Test Signing Cert My Test Signing Cert.cer (If you do not have access rights to the Private Cert Store, you can use a different storage location. This must also be used in the Post Build event [} 37].) ð This is followed by creation of a self-signed certificate, which is stored in the file "My Test Signing Cert.cer" and in the Windows Certificate Store. ð Check the result with mmc (Use File->Add/Remove Snap-in->Certificates): 2. On XAE: configure the certificate so that it is recognized by Twin CAT XAE on the engineering system. Set the environment variable TWINCATTESTCERTIFICATE to "My Test Signing Cert" in the engineering system or edit the post build event of Debug|Twin CAT RT (x64) and Release|Twin CAT RT (x64). The name of the variable is NOT the name of the certificate file, but the CN name (in this case My Test Signing Cert). From Twin CAT 3.1 4024.0, the configuration of the certificate to be used is carried out under Tc Sign in the project properties. To use signing via the operating system, as described here, please pay attention to the project settings. 34 Version: 1.18.0 Twin CAT 3

## Page 35

Preparation - only once On XAR (and XAE, if it is a local test), activate the test mode so that the operating system can accept the self-signed certificates. This can be done on both engineering systems (XAE) and runtime systems (XAR). For Windows Use the administrator prompt to execute the following: bcdedit /set testsigning yes and reboot the target system. You may have to switch off "Secure Boot" for this, which can be done in the bios. If test signing mode is enabled, this is displayed at the bottom right of the desktop. The system now accepts all signed drivers for execution. After the respective procedure, the system accepts all signed drivers for execution. 1. Test whether a configuration with a Twin CAT module implemented in a Twin CAT C++ driver can be enabled and started on the target system. ð Compilation of the x64 driver generates the following output: References: MSDN, Make Cert test certificates (Windows drivers), https://docs.microsoft.com/en-us/windows-hardware/drivers/install/makecert-test-certificate 5.2.2.2 Delete test certificate This article is about how to delete a test certificate. Overview A certificate can be deleted with the Microsoft Management Console: Twin CAT 3 Version: 1.18.0 35

## Page 36

Preparation - only once 1. Start the management console MMC.exe via the Start menu or the user interface. 2. Click in the menu on File -> Add/Remove Snap-in.. and select the certificate snap-in for the current user; conclude with OK. ð The certificates are listed in the node under Private Cert Store/Certificates. 36 Version: 1.18.0 Twin CAT 3

## Page 37

Preparation - only once 3. Select the certificate to be deleted. 5.2.2.3 Windows driver without test mode For Windows operating systems the driver has to be signed via "Attestation Signing". This requires an EV certificate. Microsoft provides relevant instructions: https://docs.microsoft.com/en-us/windows-hardware/drivers/ dashboard/attestation-signing-a-kernel-driver-for-public-release he drivers created in this way are also suitable for devices that have secure boot enabled. Microsoft announced that the previous procedure using Cross Signing certificates (signing tool with parameter /ac) will be discontinued from July 2021. It can no longer be used (depending on the expiry date of the individual Cross Signing certificate). Versioned C++ projects, which are loaded via the Twin CAT Loader [} 53], have been available for Twin CAT C++ for some time, so that they are not drivers in the sense of the operating system. Beckhoff therefore recommends using versioned C++ projects. A guide is available in the How-to section for the migration of Twin CAT C++ drivers to versioned C++ projects. Twin CAT 3 Version: 1.18.0 37

## Page 38

Modules 6 Modules The Twin CAT module concept is one of the core elements for the modularization of modern machines. This chapter describes the modular concept and working with modules. The modular concept applies to all Twin CAT modules, not just C++ modules, although most details only relate to the engineering of C++ modules. 6.1 The Twin CAT Component Object Model (Tc COM) concept The Twin CAT Component Object Model defines the characteristics and the behavior of the modules. The model derived from the "Component Object Model" COM from Microsoft Windows describes the way in which various independently developed and compiled software components can co-operate with one another. To make that possible, a precisely defined mode of behavior and the observation of interfaces of the module must be defined, so that they can interact. Such an interface is also ideal for facilitating interaction between modules from different manufacturers, for example. To some degree Tc COM is based on COM (Component Object Model of the Microsoft Windows world), although only a subset of COM is used. In comparison with COM, however, Tc COM contains additional definitions that go beyond COM, for example the state machine module. Overview and application of Tc COM modules This introductory overview is intended to make the individual topics easier to understand. One or several Tc COM modules are consolidated in a driver. This driver is created by Twin CAT Engineering using the MSVC compiler. The modules and interfaces are described in a TMC (Twin CAT Module Class) file. The drivers and their TMC file can now be exchanged and combined between the engineering systems. Instances of these modules are now created using the engineering facility. They are associated with a TMI file. The instances can be parameterized and linked with each other and with other modules to form the I/O. A corresponding configuration is transferred to the target system, where it is executed. Corresponding modules are started, which register with the Twin CAT Object Server. The Twin CAT XAR also provides the process images. Modules can query the Twin CAT Object Server for a reference to another object with regard to a particular interface. If such a reference is available, the interface methods can be called on the module instance. The following sections substantiate the individual topics. ID Management Different types of ID are used for the interaction of the modules with each other and also within the modules. Tc COM uses GUIDs (128-bit) and 32-bit long integers. 38 Version: 1.18.0 Twin CAT 3

## Page 39

Modules Tc COM uses • GUIDs for: Modul IDs, Class IDs and Interface IDs. • 32-bit long integers are used for: Parameter IDs, Object IDs, Context IDs, Category ID. Interfaces An important component of COM, and therefore of Tc COM too, are interfaces. Interfaces define a set of methods that are combined to perform a certain task. An interface is referenced with a unique ID (Interface ID), which must never be modified as long as the interface does not change. This ID enables modules to determine whether they can cooperate with other modules. At the same time the development process can take place independently, if the interfaces are clearly defined. Modifications of interfaces therefore lead to different IDs. The Tc COM concept is designed such that Interface IDs can superpose other (older) Interface IDs ( "Hides" in the TMC description / TMC editor). In this way, both versions of the interface are available, while on the other hand it is always clear which is the latest Interface ID. The same concept also exists for the data types. Tc COM itself already defines a whole series of interfaces that are prescribed in some cases (e.g. ITCom Object), but are optional in most. Many interfaces only make sense in certain application areas. Other interfaces are so general that they can often be re-used. Provision is made for customer-defined interfaces, so that two third-party modules can interact with each other, for example. • All interfaces are derived from the basic interface Itc Unknown which, like the corresponding interface of COM, provides the basic services for querying other interfaces of the module (Tc Query Interface) and for controlling the service life of the module (Tc Add Ref and Tc Release). • The ITCom Object interface, which must be implemented by each module, contains methods for accessing the name, Object ID, Object ID of the parent, parameters and state machine of the module. Several general interfaces are used by many modules: • ITc Cyclic is implemented by modules, which are called cyclically ("Cycle Update"). The module can register via the ITc Cyclic Caller interface of a Twin CAT task to obtain cyclic calls. • The ITc ADI interface can be used to access data areas of a module. • ITc Watch Source is implemented by default; it facilitates ADS Device Notifications and other features. • The ITc Task interface, which is implemented by the tasks of the real-time system, provides information about the cycle time, the priority and other task information. • The ITCom Object Server interface is implemented by the Object Server and referenced by all modules. A whole series of general interfaces has already been defined. General interfaces have the advantage that their use supports the exchange and recycling of modules. Only if no suitable general interfaces exist should you define your own interfaces. Class Factories "Class Factories" are used for creating modules in C++. All modules contained in a driver have a common Class Factory. The Class Factory registers once with the Object Server and offers its services for the creation of certain module classes. The module classes are identified by the unique Class ID of the module. When the Object Server requests a new module (based on the initialization data of the configurator or through other modules at runtime), the module selects the right Class Factory based on the Class ID and triggers creation of the module via its ITc Class Factory interface. Module service life Similar to COM, the service life of a module is determined via a reference counter (Ref Counter). The reference counter is incremented whenever a module interface is queried. The counter is decremented when the interface is released. An interface is also queried when a module logs into the Object Server (the ITCom Object interface), so that the reference counter is at least 1. The counter is decremented on logout. When the counter reaches 0, the module deletes itself automatically, usually after logout from the Object Server. If another module already maintains a reference (has an interface pointer), the module continues to exist, and the interface pointer remains valid, until this pointer is released. Twin CAT 3 Version: 1.18.0 39

## Page 40

Modules 6.1.1 Twin CAT module properties A Tc COM module has a number of formally defined, prescribed and optional properties. The properties are sufficiently formalized to enable interchangeable application. Each module has a module description, which describes the module properties. They are used for configuring the modules and their relationships with each other. If a module is instantiated in the Twin CAT runtime, it registers itself with a central system instance, the Object Server. This makes it reachable and parameterizable for other modules and also for general tools. Modules can be compiled independently and can therefore also be developed, tested and updated independently. Modules can be very simple, e.g. they may only contain a basic function such as low-pass filter. Or they may be very complex internally and contain the whole control system for a machine subassembly. There are a great many applications for modules; all tasks of an automation system can be specified in modules. Accordingly, no distinction is made between modules, which primarily represent the basic functions of an automation system, such as real-time tasks, fieldbus drivers or a PLC runtime system, and user- or application-specific algorithms for controlling a machine unit. The diagram below shows a common Twin CAT module with his main properties. The dark blue blocks define prescribed properties, the light blue blocks optional properties. 40 Version: 1.18.0 Twin CAT 3

## Page 41

Modules Module description Each Tc COM module has some general description parameters. These include a Class ID, which unambiguously references the module class. It is instantiated by the corresponding Class Factory. Each module instance has an Object ID, which is unique in the Twin CAT runtime. In addition there is a parent Object ID, which refers to a possible logical parent. The description, state machine and parameters of the module described below can be reached via the ITCom Object interface (see "Interfaces"). Class description files (*.tmc) The module classes are described in class description files (Twin CAT Module Class; *.tmc). These files are used by developers to describe the module properties and interfaces, so that others can use and embed the module. In addition to general information (vendor data, module class ID etc.), optional module properties are described. Twin CAT 3 Version: 1.18.0 41

## Page 42

Modules • Supported categories • Implemented interfaces • Data areas with corresponding symbols • Parameter • Interface pointers • Data pointers, which can be set The system configurator uses the class description files mainly as a basis for the integration of a module instance in the configuration, for specifying the parameters and for configuring the links with other modules. They also include the description of all data types in the modules, which are then adopted by the configurator in its general data type system. In this way, all interfaces of the TMC descriptions present in the system can be used by all modules. More complex configurations involving several modules can also be described in the class description files, which are preconfigured and linked for a specific application. Accordingly, a module for a complex machine unit, which internally consists of a number of submodules, can be defined and preconfigured as an entity during the development phase. Instance description files (*.tmi) An instance of a certain module is described in the instance description file (Twin CAT Module Instance; *.tmi). The instance descriptions are based on a similar format, although in contrast to the class description files they already contain concrete specifications for the parameters, interface pointers etc. for the special module instance within a project. The instance description files are created by Twin CAT Engineering (XAE), when an instance of a class description is created for a specific project. They are mainly used for the exchange of data between all tools involved in the configuration. However, the instance descriptions can also be used cross-project, for example if a specially parameterized module is to be used again in a new project. State machine Each module contains a state machine, which describes the initialization state of the module and the means with which this state can be modified from outside. The state machine describes the states, which occur during starting and stopping of the module. This relates to module creation, parameterization and production in conjunction with the other modules. Application-specific states (e.g. of the fieldbus or driver) can be described in their own state machines. The state machine of the Tc COM modules defines the states INIT, PREOP, SAFEOP and OP. Although the state designations are the same as under Ether CAT fieldbus, the actual states differ. When the Tc COM module implements a fieldbus driver for Ether CAT, it has two state machines (module and fieldbus state machine), which are passed through sequentially. The module state machine must have reached the operating state (OP) before the fieldbus state machine can start. The state machine is described [} 47] in detail separately. 42 Version: 1.18.0 Twin CAT 3

## Page 43

Modules Parameter Modules can have parameters, which can be read or written during initialization or later at runtime (OP state). Each parameter is designated by a parameter ID. The uniqueness of the parameter ID can be global, limited global or module-specific. Further details can be found in the "ID Management" section. In addition to the parameter ID, the parameter contains the current data; the data type depends on the parameter and is defined unambiguously for the respective parameter ID. Interfaces Twin CAT 3 Version: 1.18.0 43

## Page 44

Modules Interfaces consist of a defined set of methods (functions), which offer modules through which they can be contacted by other modules. Interfaces are characterized by a unique ID, as described above. A module must support at least the ITCom Object interface and may in addition contain as many interfaces as required. An interface reference can be queried by calling the method "Tc Query Interface" with specification of the corresponding interface ID. Interface pointers Interface pointers behave like the counterpart of interfaces. If a module wants to use an interface of another module, it must have an interface pointer of the corresponding interface type and ensure that it points to the other module. The methods of the other module can then be used. Interface pointers are usually set on startup of the state machine. During the transition from INIT to PREOP (IP), the module receives the object ID of the other modules with the corresponding interface; during the transition from PREOP to SAFEOP (PS) or SAFEOP to OP (SO), the instance of the other modules is searched with the Object Server, and the corresponding interface is set with the Method Query interface. During the state transition in the opposite direction, i.e. from SAFEOP to PREOP (SP) or OP to SAFEOP (OS), the interface must be enabled again. Data areas Modules can contain data areas, which can be used by the environment (e.g. by other modules or the IO area of Twin CAT). These data areas can contain any data. They are often used for process image data (inputs and outputs). The structure of the data areas is defined in the device description of the module. If a module has data areas, which it wants to make accessible for other modules, it implements the ITc ADI interface to enable access to the data. Data areas can contain symbol information, which describes the structure of the respective data area in more detail. 44 Version: 1.18.0 Twin CAT 3

## Page 45

Modules Data area pointer If a module wants to access the data area of other modules, it can contain data area pointers. These are normally set during initialization of the state machine to data areas or data area sections of other modules. The access is directly to the memory area, so that corresponding protection mechanisms for competing access operations have to be implemented, if necessary. In many cases it is preferable to use a corresponding interface. Context The context should be regarded as real-time task context. Context is required for the configuration of the modules, for example. Simple modules usually operate in a single time context, which therefore requires no detailed specification. Other modules may partly be active in several contexts (e.g. an Ether CAT master can support several independent real-time tasks, or a control loop can process control loops of the layer below in another cycle time). If a module has more than one time-dependent context, this must be specified the in the module description. Twin CAT 3 Version: 1.18.0 45

## Page 46

Modules Categories Modules can offer categories by implementing the interface ITCom Object Category. Categories are enumerated by the Object Server, and objects, which use this to associated themselves with categories, can be queried by the Object Server (ITCom Object Enum Ptr). ADS Each module that is entered in the Object Server can be reached via ADS. The Object Server uses the ITCom Object interface of the modules in order to read or write parameters or to access the state machine, for example. In addition, a dedicated ADS port can be implemented, through which dedicated ADS commands can be received. 46 Version: 1.18.0 Twin CAT 3

## Page 47

Modules System module In addition, the Twin CAT runtime provides a number of system modules, which make the basic runtime services available for other modules. These system modules have a fixed, constant Object ID, through which the other modules can access it. An example for such a system module is the real-time system, which makes the basic real-time system services, i.e. generation of real-time tasks, available via the ITc RTime interface. The ADS router is also implemented as a system module, so that other modules can register their ADS port here. Creation of modules Modules can be created both in C++ and in IEC 61131-3. The object-oriented extensions of the Twin CAT PLC are used for this purpose. Modules from both worlds can interact via interfaces in the same way as pure C++ modules. The object-oriented extension makes the same interfaces available as in C++. The PLC modules also register via the Object Server and can therefore be reached through it. PLC modules vary in terms of complexity. It makes no difference whether only a small filter module is generated or a complete PLC program is packed into a module. Due to the automation, each PLC program is a module within the meaning of Twin CAT modules. Each conventional PLC program is automatically packed into a module and registers itself with the Object Server and one or several task modules. Access to the process data of a PLC module (e.g. mapping with regard to a fieldbus driver) is also controlled via the defined data areas and ITc ADI. This behavior remains transparent and invisible for PLC programmers, as long as they decide to explicitly define parts of the PLC program as Twin CAT modules, so that they can be used with suitable flexibility. 6.1.2 Twin CAT module state machine In addition to the states (INIT, PREOP, SAFEOP and OP), there are corresponding state transitions, within which general or module-specific actions have to be executed or can be executed. The design of the state machine is very simple. In any case, there are only transitions to the next or previous step. This results in the state transitions: INIT to PREOP (IP), PREOP to SAFEOP (PS) and SAFEOP to OP (SO). In the opposite direction, the following state transitions exist: OP to SAFEOP (OS), SAFEOP to PREOP (SP) and PREOP to INIT (PI). Up to and including the SAFEOP state, all states and state transitions take place within the non-real-time context. Only the transition from SAFEOP to OP, the OP state and the transition from OP to SAFEOP take place in the real-time context. This differentiation is relevant when resources are allocated or enabled, or when modules register or deregister with other modules. Twin CAT 3 Version: 1.18.0 47

## Page 48

Modules State: INIT The INIT state is only a virtual state. Immediately after creation of a module, the module changes from INIT to PREOP, i.e. the IP state transition is executed. The instantiation and the IP state transition always take place together, so that the module never remains in INIT state. Only when the module is removed does it remain in INIT state for a short time. Transition: INIT to PREOP (IP) During the IP state transition, the module registers with the Object Server with its unique Object ID. The initialization parameters, which are also allocated during object creation, are transferred to the module. During this transition the module cannot establish connections to other modules, because it is not clear whether the other modules already exist and are registered with the Object Server. When the module requires system resources (e.g. memory), these can be allocated during the state transition. All allocated resources have to be released again during the transition from PREOP to INIT (PI). State: PREOP In PREOP state, module creation is complete and the module is usually fully parameterized, even if further parameters may be added during the transition from PREOP to SAFEOP. The module is registered in the Object Server, although no connections with other modules have been created yet. Transition: PREOP to SAFEOP (PS) In this state transition the module can establish connections with other modules. To this end it has usually received, among other things, Object IDs of other modules with the initialization data, which are now converted to actual connections with these modules via the Object Server. The transition can generally be triggered by the system according to the configurator, or by another module (e.g. the parent module). During this state transition further parameters can be transferred. For example, the parent module can transfer its own parameters to the child module. State: SAFEOP The module is still in the non-real-time context and is waiting to be switched to OP state by the system or by other modules. 48 Version: 1.18.0 Twin CAT 3

## Page 49

Modules Transition: SAFEOP to OP (SO) The state transition from SAFEOP to OP, the state OP, and the transition from OP to SAFEOP take place in the real-time context. System resources may no longer be allocated. On the other hand, resources can now be requested by other modules, and modules can register with other modules, e.g. in order to obtain a cyclic call during tasks. This transition should not be used for long-running tasks. For example, file operations should be executed during PS. State: OP In OP state the module starts working and is fully active in the meaning of the Twin CAT system. Transition: OP to SAFEOP (OS) This state transition takes place in the real-time context. All actions from the SO transition are reversed, and all resources requested during the SO transition are released again. Transition: SAFEOP to PREOP (SP) All actions from the PS transition are reversed, and all resources requested during the PS transition are released again. Transition: PREOP to INIT (PI) All actions from the IP transition are reversed, and all resources requested during the IP transition are released again. The module signs off from the Object Server and usually deletes itself (see "Service life"). 6.2 Module-to-module communication Tc COM modules can communicate with one another. This article is intended to provide an overview of the various options. There are four methods of module-to-module communication: • IO Mapping (linking of input/output symbols) • IO Data Pointer • Method calls via interface • ADS These four methods will now be described. IO Mapping (linking of input/output symbols) The inputs and outputs of Tc COM modules can be linked by IO Mapping in the same way as the links to physical symbols in the fieldbus level. To do this, data areas are created in the TMC editor [} 121] that describe the corresponding inputs/outputs. These are then linked in the Twin CAT solution. Mapping is used to provide or transfer data from one module to another. Data consistency is ensured by synchronous or asynchronous mapping, which is carried out after or before the actual cyclic program sequence. The implementing language (PLC, C++, Matlab®) is irrelevant. The following sample shows the implementation: Twin CAT 3 Version: 1.18.0 49

## Page 50

Modules Sample12: Module communication: Using IO mapping [} 296] IO Data Pointer Direct memory access is also possible within a task via the Data Area Pointers, which are created in the TMC Editor. If several callers of a task or callers from other tasks occur, the user must ensure the data consistency through appropriate mechanisms. Data pointers are available for C++ and MATLAB®. The following sample shows the implementation: Sample10: Module communication: Use of data pointers [} 267] Method calls via interfaces As already described, Tc COM modules can offer interfaces that are also defined in the TMC editor. If a module implements them ("Implemented Interfaces" in the TMC editor [} 113]), it offers appropriate methods. A calling module will then have an "Interface Pointer" to this module in order to call the methods. These are blocking calls, meaning that the caller blocks until the called methods come back and the return values of the methods can thus be directly used. If several callers of a task or callers from other tasks occur, the user must ensure the data consistency through appropriate mechanisms. The following samples show the implementation: Sample11: Module communication: PLC module invokes method of C module [} 268] Sample11a: Module communication: C module calls a method of another C module [} 295] Further samples exist for the communication with the PLC [} 315]. ADS As the internal communication of the Twin CAT system in general, ADS can also be used to communicate between modules. Communication in this case is acyclic, event-controlled communication. At the same time ADS can also be used to collect or provide data from the User Mode and communicate with other controllers (i.e. via the network). ADS can also be used to ensure data-consistent communication, e.g. between tasks/cores/CPUs. In this case Tc COM modules can be both clients (requesters) and servers (providers). The implementing language (PLC, C++, Matlab®) is irrelevant. 50 Version: 1.18.0 Twin CAT 3

## Page 51

Modules The following samples show the implementation: Sample03: C++ as ADS server [} 248] Sample06: UI-C#-ADS client uploading the symbolic from module [} 258] Sample07: Receiving ADS Notifications [} 263] Sample08: Provision of ADS-RPC [} 264] Twin CAT 3 Version: 1.18.0 51

## Page 52

Modules - Handling 7 Modules - Handling Tc COM modules are implemented and loaded after a build. This section describes the handling of modules when they are exchanged between systems. These modules are programmed in Versioned C++ projects [} 52] that generate a tmx file in order to load them with the Twin CAT Loader [} 53] (since Twin CAT 3.1 Build 4024). Driver projects For older projects, Beckhoff recommends switching to the versioned C++ projects [} 52], as these offer the following advantages, for example: • Driver signature [} 24] via OEM certificates that can be obtained from Beckhoff. • Versioned storage [} 53] of the binaries. • Online Change capability [} 152], if required. After installation under Twin CAT 3.1 Build 4026, a conversion is available on the C++ node for migration from the older projects ("driver projects"). This can be accessed via the context menu: The migration generates a report as an HTML file that should be taken into account. 7.1 Versioned C++ Projects From Twin CAT 3.1 Build 4024.0 The functionality described here is available from Twin CAT 3.1. 4024.0. Versioned Twin CAT C++ projects result in an architecture-dependent TMX file during building and are loaded via the Twin CAT Loader [} 53]. They must be signed by a Twin CAT user certificate. If a C++ project was created using the “Versioned C++ Project” template, the binary files are stored by Publish in the Twin CAT Engineering Repository (under Twin CAT 3.1 Build 4024: C:\Twin CAT\3.1\Repository and Twin CAT 3.1 Build 4026 C:\Program Data\Beckhoff\Twin CAT\3.1\Repository) at a vendor- and version- specific location. From here, modules are transferred to the target system, if they are needed: • Windows with Twin CAT 3.1 Build 4024: C:\Twin CAT\3.1\Boot\Repository • Windows with Twin CAT 3.1 Build 4026: C:\Program Data\Beckhoff\Twin CAT\3.1\Boot\Repository 52 Version: 1.18.0 Twin CAT 3

## Page 53

Modules - Handling • Twin CAT/BSD: /usr/local/etc/Twin CAT/3.1/Boot/Repository This can be either at the time of activation (Activate Configuration) or at the time of the Online Change [} 152]. Additionally, it is possible to create an archive for the transfer between engineering systems of the binary version of this project, which is configured by the project properties [} 147]. 7.2 Starting Modules Twin CAT C++ modules can be started in two ways: • Operating system: The operating system starts the Twin CAT module as a normal driver. It is recommended to migrate to the Twin CAT Loader with TMX files. • Twin CAT Loader: [} 53] The Twin CAT Loader starts the Twin CAT module. ◦ The Twin CAT Loader requires a signature [} 23] with Twin CAT user certificate. ◦ This option is mandatory for encrypted modules [} 56]. ◦ The Twin CAT Loader is required for the versioned C++ projects [} 87]. Via System -> Tc COM Modules -> Class Factories tab you can see whether the Twin CAT Loader or the operating system is used: 7.3 Twin CAT Loader From Twin CAT 3.1 Build 4024.0 The functionality described here is available from Twin CAT 3.1. 4024.0. Twin CAT 3 has an integrated function for loading modules. Modules loaded with the Twin CAT Loader: • Must be signed: Test signing [} 54]. • Can be encrypted: Encrypting Modules [} 56], for which the Twin CAT Software Protection must be configured with a User DB. Twin CAT 3 Version: 1.18.0 53

## Page 54

Modules - Handling 7.3.1 Test signing The test signing for Twin CAT can be carried out with the same Twin CAT user certificate as for the actual delivery (see Request Twin CAT 3 user certificate [} 27]). 1. For test operation, e.g., during software development, it is sufficient to create a Twin CAT user certificate [} 28]. Make sure that you select the purpose "Sign Twin CAT C++ executable (*.tmx)". For this the Crypto version 2 is required, a message appears. On XAR (and XAE, if it is a local test), activate the test mode so that the operating system can accept the self-signed certificates. This can be done on both engineering systems (XAE) and runtime systems (XAR). For Windows Use the administrator prompt to execute the following: bcdedit /set testsigning yes and reboot the target system. You may have to switch off "Secure Boot" for this, which can be done in the bios. If test signing mode is enabled, this is displayed at the bottom right of the desktop. The system now accepts all signed drivers for execution. 54 Version: 1.18.0 Twin CAT 3

## Page 55

Modules - Handling For Twin CAT/BSD In the file /usr/local/etc/Twin CAT/3.1/Tc Registry.xml enter "<Value Name="Enable Test Signing" Type="DW"1</Value>" under Key "System". <Key Name="System"> <Value Name="Run As Device" Type="DW">1</Value> <Value Name="RTime Mode" Type="DW">0</Value> <Value Name="Ams Net Id" Type="BIN">052445B00101</Value> <Value Name="Locked Mem Size" Type="DW">33554432</Value> <Value Name="Enable Test Signing" Type="DW">1</Value> </Key> Then restart the Twin CAT system service: doas service Tc System Service restart After the respective procedure, the system accepts all signed drivers for execution. 1. During the first activation (Activate Configuration) with a Twin CAT user certificate, the target system detects that the certificate is not trusted and the activation process is aborted: For Windows: A local user with administration rights can trust the certificate via the created REG file by simply executing it: For Twin CAT/BSD: If the "Tcimportcert" package is not installed, install it: pkg install tcimportcert Trust the certificate via doas tcimportcert /usr/local/etc/Twin CAT/3.1/Target/ Oem Certificates/<Created File>.reg. Then restart the Twin CAT System Service or reboot the system: doas service Tc System Service restart ð This process only enables C++ modules with a signature from the trusted Twin CAT user certificates to run. 2. Following this process you can use the Twin CAT user certificate for signing with the test mode of the operating system. This is configured in the project properties [} 148]. Use the Tc Sign Tool [} 58] to avoid storing the password of the Twin CAT user certificate in the project, where it would also end up in version management, for example. If you want to use the Twin CAT user certificate without Test Mode for delivery, you must have the certificate countersigned by Beckhoff [} 26]. Twin CAT 3 Version: 1.18.0 55

## Page 56

Modules - Handling 7.3.2 Encrypting Modules Twin CAT C++ modules loaded via the Twin CAT Loader (TMX files) can be encrypted, i.e. a key protects the content of the driver against manipulation and reverse engineering at file level. No debugging Encrypted modules cannot be searched for errors. Encrypted modules are not displayed in the debugger. Module encryption is enabled as follows: ü The Twin CAT software protection must be configured. ü A Twin CAT user certificate with Sign User DB rights is required. 1. In the system tree, select the Solution User DB Key as the Boot File Encryption Key. 2. Select the C++ project and activate encryption there: 3. To start, an encrypted module must be loaded with the Twin CAT Loader (not the operating system). ð For non-versioned drivers: The drivers are encrypted during transfer to the _deployment directory of the project. ð For versioned TMX: The drivers are stored unencrypted in XAE and encrypted when they are activated on the target system. ð If the function is used with versioned C++ projects, the TMX files are stored in the repository [} 52] as usual. Twin CAT C++ modules can be started in two ways: • Operating system: The operating system starts the Twin CAT module as a normal driver. It is recommended to migrate to the Twin CAT Loader with TMX files. 56 Version: 1.18.0 Twin CAT 3

## Page 57

Modules - Handling • Twin CAT Loader: [} 53] The Twin CAT Loader starts the Twin CAT module. ◦ The Twin CAT Loader requires a signature [} 23] with Twin CAT user certificate. ◦ This option is mandatory for encrypted modules [} 56]. ◦ The Twin CAT Loader is required for the versioned C++ projects [} 87]. Via System -> Tc COM Modules -> Class Factories tab you can see whether the Twin CAT Loader or the operating system is used: 7.3.3 Return Codes Loading a module with the Twin CAT Loader can fail for various reasons. Return codes under Windows Hex Description 0x C1 File is corrupted; PE file checksum error. 0x241 Signing error: Twin CAT user certificate does not match the file hash. 0x4FB Signing error: File not signed. 0x1772 File is encrypted, but cannot be decoded with known keys. Twin CAT 3 Version: 1.18.0 57

## Page 58

Modules - Handling Return codes under Twin CAT/BSD Hex Description 0x C0000001 File is corrupted; PE file checksum error. 0x C0000004 0x C000007B 0x C0000173 0x C0000221 0x C0000102 Signing error: Twin CAT user certificate does not match the file hash. 0x C0000424 0x4FB Signing error: File not signed. 0x C0000428 Signing error: Used certificate not countersigned. Test mode necessary. 0x C0000603 Signing error: Certificate is not trusted. Add necessary (see "tcinsertcert") 0x C0000385 Signing error: File not signed. Check the settings in Engineering. 0x C0000293 File is encrypted, but cannot be decoded with known keys. 0x C0000225 File not found. 7.3.4 Tc Sign Tool - Storage of the certificate password outside the project The Tc Sign Tool can be used to store a password for a Twin CAT user certificate in the registry. Thus, the password is not needed in the projects, where the passwords would end up unintentionally in version control systems. The Tc Sign Tool is a command line program located in the path C:\Twin CAT\3.1\sdk\Bin\ or C:\Program Files (x86)\Beckhoff\Twin CAT\3.1\SDK\Bin. The storage of the password is carried out with the following parameters: tcsigntool grant /f "…Custom Config\Certificates\My Certificate.tccert" /p My Password The password is deleted with the following parameters: tcsigntool grant /f "…Custom Config\Certificates\My Certificate.tccert" /r The unencrypted password is stored under: HKEY_CURRENT_USER\SOFTWARE\Beckhoff\Tc Sign Tool\ 58 Version: 1.18.0 Twin CAT 3

## Page 59

Twin CAT C++ development 8 Twin CAT C++ development Overview of the development environment The layout of Visual Studio is flexible and adaptable, so that only a brief overview of a common configuration can be provided here. The user is free to configure windows and arrangements as required. 1. In the Twin CAT Solution, a Twin CAT C++ project can be created by right-clicking on the C++ icon. This project contains the sources (“Untitled Project”) of several modules [} 38], if applicable, and module instances ("Untitled1_Obj1 (CModule1)") can be created. The module instances have inputs/ outputs, which can be linked in the usual way ("Link"). There are further options [} 49] for module interaction. 2. The Visual Studio editor for Visual C++ is used for programming. Here, particular attention should be paid to the drop-down boxes for fast navigation within a file. In the lower area the result of the compile process is output. It is also possible to switch to the Twin CAT messages (see Module messages for the Engineering (logging / tracing) [} 216]). The usual features such as breakpoints (cf. Debugging [} 78]) can be used in the editors. 3. The freely configurable toolbar usually contains the toolbar for Twin CAT XAE Base. Activate Configuration, RUN, CONFIG, Choose Target System (in this case <Local>) and several other buttons provide fast access to frequently used functions. The Twin CAT Debugger is the button for establishing a connection to the target system with regard to C++ modules (the PLC uses an independent debugger). Like in other C++ programs, and in contrast to PLC, in Twin CAT C++ a distinction has to be made between "Release" and "Debug". In a build process for "Release", the code is optimized to such an extent that a debugger may no longer reliably reach the breakpoints, and incorrect data may be displayed. Procedure This section describes the processes for programming, compiling and starting a Twin CAT C++ project. It provides a general overview of the engineering process for Twin CAT C++ projects with reference to the corresponding detailed documentation. The quick start [} 61] guide describes the individual common steps. Twin CAT 3 Version: 1.18.0 59

## Page 60

Twin CAT C++ development 1. Type declaration and module type: The Twin CAT Module Class Editor (TMC) [} 90] and TMC Code Generator are used for the definition of data types and interfaces, and also for the modules that use these. The TMC Code Generator generates source code based on the processed TMC file and prepares data types / interfaces for use in other projects (like PLC). Editing and starting the Code Generator can take place as often as you like – the code generation pays attention to programmed user code and preserves it. 2. Programming The familiar Visual Studio C++ programming environment is used for the development and debugging [} 78] of the user-defined code within the code template. 3. Instantiating modules [} 38] The program describes a class, which is instantiated as objects. The Twin CAT Module Instance Configurator [} 133] is used to configure the instance. General configuration elements are: allocate task, download symbol information for runtime (Twin CAT Module Instance (TMI) file), or specify parameter/ interface pointers. 4. Mapping of variables The input and output variables of an object can be linked with variables of other objects or PLC projects, using the standard Twin CAT System Manager. 5. Building During the building (compilation and linking) of the Twin CAT C++ project, all components are compiled for the selected platform. The platform is determined automatically when the target system is selected. 6. Publishing During publishing of a module, the drivers for all platforms are created, and the module is prepared for distribution. The directory created in the repository can be distributed without having to transfer the source code. Only binary code with the interface description is transferred. 7. Signature (see Module signing [} 23]) Twin CAT C++ projects must be signed. The signature process can be user-defined [} 37]. 8. Activation The Twin CAT C++ driver can be activated like any other Twin CAT project via Activate Configuration. The dialog then requests to switch Twin CAT to RUN mode. Debugging [} 78] in real-time (which is familiar from IEC61131-based systems) and the setting of (conditional) breakpoints is possible for Twin CAT C++ modules. ð The module runs under real-time conditions. 60 Version: 1.18.0 Twin CAT 3

## Page 61

Quick Start 9 Quick Start This quick start shows how you can familiarize yourself with the Twin CAT C++ module engineering in a short time. Each step in the creation of a module that runs in a real-time context is described in detail. Two different scenarios are discussed: • Twin CAT Versioned C++ projects. Modules based on such project are loaded by Twin CAT and stored versioned in binary form. • We illustrate how to switch between the different versions via Online Change, using versioned C++ projects as a basis. Before the quick start, please pay attention to the preparation - just once! [} 23] In particular, prepare the respective driver signing. 9.1 Create Twin CAT 3 project Start the Twin CAT Engineering Environment (XAE) Microsoft Visual Studio® can be started via the Twin CAT Sys Tray icon. The Microsoft Visual Studio® versions offered are those in which Twin CAT is activated. Alternatively, Microsoft Visual Studio® can also be started via the Start menu. Creating a Twin CAT 3 C++ project Carry out the following steps to create a Twin CAT C++ project: 1. Select New Twin CAT Project … via the Start page. 2. Alternatively, you can create a project by clicking on: File -> New -> Project. ð All existing project templates are displayed. 3. Select Twin CAT XAE Project and optionally enter a suitable project name. Twin CAT 3 Version: 1.18.0 61

## Page 62

Quick Start 4. Click OK. ð The Visual Studio Solution Explorer then displays the Twin CAT 3 project. 9.2 Create Twin CAT 3 C++ project After creating a Twin CAT 3 project, open the C++ node and proceed as follows: 62 Version: 1.18.0 Twin CAT 3

## Page 63

Quick Start 1. Right-click C++ and select Add New Item.... If the green C++ symbol is not listed, this means that either a target device is selected that doesn't support Twin CAT C++ or the Twin CAT Solution is currently open in a version of Visual Studio that is not C++-capable (cf. Installation [} 21]). ð The Twin CAT C++ Project Wizard [} 87] is shown and all existing project templates are listed. 2. Select Twin CAT Versioned C++ Project, optionally enter a related project name and click on OK. Alternatively, use the Twin CAT Static Library Project, which provides an environment for programming static Twin CAT C++ libraries (see Sample 25 [} 307]). ð The Twin CAT Module wizard [} 88] is displayed. Twin CAT 3 Version: 1.18.0 63

## Page 64

Quick Start 3. In this case, select Twin CAT Module Class with Cyclic IO and click on OK. If you want to use the Online Change capability, select the Twin CAT Module Class Online Changeable. 64 Version: 1.18.0 Twin CAT 3

## Page 65

Quick Start 4. Enter a unique name in the Twin CAT Class Wizard dialog box or continue with the "Module1" suggestion. Twin CAT 3 Version: 1.18.0 65

## Page 66

Quick Start ð A Twin CAT 3 C++ project will then be created on the basis of the selected template: 9.3 Twin CAT 3 C++ Configure project ü You have created a Twin CAT Versioned C++ project and also had a module created by the wizard 1. Go to the properties of the project by right-clicking. 2. Activate the Twin CAT Signing in the Tc Sign tab. 3. If you have not yet created a Twin CAT user certificate, follow the instructions and observe to select the Sign Twin CAT C++ executeables. 4. Enter the file name of the Twin CAT user certificate and the password. (Note that this is stored unencrypted in the solution and is therefore also loaded on servers via version control, for example. If necessary, use the Tc Sign Tool [} 58].) 66 Version: 1.18.0 Twin CAT 3

## Page 67

Quick Start 9.4 Implement Twin CAT 3 C++ project This article describes how the sample project can be changed. The implementation begins after creating a Twin CAT C++ project and opening <My Class>.cpp (Module1.cpp in this sample). Twin CAT 3 Version: 1.18.0 67

## Page 68

Quick Start 1. The <My Class>::Cycle Update() method is cyclically called – this is the point where the cyclic logic is to be positioned. At this point, add the entire cyclic code. Use the drop-down menu at the top of the editor for navigation. 2. In this case a counter is incremented by the value of the Value variable in the input image (m_Inputs). Replace a line in order to increment the counter without dependence on the value of the input image. Replace this line: m_counter+=m_Inputs. Value; with this one: m_counter++; 3. Save the modifications. 4. If you have prepared the module for Online Change, please note that version 0.0.0.1 has been implemented here, as you can see in the TMC editor. 5. The project can now be built and the actual implementation is done until local tests are successful. 68 Version: 1.18.0 Twin CAT 3

## Page 69

Quick Start 9.5 Publish Twin CAT 3 C++ project in version 0.0.0.1 After a Twin CAT C++ project has been created, compiled and tested, the project can be published, i.e. it is prepared for distribution. 1. Click in the context menu on Twin CAT Publish Modules to publish the module and thus make it available in the local repository as version 0.0.0.1 ð The module is published in version 0.0.0.1 with the incremental counter on the engineering device. 9.6 Implement and publish Twin CAT 3 C++ project version 0.0.0.2 These steps are only necessary if you have previously prepared the module for Online Change. This article describes how to change the sample project to create a version 0.0.0.2. This can later be exchanged on the target system via Online Change In <My Class>.cpp (in this sample Module1.cpp) the implementation can be changed. 1. Replace a line to decrement the counter instead of incrementing it. Replace this line m_counter++; 2. with this m_counter--; 3. Save the modifications. Twin CAT 3 Version: 1.18.0 69

## Page 70

Quick Start 4. Start the Code Generator to take over any possible changes. 5. Parameterize version 0.0.0.2 in the TMC Editor. 70 Version: 1.18.0 Twin CAT 3

## Page 71

Quick Start 6. Publish this version as well: ð There are two versions of a module, which can be exchanged during runtime. 9.7 Create Twin CAT 3 C++ Module instance An instance of the module must be created in order to execute it. Several instances of a module can exist. After creating a Twin CAT C++ module, open the C++ node and follow these steps to create an instance. 1. Right-click on the C++ module (in this case "Untitled1") and select Add New Item.... Twin CAT 3 Version: 1.18.0 71

## Page 72

Quick Start ð All existing C++ modules are listed. 2. Select a C++ module. You can use the default name or alternatively enter a new instance name and confirm with OK (in this sample the default name was selected). ð The new instance "Untitled1_Obj2 (CModule1)" becomes part of the Twin CAT 3 Solution: the new node can be found exactly under the Twin CAT 3 C++ source "Untitled1 Project". The module already provides a simple I/O interface with 3 variables in each case: • Input Area: Value, Status, Data • Output Area: Value, Control, Data The description of these interfaces corresponds in two places: • "<Classname>Services.h" (in this sample "Untitled1Services.h") 72 Version: 1.18.0 Twin CAT 3

## Page 73

Quick Start • "Twin CAT Module Configuration".tmc file (in this sample "Untitled1.tmc") 9.8 Twin CAT 3 enable C++ debugger To prevent all dependencies from being loaded for debugging [} 78], this function is switched off by default and must be activated once before the activation of the configuration. 1. Select C++ Debugger on the C++ node of the Solution tab. 2. Select Enable C++ Debugger. 3. Switch Enable C++ Debugger on. Twin CAT 3 Version: 1.18.0 73

## Page 74

Quick Start 9.9 Create a Twin CAT task and apply it to the module instance This page describes the linking of a module instance to a task, so that the cyclic interface of the module is called by the Twin CAT real-time system. This configuration step only has to be carried out once. No new task needs to be configured for subsequent creations/new compilations of the C++ module in the same project. Creating a Twin CAT 3 task 1. Open System, right-click on Tasks and select Add New Item…. 2. Enter a unique name for the task (or retain the default name). In this sample the I/O image interface is provided by a C++ module instance, so that no image is necessary at the task for triggering the execution of the C++ module instance. ð The new task with the name "Task 1" has been created. 74 Version: 1.18.0 Twin CAT 3

## Page 75

Quick Start 3. The task can now be configured; double-click on the task to do this. The most important parameters are Auto start and Priority: Auto start must be activated in order to automatically start a task that is to be cyclically executed. The Cycle ticks define the timing of the clock in relation to the basic clock (see real-time settings). ð Configuring a Twin CAT 3 C++ module instance that is called from the task 1. Select the C++ module instance in the solution tree. 2. Select the Context tab in the right-hand working area. 3. Select the task for the previously created context in the drop-down task menu. Select the default Task 1 in the sample. ð On completion of this step the Interface Pointer is configured as a Cyclic Caller. The configuration is now complete! Twin CAT 3 Version: 1.18.0 75

## Page 76

Quick Start 9.10 Activating a Twin CAT 3 project Once a Twin CAT C++ project has been created, compiled and made available, the configuration must be activated: 1. Click on the symbol Activate Configuration – all required files for the Twin CAT project are transferred to the target system: 2. In the next step, confirm the activation of the new configuration. The previous old configuration will be overwritten. ð The certificates required for execution are displayed and can be approved automatically: 3. If you have no license on the target system, you will be offered the option to create a 7-day trial license. This can be repeated any number of times. 4. Twin CAT 3 automatically asks whether the mode should be switched to Run mode. 76 Version: 1.18.0 Twin CAT 3

## Page 77

Quick Start ð With OK the Twin CAT 3 project changes to Run mode. With Cancel Twin CAT 3 remains in Config mode. ð After switching to Run mode, the Twin CAT System Service symbol at the bottom in Visual Studio lights up green. 9.11 Twin CAT 3 C++ Implement project Online Change These steps are only necessary if you have previously prepared the module for Online Change. ü Running Twin CAT C++ project as described above. 1. Switch to the Tc COM Objects overview of the SYSTEM area and there to the Online Changeable Objects tab. 2. 3. In the column Online Version the currently running version is preselected and marked with the extension (Current). 4. Set a different version. 5. Activate this change by right-clicking and Apply changed online object versions on the target. ð The version change was made on the target Also see about this 2 Activating a Twin CAT 3 project [} 76] Twin CAT 3 Version: 1.18.0 77

## Page 78

Debugging 10 Debugging Twin CAT C++ offers various mechanisms for debugging Twin CAT C++ modules running under real-time conditions. Most of them correspond to the mechanisms that are familiar from the normal C++ development environment. The world of automation requires additional, slightly different debugging mechanisms, which are documented here. In addition, we provide an overview of Visual Studio tools that can be used in Twin CAT 3. These were extended, so that data from the target system are displayed. Debugging must be enabled. This is configured via the C++ node of the solution: 1. Double-click on the C++ node and switch to the C++ Debugger tab to access the checkbox. 2. For all debugging in Twin CAT C++, connect the Twin CAT Engineering with the runtime system (XAR) via the Twin CAT Debugger button. 3. Breakpoints and step-by-step execution In most cases when debugging a C++ program, breakpoints are set and the code is then executed step by step while observing the variables, pointers, etc. In the context of the Visual Studio debugging environment, Twin CAT offers options to run real-time-executed code step by step. To set a breakpoint, you can navigate through the code and click on the gray column on the left adjacent to the code or use the hotkey (normally F9). WARNING Damage to plants and personal injuries due to unexpected behavior of the machine / plant Breakpoints change the behavior of the machine or plant. Depending on the machine being controlled, the machine or workpieces may be damaged or the health and life of people may be endangered. Make sure that the changed behavior of the controlled system does not cause any damage and be sure to note the plant documentation. 78 Version: 1.18.0 Twin CAT 3

## Page 79

Debugging On reaching the breakpoint (indicated by an arrow), the execution of the code is stopped. The code is executed step by step by pressing Step Over (Debug menu, toolbar or hotkey F10). The familiar Visual Studio functions Step in (F11) and Step out (Shift + F11) are also available. Conditional breakpoints A more advanced technology allows the setting of conditional breakpoints – the execution of code is only stopped at a breakpoint if a condition is fulfilled. Twin CAT offers the implementation of a conditional breakpoint as part of the Visual Studio Integration. To set a condition, first set a normal breakpoint and then right-click on the red dot in the breakpoint column. WARNING Damage to plants and personal injuries due to unexpected behavior of the machine / plant Breakpoints change the behavior of the machine or plant. Depending on the machine being controlled, the machine or workpieces may be damaged or the health and life of people may be endangered. Make sure that the changed behavior of the controlled system does not cause any damage and be sure to note the plant documentation. Select Condition… to open the condition window: Twin CAT 3 Version: 1.18.0 79

## Page 80

Debugging For more information, see the chapter: Details of Conditional Breakpoints [} 81]. Live Watch When engineering and developing machines, it is not always advisable to stop the system at a breakpoint because this will affect the behavior. The Twin CAT PLC projects offer an online view and handling of the variables in the RUN state, without having to interrupt the real-time. Twin CAT C++ projects offer a similar behavior for C++ code via the Live Watch window. The Live Watch window can be opened via Debug->Windows->Twin CAT Live Watch. To open the window, first establish a connection with the real-time system (press the Twin CAT Debugger button), whereupon Visual Studio switches to the debug view, otherwise no data can be provided. The Twin CAT Live Watch window is divided into two areas. 80 Version: 1.18.0 Twin CAT 3

## Page 81

Debugging In the upper area all member variables can be explored. By double-clicking on it they are added to the lower area, where the current value is then displayed. You can edit these values by clicking on the value in the Value field. The new value is highlighted in red. To write the value, press the symbol in the upper left corner (1). Using the import and export symbols under (2), the selected member variables can be saved and later restored. 10.1 Details of Conditional Breakpoints Twin CAT C++ provides conditional breakpoints. Details of the formulation of these conditions can be found here. Unlike the Visual Studio C++ conditional breakpoints, the Twin CAT conditions are compiled and subsequently transferred to the target system so that they can be used during short cycle times. WARNING Damage to plants and personal injuries due to unexpected behavior of the machine / plant Breakpoints change the behavior of the machine or plant. Depending on the machine being controlled, the machine or workpieces may be damaged or the health and life of people may be endangered. Make sure that the changed behavior of the controlled system does not cause any damage and be sure to note the plant documentation. The option buttons offer two options that are described separately. Option: Is true Conditions are defined with the help of logical terms, comparable to the conjunctive normal forms. They are formed from a combination of Maxterms connected with "&&": (Maxterm1 && Maxterm2 && ... && Maxterm N) wherein each Maxterm represents a combination of || associated conditions: (condition1 ||condition2 || ... || condition N ) Possible comparison operators: ==,!=, <=, >=, <, > Observe the Live Watch window for the determination of the available variables. All listed variables can be used for the formulation of conditions. This includes TMC-defined symbols as well as local member variables. Samples: m_counter == 123 && hr != 0 m_counter == 123 || m_counter2 == 321 && hr == 0 Twin CAT 3 Version: 1.18.0 81

## Page 82

Debugging m_counter == 123 Monitoring module instances The OID of the object is stored in m_obj Id, so the monitoring of the OID can look like this m_obj Id == 0x01010010 Monitoring of tasks A special variable #task Id is provided to access the OID of the calling task. E.g.: #task ID == 0x02010010 Option: Has changed The option “Has changed“ is simple to understand: By providing variable names, the value will be monitored and execution will be held, if the value has changed from the cycle before. Samples: m_counter m_counter && m_counter2 10.2 Visual Studio tools Visual Studio makes the usual development and debugging tools available for C++ developers. Twin CAT 3 extends these Visual Studio tools, so that debugging of C++ code that runs on a target system is also possible in Twin CAT 3 Engineering with the Visual Studio tools. The corresponding advanced tools are briefly described here. If the corresponding windows are not visible in Visual Studio, they can be added via the menu item Debug ->Windows. The menu is context-dependent, i.e. many of the windows described here only become configurable once a debugger is linked to a target system. Callstack The Call Stack is displayed by the Call Stack tool window when a breakpoint has been reached. Autos / Locals and Watch The corresponding variables and values are displayed in the Autos / Locals window when a breakpoint is reached. Changes are shown in RED. 82 Version: 1.18.0 Twin CAT 3

## Page 83

Debugging From here, the values can be applied to the Watch windows by right-clicking: Memory View The memory can be monitored directly. Changes are shown in RED. Twin CAT 3 Version: 1.18.0 83

## Page 84

Debugging 10.3 Working with Twin CAT Task Dumps From Twin CAT 3.1 Build 4026 This function is available from Twin CAT 3.1 Build 4026. If an exception occurs, Twin CAT runtime automatically writes "Twin CAT Task Dumps" to the boot directory (usually C:\Program Data\Beckhoff\Twin CAT\3.1\Boot) if it is not handled by the application. These Task Dumps can be transferred and evaluated by the Twin CAT C++ developer on a development system with Visual Studio for Twin CAT C++ development. For the investigation, it is necessary that, in addition to the Twin CAT task dumps, the exact corresponding TMX and PDB files are also available. If the Twin CAT Task Dump is loaded directly from the appropriate Solution, these files are found automatically. If the Twin CAT Task Dump is loaded from an empty Solution, the associated TMX and PDB files can be placed in the same directory as the Twin CAT Task Dump. Alternatively, it is possible to enter a search path in the Visual Studio options (Tools->Options->Debugging->Symbols: add new Path to Symbol file (.pdb) locations). The procedure is then as follows: ü An exception has occurred on the target system. 1. The Twin CAT Task Dump file is transferred from the target system to the engineering system. It has a name like taskmemory-*.dmp 2. Ideally, the appropriate sources of the Twin CAT project are available and are opened in Visual Studio. 3. The file can be opened via File->Open->Open Tc Task Dump: 84 Version: 1.18.0 Twin CAT 3

## Page 85

Debugging 4. The editor jumps directly to the appropriate code location that triggered the exception: In addition, standard Visual Studio windows can be used to control variable values, for example: 10.4 Debugging the state machine with the Usermode Runtime The state machine of the Tc COM modules cannot be debugged in the real-time environment, as the debugger itself is still being started at that point. The Usermode Runtime can be used for this. ü A Twin CAT C++ project is loaded in Visual Studio 1. Activate the project in a Usermode Runtime 2. Open a second Visual Studio instance Twin CAT 3 Version: 1.18.0 85

## Page 86

Debugging 3. Use the normal Visual Studio C++ debugger to connect to the Usermode Runtime process. Debug -> Attach to Process ... -> Selection of Tc System Service Um.exe 4. In this instance, add the Twin CAT C++ project that you want to debug. Set breakpoints in the transitions. 5. Start the Usermode Runtime - the breakpoints are reached. 86 Version: 1.18.0 Twin CAT 3

## Page 87

Wizards 11 Wizards Wizards are available to facilitate familiarization with the engineering procedures of the Twin CAT C++ system. • The Twin CAT Project Wizard [} 87] creates a Twin CAT C++ project. For driver projects the Twin CAT Class Wizard is then started. • The Twin CAT Module Class Wizard [} 88] is started automatically when a C++ module is created. This wizard provides various "ready-to-use" projects as a starting point for your own developments. • The Twin CAT Module Class Editor [} 90] (TMC) is a graphical editor for defining data structures, parameters, data areas, interfaces and pointers. It creates a TMC file that is used by the TMC Code Generator. • Instances are generated based on the defined classes, which can be configured via the Twin CAT Module Instance Configurator [} 133]. 11.1 Twin CAT C++ Project Wizard After the creation of a Twin CAT project you can add a C++ project with the help of the Twin CAT C++ Project Wizard: 1. Right-click on the C++ icon and select Add new Item... to start the C++ project wizard. Twin CAT offers two C++ projects: - Versioned C++ projects: Projects that involve versioning may also have the option of switching between versions at runtime. - Static library: Projects with C++ functions that are used by (different) Twin CAT C++ drivers. 2. Select one of the project templates and specify a name and location. ð The Twin CAT C++ project is created ð In the case of a driver, the Twin CAT C++ Class Wizard [} 88] is started. Twin CAT 3 Version: 1.18.0 87

## Page 88

Wizards 11.2 Twin CAT Module Class Wizard Twin CAT 3 offers various class templates that can be used to create Tc COM object classes: • Twin CAT Module Class • Twin CAT Module Class with ADS port • Twin CAT Module Class with cyclic caller • Twin CAT Module Class with cyclic input/output • Twin CAT Module Class with data pointer • Twin CAT Module Class for real-time context • Twin CAT Module Class with Online Changeable capability Twin CAT Modules Class Creates a new Twin CAT module class. This is a template generates a basic core module. It has no cyclic caller and no data area, instead it's good as a start point for implementing services called on demand from a caller. For example when creating a C++ method that will be called from a PLC module or another C++ module. See Sample11 [} 268] Twin CAT Module Class with ADS port This template offers the C++ module as well as the functionality of an ADS server and ADS clients. • ADS server: Can run as a single instance of this template of the C++ module and can be preconfigured with a specific ADS port number (e.g. 25023). Enables several instances of this template, whereby each C++ module is assigned its own unique ADS port number by Twin CAT 3 (e.g. 25023, 25024, 25025, ...). The ADS messages can be analyzed and processed thanks to the implementation of the C++ module. ADS handling for accessing input/output data areas does not have to be implemented using its own ADS Message Handling. • ADS Client: This template provides sample codes to initiate an ADS call by sending an ADS message to an ADS partner. 88 Version: 1.18.0 Twin CAT 3

## Page 89

Wizards Since the modules behave like ADS clients or ADS servers that communicate with each other via ADS messages, the two modules (Caller=Client and Called=Server) can run in the same or different real-time contexts on the same or different CPU cores. Because ADS can work across networks, the two modules can also run on different machines in the network. See Sample03 [} 248], ADS Communication [} 194] Twin CAT Module Class with cyclic caller Enables the cyclic call of a C++ program which is cut off from the outside world. Not often used, a module class with cyclic caller and cyclic I/O is preferred. Twin CAT Module Class with cyclic input/output Creates a new Twin CAT module class, which implements the cyclically calling interface and has an input and output data area. The input and output data areas can be linked with other input/output images or with physical I/O terminals. Important: The C++ module has its own logical input/output data storage area. The data areas of the module can be configured with the System Manager. If the module is mapped with a cyclic interface, copies of the input and output data areas exist in both modules (the caller and the called). In this way, the module can run under a different real-time context and even on another CPU core in relation to another module. Twin CAT will continuously copy the data between the modules. See Quick Start [} 61], sample 01 [} 247]. Twin CAT Module Class with data pointer Just like the Twin CAT Module Class with Cyclic IO, this template also generates a new Twin CAT module class that implements a calling interface with an input and output data area for linking with other logic input/ output images or with physical I/O terminals. In addition, this template provides data pointers that can be used to access data areas from other modules via pointers. Important: Unlike in the case of the cyclic I/O data area, where the data is copied cyclically between modules, in the case of the use of C++ data pointers there is only a single data area and this belongs to the destination module. When writing from another C++ module to the destination module via the data pointer mechanism, this will immediately affect the data area of the destination module. (Not necessarily towards the end of a cycle). If the module is executed at runtime, the call occurs immediately, blocking the original process (it is a pointer...). Therefore, both modules (the caller and the called one) must be in the same real-time context and on the same CPU core. The data pointer is configured in the Twin CAT Module Instance Configurator [} 133]. See sample10 [} 267] Twin CAT Module Class for real-time context This template creates a module, which can be instantiated in the real-time context. As described in chapter Twin CAT module state machine [} 47], the other modules have transitions for startup and shutdown in a non-real-time context. In some cases modules have to be started when a real-time is already running, so that all transitions are executed in the real-time context. This is a corresponding Twin CAT 3 Version: 1.18.0 89

## Page 90

Wizards template. The modules with this (modified) state machine can also be used for instantiation directly on startup of Twin CAT. In this case the transitions are executed like for a normal module. The Tc COM 03 sample [} 329] illustrates the application of such a module. Twin CAT Module Class with Online Change capability This option can only be used if the module is added to a Versioned C++ Project. This template creates a module that is capable of Online Change. Due to the revision control of the project, these modules become exchangeable at runtime - it is therefore possible to exchange modules from different versions at runtime. The procedure for this Online Change is described in chapter Online Change [} 152]. The module itself otherwise corresponds to a module with cyclic input/output. 11.3 Twin CAT Module Class Editor (TMC) The Twin CAT Module Class Editor (TMC Editor) is used for defining the class information for a module. It includes data type definitions and their application, provided and implemented interfaces, and data areas and data pointers. To put it briefly: everything that is visible from outside must be defined with this editor. The basic idea is: 1. The TMC Editor can be used to modify the module description file (TMC file). This contains all information that is accessible in the Twin CAT system itself. These are for example symbols, implemented interfaces and parameters. 2. The Twin CAT Code Generator, which can also be called from the TMC Editor, is used to generate all the required C++ code, i.e. header and cpp files. Start the TMC Editor Open the editor by double-clicking on the TMC file of a module. The graphical editor opens: Functionalities of the TMC Editor: • Create/delete/edit symbols in the data areas, e.g. the logical input or output process images of a module. • Create/delete/edit user-defined data type definitions. • Create/delete/edit symbols in the parameter list of a module. 90 Version: 1.18.0 Twin CAT 3

## Page 91

Wizards User Help The TMC Editor offers user support for the definition of data types and C++ modules. For example, in the event of problems (alignment, invalid standard definitions, ...) within the TMC, the user is guided to the relevant location via red markings within the TMC tree: The user can nevertheless edit the TMCs directly, since they are XML files and can therefore be created and edited by the user. Tools The upper section of the TMC editor contains symbols for the required operations. • Reloading of the TMC file and the types from the type system. Twin CAT 3 Version: 1.18.0 91

## Page 92

Wizards • Updating of the higher-level data types. • Switching the User Help [} 91] on/off. • Start the Twin CAT TMC Code Generator: The editor will store the entered information in the TMC file. The Twin CAT TMC Code Generator converts this TMC description to source code, which is also available in the context menu of the Twin CAT C++ project. 11.3.1 Overview User interface • TMC [} 93]: Here you can edit the C++ module vendor's basic information and add an image. • Data types [} 94]: Data types are added, removed, or re-ordered here. • Modules [} 111]: Shows the modules of the driver. • Implemented Interfaces [} 113]: Shows the implemented interfaces of the module. • Parameters [} 113]: Parameters are added, removed, or re-ordered here. ◦ Trace Level Max [} 120]: Parameter that controls the quantity of logged messages; predefined for (almost) every module. • Data Areas [} 121]: Data areas are added, removed, or re-ordered here. • Data Pointers [} 128]: Data pointers are added, removed, or re-ordered here. • Interface Pointers [} 130]: Interface pointers are added, removed, or re-ordered here. • Deployment [} 131]: Determines the files that are provided. 92 Version: 1.18.0 Twin CAT 3

## Page 93

Wizards 11.3.2 Basic Information Basic information on the TMC file can be found here: Information about the provider Name: This is the name of the provider. Choose Image: A 16 x 16 pixel bitmap icon is entered here. Reset image: Resets the module image to the standard value. Versioned Classfactory Name: Displays all class factories referenced from the TMC file. The class factory that implements the C++ project must be set. Typically this is the name of the project. Used only for versioned C++ projects; otherwise "not set" appears here. Version: The current version, consisting of four digits, each separated by a ".". At least one digit must not be 0. Optional features Generated by: This field indicates who created the file and who will maintain it. Please note that changes are no longer possible in the TMC Editor when filling out this field (deactivates all editing procedures). Comment: Optionally, you can enter a comment here. 11.3.3 Data Types The user can define data types via the Twin CAT Module Class (TMC) editor. Twin CAT 3 Version: 1.18.0 93

## Page 94

Wizards These data types can be type definitions, structures, areas, enumerations or interfaces, e.g. methods and their signatures. The Twin CAT Engineering system (XAE) publishes these data types in relation to all other nested projects of the Twin CAT project, so that they can also be used in PLC projects, for example (as described in chapter Sample11: Module communication: method call PLC module to C++ module [} 268]). NOTICE Name conflict A name collision can occur if the driver is used in combination with a PLC module. • Do not use any of the keywords that are reserved for the PLC as names. This chapter describes how to use the capabilities of the TMC Editor for defining data types. 11.3.3.1 Overview User interface 94 Version: 1.18.0 Twin CAT 3

## Page 95

Wizards Symbol Function Add a new data type. Add a new interface. Delete the selected type. Move the selected element one place downwards. Move the selected element one place upwards. Search for unused types. Select byte alignment. Align selected data type (Alignment) . This function runs through all data types used (recursion). Is this is not desired, a step-by-step approach can be adopted, by using the function within the data types. Reset data format of the selected data type. Copy Paste Data type properties Name: user-defined name of the data type. GUID: unique ID of the data type. Specification: specification of the data type. Size: size of the data type, if expressly specified. Size X64: different size of the data type for the x64 platform. 11.3.3.2 Add / modify / delete data types Data types used by Twin CAT C++ modules can be added, edited and deleted with the help of the Twin CAT Module Class (TMC) editor. This article describes: • Step 1: Create a new data type [} 95] in the TMC file. • Step 2: Start the Twin CAT TMC Code Generator [} 98] in order to generate C++ code on the basis of a module description in the TMC file. • Using [} 111] the data types. Step 1: Generate a new data type 1. After starting the TMC Editor, select the Data Types node. 2. Extend the list of data types and interfaces by a new data type by clicking on the + button Add a new data area. Twin CAT 3 Version: 1.18.0 95

## Page 96

Wizards ð A new data type is then listed as a new entry: 3. Select the generated "Data Type1" in order to obtain details of the new data type. 4. Specify [} 105] the data type. 5. Rename the data type. In this sample st Sensor Data, select the specification STRUCT and click on Edit Struct. 96 Version: 1.18.0 Twin CAT 3

## Page 97

Wizards 6. Insert new sub items in the structure by clicking on the Add a new sub item button. 7. You can edit the properties by double-clicking on the sub item. Give the sub item a new name and select a suitable data type. 8. Give the other sub items a new name and select a suitable data type. 9. Save the changes you have made in the TMC file. Twin CAT 3 Version: 1.18.0 97

## Page 98

Wizards Step 2: Start the Twin CAT TMC Code Generator to generate code for the module description. 1. Right-click on your project file and select Twin CAT TMC Code Generator to generate the source code for your data type: ð You can see the data type declaration in the module header file "Untitled1Services.h" ð If you add a further data type or a further sub-element, run the Twin CAT TMC Code Generator again. 98 Version: 1.18.0 Twin CAT 3

## Page 99

Wizards 11.3.3.3 Add / modify / delete Interfaces Interfaces of a Twin CAT module can be added, edited and deleted with the help of the Twin CAT Module Class (TMC) editor. This article describes: • Step 1: Create a new interface [} 99] in the TMC file. • Step 2: [} 99]Add methods [} 99] to the interface in the TMC file. • Step 3: Use the interface [} 101] by adding it to the "Implemented Interfaces" of the module. • Step 4: Start the Twin CAT TMC [} 103] Code Generator to generate code for the module description. • Optional change of the interface [} 103]. Step 1: generate a new interface 1. After starting the TMC Editor, select the Data Types node. 2. Click on Add a new interface to extend the list of interfaces by a new interface. ð A new entry IInterface1 is then listed: 3. To open the details you can either select the appropriate node in the tree or double-click on the row in the table. 4. Enter a meaningful name - in this sample "IState Machine". Step 2: add methods to the interface 1. Click on Edit Methods... to get a list of the methods of this interface: Twin CAT 3 Version: 1.18.0 99

## Page 100

Wizards 2. Click on the + button to generate a new default method, "Method1". 3. Double-click on the method or select a node in the tree to open the details. 4. Give the default "Method1" a more meaningful name. 5. Subsequently, you can add parameters by clicking on Add a new parameter or edit parameters of the "Set State" method. ð The new parameter, "Parameter1", is generated by default as "Normal Type" "INTEGER". 6. Edit the parameter by clicking on the name "Parameter1". ð The "Normal Type" can also be changed to "Pointer" and so on – the data type itself can also be selected. ð In this case "New State" is the new name – the rest of the settings are not changed. 100 Version: 1.18.0 Twin CAT 3

## Page 101

Wizards 7. By repeating step 2 "Add methods to interface", all methods are listed – you can re-order the methods with the help of the move up / move down button. 8. The interface is ready to be implemented by your module. Step 3: Add the new interface to Implemented Interfaces 1. Select the module that is to be extended by the new interface - in this case select the destination Modules->CModule1. 2. Extend the list of implemented interfaces by a new interface with Add a new interface to the module by clicking on the + button. Twin CAT 3 Version: 1.18.0 101

## Page 102

Wizards 3. All available interfaces are listed - select the new template "IState Machine" and end with OK. ð The new interface "IState Machine" is part of the module description. 102 Version: 1.18.0 Twin CAT 3

## Page 103

Wizards Step 4: Start the Twin CAT TMC Code Generator to generate code for the module description. 1. In order to generate the C/C++ code on the basis of this module description, right-click in the C/C++ project and then select the Twin CAT TMC Code Generator. ð The module "Module1" then contains the new interfaces CModule1: Start() CModule1: Stop() CModule1: Set State(SHORT New State). ð Done – the user-defined code can now be inserted in this area. Optional change of the interface User-defined code will never be deleted In the case of changes to the interface (e.g. the parameters of a method will be extended later), the user-defined code will never be deleted. Instead, the existing method will merely be provided with a comment if the TMC Code Generator cannot map the methods. Twin CAT 3 Version: 1.18.0 103

## Page 104

Wizards 104 Version: 1.18.0 Twin CAT 3

## Page 105

Wizards 11.3.3.4 Data type properties Editing the properties of data types General properties Name: user-defined name of the data type. Twin CAT 3 Version: 1.18.0 105

## Page 106

Wizards NOTICE Name conflict A name collision can occur if the driver is used in combination with a PLC module. • Do not use any of the keywords that are reserved for the PLC as names. Namespace: user-defined namespace of the data type. Please note that this is not assigned to a C namespace. It is used as the prefix to your data type. Sample: an enumeration with a namespace "A": The following code is generated: ///<Auto Generated Content id="Data Types"> #if !defined(_TC_TYPE_41D4A207_3A09_4316_9D89_0DD1881AB8C4_INCLUDED_) #define _TC_TYPE_41D4A207_3A09_4316_9D89_0DD1881AB8C4_INCLUDED_ enum A_ASample Enum : SHORT { One, Two, Three }; #endif // !defined(_TC_TYPE_41D4A207_3A09_4316_9D89_0DD1881AB8C4_INCLUDED_) You may wish to manually append the namespace name to the enumeration element as a prefix: #if !defined(_TC_TYPE_C26FED5F_AC13_4FD3_AC6F_B658CB5604E0_INCLUDED_) #define _TC_TYPE_C26FED5F_AC13_4FD3_AC6F_B658CB5604E0_INCLUDED_ enum B_BSample Enum : SHORT { B_one, B_two, B_three }; #endif // !defined(_TC_TYPE_C26FED5F_AC13_4FD3_AC6F_B658CB5604E0_INCLUDED_) GUID: unique ID of the data type. Specification: specification of the data type. • Alias: generate an alias of a standard data type (e.g. INT). • Array [} 108]: create a user-defined array. • Enumeration [} 108]: create a user-defined enumeration. • Struct [} 109]: generate a user-defined structure. • Interface [} 109]: generate a new interface. Select data type Select: Select data type – it can be a basic Twin CAT data type or a user-defined data type. Data types equivalent to the PLC data types are defined (like TIME, LTIME, etc.). See Data Types of the PLC for further information. Description: Define the type as pointer, reference or value by means of the appropriate selection. • Normal type • Pointer 106 Version: 1.18.0 Twin CAT 3

## Page 107

Wizards • Pointer to pointer • Pointer to pointer to pointer • a reference Type information • Namespace: Defined for selected data type. • GUID: Unique ID of the selected data type. Optional data type settings Size [Bits]: Size in bits (white fields) and in "Byte. Bit" notation (grey fields). A different size can be defined for the x64 platform. C/C++ Name: name used in the generated C++ code. The TMC code generator will not generate the declaration, so that user-defined code can be provided for this data type. Beyond that a different name can be defined for x64. Unit: a unit of the variable. Comment: comment that is visible, for example, in the instance configurator. Hide sub items: If the data type has sub-elements, the System Manager will not allow the sub-elements to be accessed. This should be used, for example, in the case of larger arrays. Persistent (even if unused): Persistent type in the global type system (cf. System->Type System->Data Types). Optional Defaults Depending on data type the default could be defined. Optional Properties A table of name, value and description for annotating the data type. This information is provided within the TMC and also TMI files. Twin CAT functions as well as customer programs can use these properties. Datatype Hides Listed GUIDs refer to data types which are hidden by this data type. Normally, GUIDs of previous versions of this data type are inserted here automatically on each change. 11.3.3.5 Specification This section describes the specification of data types. Twin CAT 3 Version: 1.18.0 107

## Page 108

Wizards 11.3.3.5.1 Array Array: Create a user-defined array. A new dialog is shown for adding (+) or removing (-) array elements. Dimension: Dimension of the array. LBound: Left limit of the array (default value = 0). Elements: Number of elements. Dynamic arrays for parameters and data pointers In the case of parameters [} 113] and data pointers [} 128], Twin CAT 3 supports arrays with a dynamic size. Min: Minimum size of the array. Max: Maximum size of the array. Max is unbounded: Indicates that there is no upper limit for the array size. 11.3.3.5.2 Enum Enumeration: Create a user-defined enumeration. A new dialog is shown for adding (+) or removing (-) an element. Edit the order with the help of the arrows. NOTICE Unique names are required for enumeration elements Please note that the enumeration elements must have unique names, as otherwise the C++ code generated is invalid. Text: Enumeration element Enum: Suitable integer value. 108 Version: 1.18.0 Twin CAT 3

## Page 109

Wizards Comment: Optional comment. 11.3.3.5.3 Struct Struct: Creating a user-defined structure. Select the Sub Items node or click on the Edit Struct button to switch to this table: A new dialog is shown for adding (+) or removing (-) an element. Edit the order with the help of the arrows. Name: Name of the element. Specification: A struct can contain aliases, arrays or enumerations. Type: Type of the variable. Size: Size and offset of the sub-element. Size X64: Other size for the x64 platform will additionally be provided. Unit: Optional unit. The details of the configuration page of the sub-element are shown by selecting the data type or double- clicking on the table entry. Similar to Data type properties [} 105]. 11.3.3.5.4 Interfaces Interfaces: Creating a user-defined interface. Twin CAT 3 Version: 1.18.0 109

## Page 110

Wizards Select the Methods node or click on the Edit Methods button to switch to this table: Method parameters Select the Methods node or double-click on the entry to view the details of the method. Name: The name of the method. RPC enable: Enable remote procedure calls from outside this method. Include Return Value: Enable sharing of the method's return value. 110 Version: 1.18.0 Twin CAT 3

## Page 111

Wizards The fields correspond to those of the Data type properties [} 105]. Defining the method parameters • Name: • Type: Known from the Data type properties [} 105]. • Description: Known from the Data type properties [} 105]. • Default Value: Default value of this parameter; only numbers are allowed. • RPC direction: As in the case of PLC function blocks, each parameter can either be IN, OUT or INOUT. Over and above that, it can be defined as NONE so that this parameter is ignored in the case of remote procedure calls (RPC). 11.3.4 Modules Modules: Displays the modules of the driver. Class Name: Name of the module. Class ID: Unique ID of the module. Module Properties: Click on the node in the tree or the row in the table to open the module properties. Twin CAT 3 Version: 1.18.0 111

## Page 112

Wizards General properties Name: Name of the module. Class ID: Unique module ID. Auto generate on save: Enables Twin CAT to generate the Class ID via the module parameters during saving. If the Class ID changes during import of the binary modules, the corresponding Class IDs have to be adjusted. Thus, Twin CAT can detect the interface change. Choose Image: Add a 16x16 pixel bitmap symbol. Reset image: Reset the module image to the default value. Init sequence: Start the state machine. The selection options with 'late' in the name are internal. (See Object [} 134] of the instance configurator for further information.) Instantiable in RT Context: Indicates whether this module can be instantiated under real-time context; see Twin CAT Module Class Wizard [} 88] Defining the contexts of the module You can add (+) or remove (-) contexts for the module. Edit the order with the help of the arrows. The context ID must be an integer other than 0. Optional Properties 112 Version: 1.18.0 Twin CAT 3

## Page 113

Wizards A table of name, value and description for annotating the module. This information is provided within the TMC and also TMI files. Twin CAT functions as well as customer programs can use these properties. 11.3.4.1 Implemented Interfaces Implemented Interfaces: View and edit the implemented interfaces of the module. Name: Name of the interface. Interface ID: Unique ID of the interface. Disable Code Generation: Enable/disable code generation. You can add (+) or remove (-) contexts for the module. Edit the order with the help of the arrows. 11.3.4.2 Parameters A Tc COM module instance is defined through various parameters. Twin CAT 3 Version: 1.18.0 113

## Page 114

Wizards Twin CAT supports three types of Parameter IDs (PTCID) in the section Configuring the parameter ID [} 119]. • "User defined" (default value for new parameters): A unique parameter ID is generated, which can be used in the user code or in the instance configuration for specifying the parameter. • "Predefined...": Special PTCIDs provided by the Twin CAT 3 system (e.g. Tc Trace Level). • "Context-based…": Automatically assign values of the configured context [} 135] to this parameter. The selected property is applied to the PTCPID. It overwrites the defined standard parameters and the instance configuration parameter (parameter (Init)). The parameters and their configuration are described in more detail below. Parameters: Shows the implemented parameters of the module. Symbol Function Add a new parameter Deletes the selected type Moves the selected element down one position Moves the selected element up one position Select byte alignment Align the selected data type Reset data format of the selected data type Name: Name of the interface. Parameter ID: Unique ID of the parameter. Specification: Data type of the parameter. Size: Size of the parameter. Other sizes are possible for x64. Context: Context ID of the parameter. Disable Code Generation: Enable/disable code generation. 11.3.4.2.1 Add / modify / delete parameters The properties and functionalities of a Twin CAT class can be added, edited and deleted with the aid of the Twin CAT Module Class (TMC) Editor. This article describes: 114 Version: 1.18.0 Twin CAT 3

## Page 115

Wizards • Step 1: Create a new parameter [} 115] in the TMC file. • Step 2: Start the Twin CAT TMC Code Generator [} 116] to generate code for the module description in the TMC file. • Step 3: Observe the transitions of the state machine [} 117] Step 1: Create new parameters 1. After starting the TMC Editor, select the target Parameters. 2. Extend the list of parameters by a new parameter by clicking on the + button Add a new parameter. ð A new "Parameter" is then listed as a new entry: 3. Select Parameter in the left-hand tree or double-click on the red-marked "Parameter3" or select the node in the tree to obtain details of the new parameter. 4. Configure the parameter as well as the Data Types [} 93]. 5. Give it a more meaningful name – in this sample "b Enable" – and select the data type "BOOL". 6. Save the changes you have made in the TMC file. Twin CAT 3 Version: 1.18.0 115

## Page 116

Wizards Step 2: Start the Twin CAT TMC Code Generator to generate code for the module description. 1. Right-click on your project file and select Twin CAT TMC Code Generator to receive the parameters in your source code: ð You can see the parameter declaration in the header file "Module1.h" of the module. 116 Version: 1.18.0 Twin CAT 3

## Page 117

Wizards ð The implementation of the new parameter can be found in the get and set methods of the module class "module1.cpp". To add a further parameter, use the Twin CAT TMC Code Generator again. Step 3: Transitions of the state machine Note the different state transitions of your state machine [} 47]: Twin CAT 3 Version: 1.18.0 117

## Page 118

Wizards The parameters are set during the transition from Init to Preop and, if applicable, from Preop to Safeop. 11.3.4.2.2 Parameter properties Parameter properties: Edit the properties of the parameter. 118 Version: 1.18.0 Twin CAT 3

## Page 119

Wizards General properties Name: Name of the interface. Specification: Data type of the parameter, see specification. Select data type Select: Select data type. Type information • Namespace: user-defined namespace of the data type. • GUID: unique ID of the data type. Enter a unique ID Value: Enter a unique ID value, see Parameter [} 113]. Constant Name: source code name of the parameter ID. Optional parameter settings Size [Bits]: Calculated size in bits (white fields) and in "Byte. Bit" notation (grey fields). A special size configuration is provided for x64. Unit: a unit of the variable. Comment: Comment that is visible, for example, in the instance configurator. Context ID: Context used when accessing parameters by ADS. Create Symbol: Default setting for ADS icon creation. Twin CAT 3 Version: 1.18.0 119

## Page 120

Wizards Disable Code Generation: Enable/disable the code generation. Hide parameter: Switches between showing/hiding parameters in the System Manager view. Hide sub items: If the data type has sub-elements, the System Manager will not allow the sub-elements to be accessed. This should be used, for example, in the case of larger arrays. Online parameter: Define as online parameter. Read-only: Switch to read-only access for System Manager. Optional Properties A table of name, value and description for annotating the parameter. This information is provided within the TMC and also TMI files. Twin CAT functions as well as customer programs can use these properties. 11.3.4.2.3 Trace Level Max Trace Level Max: Parameter that defines the trace level. This is a predefined parameter that most Twin CAT module templates provide (except the empty Twin CAT module template). The settings for this parameter should not be changed. See Module messages for the Engineering (logging / tracing) [} 216] 120 Version: 1.18.0 Twin CAT 3

## Page 121

Wizards 11.3.4.3 Data Areas Data Areas: Dialog for editing the data areas of your module. Symbol Function Add a new data area Deletes the selected data area Moves the selected element down one position Moves the selected element up one position Select byte alignment Align the selected data type Reset the data format of the selected area NOTICE Recursion when setting an alignment When setting the alignment of a data area, this will be taken as the basis for all of its elements (symbols and also their sub-elements). User-defined alignment will be overwritten. Number: Number of the data area. Type: Defines the purpose and location of the data area. The data areas for mapping (to other modules as well as I/O) are classified into input and output as well as source and destination. The chart illustrates this: Name: Name of the data area. Size: Size of the parameter; other sizes are possible for x64. Context: Displays the context ID. Disable Code Generation: Enable/disable code generation. Twin CAT 3 Version: 1.18.0 121

## Page 122

Wizards 11.3.4.3.1 Add / modify / delete data areas and variables The properties and functionalities of a Twin CAT class can be added, edited and deleted with the aid of the Twin CAT Module Class (TMC) Editor. This article describes: • Creation of a new data area in the TMC file. • Creating [} 127] new variables in a data area. • For example, edit the name or data type [} 127] of variables existing in the TMC file. • Delete existing variables [} 128] from the TMC file. Creating a new data area 1. After starting the TMC Editor, select the Data Areas node of the module. 2. Click on the + button, thus creating a new data area. 3. In order to obtain the properties of the data area, double-click on the table or on the node. 4. Rename the data area. Creating a new variable 1. Select the sub-node Symbols of the data area. 2. Extend this data area by a new variable by clicking on the + button. A new entry "Symbol4" is then listed. Editing the name or data type of existing variables 1. Select the sub-node Symbol4 or double-click on the row. The variable properties are shown. 122 Version: 1.18.0 Twin CAT 3

## Page 123

Wizards 2. Enter a new name, e.g. "b Enable Job" and change the type to BOOL. ð The new variable "b Enable Job" is created in the data area "Input". Remember to run the TMC Code Generator again. Deleting existing variables 1. To delete existing variables from the data area, select the variable and then click on the delete icon: in this sample, select "Machine Status1" and click on the Delete icon. 2. Run the TMC Code Generator again. 11.3.4.3.2 Data Areas Properties Data Areas Properties: Dialog for editing the data area properties. Twin CAT 3 Version: 1.18.0 123

## Page 124

Wizards General properties Number: Number of the data area. Type: Defines the purpose and location of the data area. The following are available: Linkable data areas in the System Manager: • Input-Source • Input-Destination • Output-Source • Output-Destination • Retain-Source (for use with NOV-RAM memory, see appendix [} 338]) • Retain-Destination (for internal use) Further data areas: • Standard (visible but not linkable in the System Manager) • Internal (for internal module symbols, which can be reached via ADS but are not visible in the System Manager) • MArea (for internal use) 124 Version: 1.18.0 Twin CAT 3

## Page 125

Wizards • Not specified (same as standard) Name: Name of the data area. Optional parameter settings Size [Bytes]: Size in bytes. A special size configuration is provided for x64. Comment: Optional comment that is visible, for example, in the instance configurator. Context ID: Context ID of all symbols of this data area; used for the determination of the mapping. Data type name: If specified, a data type with the specified name is created in the type system. Create Symbol: Default setting for ADS icon creation. Disable Code Generation: Enable/disable the code generation. Optional Defaults Depending on data type the default could be defined. Optional Properties A table of name, value and description for annotating the data area. This information is provided within the TMC and also TMI files. Twin CAT functions as well as customer programs can use these properties. 11.3.4.3.3 Symbol Properties Symbols: Dialog for the editing of the symbols of the data area. Twin CAT 3 Version: 1.18.0 125

## Page 126

Wizards General properties Name: Name of the symbol. Specification: Data type of the symbol, see Data type properties [} 105]. Select data type Select: Select data type – it can be a basic Twin CAT data type or a user-defined data type. Description: Define whether the type is the following: • Normal type • Pointer • Pointer to pointer • Pointer to pointer to pointer • a reference Type information • Namespace: Namespace for selected data type. • GUID: unique ID of the data type. Optional data type settings Offset [Bits]: Offset of the symbol within the data area; a different offset can be defined for the x64 platform. Size [Bits]: Size in bits, if specified. A different size can be defined for the x64 platform. Comment: Optional comment that is visible, for example, in the instance configurator. Create Symbol: Default setting for ADS icon creation. Hide sub items: If a variable has sub-elements, then the System Manager will not allow the sub-elements to be accessed. This should be used, for example, in the case of larger arrays. 11.3.4.3.3.1 Symbol properties Data Areas Symbols Properties: Dialog for editing the symbol properties. 126 Version: 1.18.0 Twin CAT 3

## Page 127

Wizards General Properties Name: Name for the interface Specification: Data type of the parameter Available specifications are: • Alias: Create an alias of a default data type (e.g. INT) • Array: Create a user specific array • Enumeration: Create a user specific enum • Struct: Create a user specific structure • Interface: Create a new interface Define the data type Select: Select data type Description: Define description Type Information Name: Name of the selected default type Namespace: User-defined namespace for the data type GUID: Unique ID of the data type Twin CAT 3 Version: 1.18.0 127

## Page 128

Wizards Optional data type settings Offset [Bits]: Memory offset Size [Bits]: Calculated size in bits Unit: Optional Comment: Optional Create symbol: Default setting for ADS symbol creation 11.3.4.4 Data Pointers Data Pointer: Dialog for editing the data pointers of your module. Symbol Function Add a new data pointer Deletes the selected data pointer Moves the selected element down one position Moves the selected element up one position Name: Name of the data pointer. Parameter ID: Unique ID of the parameter. Type: Defines the pointer type. Context: Displays the context ID. Disable Code Generation: Enable/disable code generation. 11.3.4.4.1 Properties Data Pointer Properties: Edit the properties of the data pointer. 128 Version: 1.18.0 Twin CAT 3

## Page 129

Wizards General properties Name: Name of the data pointer. Define the data type Select: Select data type. Type information • Name: Name of the selected data type. • GUID: unique ID of the data type. Define the dimension of the array See chapter Array [} 108]. Configuring the parameter ID Enter a unique ID Value: Enter a unique ID value, see Parameter [} 113]. Constant Name: source code name of the parameter ID. Optional data pointer settings Comment: Comment that is visible, for example, in the instance configurator. Context ID: Context ID of the data pointer. Disable Code Generation: Enable/disable the code generation. Twin CAT 3 Version: 1.18.0 129

## Page 130

Wizards 11.3.4.5 Interface Pointers Interface Pointers: Add, remove and rearrange interface pointers. Symbol Function Add interface pointers Deletes the selected pointer Moves the selected element down one position Moves the selected element up one position Name: Name of the interface. Parameter ID: Unique ID of the interface pointer. Type: Type of the interface pointer. Context: Context of the interface. Disable Code Generation: Enable/disable the code generation. 11.3.4.5.1 Properties Interface Pointer Properties: Edit the properties of the interface pointer. 130 Version: 1.18.0 Twin CAT 3

## Page 131

Wizards General properties Name: Name of the interface pointer. Select the basic interface Select: Selection of the interface. Type information • Namespace: Namespace of the interface. • GUID: Unique ID of the interface. Configure the parameter ID See Parameters [} 113]. Comment: Optional Context ID: Context ID of the interface pointer. Disable Code Generation: Enable/disable the code generation. 11.3.4.6 Deployment Deployment: Specify storage locations for the provided modules on the target system. The entries are empty for versioned C++ projects with their modules and are not needed. Twin CAT 3 Version: 1.18.0 131

## Page 132

Wizards Symbol Function Add a new file entry Delete a file entry Moves the selected element down one position Moves the selected element up one position This dialog enables configuration of the source and target file, which are transferred to the target system for the respective platforms. Define the files, which should be deployed. Source File: Path to the source files. Destination file: Path to the binary files. Rename Destination: Destination file will be renamed before the new file is transferred. Since this is required for Windows 10, it is done implicitly. The individual entries can be expanded and collapsed by the + or – respectively at the beginning. Evaluate: Puts the calculated value into the text field for verification. Insert: Adds the variable name selected in the dropdown list. Add or remove specific file entries Remove symbol file entries: Removes the entries for the provision of symbol files (PDB). Remove all entries: Removes all entries. Reset to default: Sets the standard entries. Add default file entries: Adds the entries for the selected platform. 132 Version: 1.18.0 Twin CAT 3

## Page 133

Wizards Remove file entries: Removes the entries for the selected platform. Source and target paths for the allocation may contain virtual environment variables, which are resolved by the Twin CAT XAE / XAR system. The following table shows the list of these supported virtual environment variables. Virtual environment vari- Registry entry (REG_SZ) under key Default value Default value able \HKLM\Software\Beckhoff\Twin CAT3 (Windows) (Twin CAT/BSD) %TC_INSTALLPATH% Install Dir C:\Twin CAT\3.1\ /usr/local/etc/ Twin CAT/3.1/ %TC_CONFIGPATH% Config Dir C:\Twin CAT\3.1 /usr/local/etc/ \Config\ Twin CAT/3.1/ Config/ %TC_TARGETPATH% Target Dir C:\Twin CAT\3.1 /usr/local/etc/ \Target\ Twin CAT/3.1/ Target/ %TC_SYSTEMPATH% System Dir C:\Twin CAT\3.1 /usr/local/etc/ \System\ Twin CAT/3.1/ System/ %TC_BOOTPRJPATH% Boot Dir C:\Twin CAT\3.1 /usr/local/etc/ \Boot\ Twin CAT/3.1/ Boot/ %TC_RESOURCEPATH% Resource Dir C:\Twin CAT\3.1 /usr/local/etc/ \Target\Resource\ Twin CAT/3.1/ Target/Resource/ %TC_REPOSITORYPATH% Repository Dir C:\Twin CAT\3.1 /usr/local/etc/ \Repository\ Twin CAT/3.1/ Repository %TC_DRIVERPATH% Driver Dir C:\Twin CAT\3.1 not available \Driver\ %TC_DRIVERAUTOINSTAL Driver Auto Install Dir C:\Twin CAT\3.1 /usr/local/etc/ LPATH% \Driver\Auto Install\ Twin CAT/3.1/ %CLASSFACTORYNAME% <Name of the <Name of the Class Factory> Class Factory> 11.4 Twin CAT Module Instance Configurator The Twin CAT 3 Modules Class (TMC) editor described above defines drivers at class level. These are instantiated and have to be configured via the Twin CAT 3 instance configurator. The configuration applies to the context (including the task calling the module), parameters and pointers. Instances of C++ classes are created by right-clicking on the C++ project folder; see quick start [} 61]. This chapter describes the configuration of these instances in detail. Double-click on the generated instance to open the configuration dialog with several windows. Twin CAT 3 Version: 1.18.0 133

## Page 134

Wizards 11.4.1 Object • Object Id: The object ID used for identifying this instance in the Twin CAT system. • Object Name: Name of the object used for displaying the instance in the Solution Explorer tree. • Type Name: Type information (class name) of the instance. • GUID: Module classes GUID. • Class Id: Class ID of the implementation class (GUID and Class Id are usually identical). • Class Factory: Refers to the driver that provides the class factory used to create an instance of the module. • Parent Id: Contains the Object ID of the parent, if available. • Init Sequence: Specifies the initialization states for determining the startup behavior of the interacting modules. See Twin CAT module state machine [} 47] for detailed description of the state machine. Specifying the startup behavior of several Tc COM instances Tc COM instances can refer to each other - e.g. for the purpose of interaction via data or interface pointers. To determine the startup behavior, the Init Sequence specifies states to be "held" by each Tc COM instance for all other modules. The name of an Init Sequence consists of the short name of the Tc COM state machine. If the short name of a state (I, P, S, O) is included in the name of the Init Sequence, the modules will wait in this state, until all other modules have reached at least this state. In the next transition the module can refer to all other module instances, in order to be in this state as a minimum. If, for example, a module has the Init Sequence "PS", the IP transitions of all other modules are executed, so that all modules are in "Preop" state. This is followed by the PS transition of the module, and the module can rely on the fact that the other modules are in "Preop" state. 134 Version: 1.18.0 Twin CAT 3

## Page 135

Wizards • Copy TMI to target: Generating the TMI (Twin CAT Module Instance) file and transferring it to the target. 11.4.2 Context • Context: Select the context to be configured (see TMC Editor for adding different contexts). A data area is assigned to a context. • Data Areas / Interfaces / Data Pointer and Interface Pointer: Each instance can be configured to have or not have elements defined in TMC. • Result Table: List of the IDs that need to be configured. At least the context ("Task" column) of the task must be configured accordingly. 11.4.3 Parameter (Init) The list of all parameters (as defined in TMC) can be initialized with values for each instance. Special Parameter IDs (PTCID) are used to set the values automatically. These are configured using the TMC Editor's parameter dialog window as described in Parameters [} 113]. The CS (Create Symbol) checkbox creates the ADS symbol for each parameter, so it can be accessed from outside. Twin CAT 3 Version: 1.18.0 135

## Page 136

Wizards 11.4.4 Data Area List of all data areas and their variables (as defined in TMC). The CS (Create Symbol) checkbox creates the ADS symbol for each parameter, so the variable is accessible from the outside. 11.4.5 Interfaces List of all implemented interfaces (as defined in TMC). 11.4.6 Interface Pointer List of all interface pointers (as defined in TMC). Special Parameter IDs (PTCID) are used to set the values automatically. These are configured using the TMC Editor's parameter dialog window as described in Parameters [} 113]. The OTCID column defines the pointer to the instance to be used. 11.4.7 Data Pointer List of all data pointers (as defined in TMC). 136 Version: 1.18.0 Twin CAT 3

## Page 137

Wizards Special Parameter IDs (PTCID) are used to set the values automatically. These are configured using the TMC Editor's parameter dialog window as described in Parameters [} 113]. The OTCID column defines the pointer to the instance to be used. 11.5 Customer-specific project templates Twin CAT 3 is embedded in Visual Studio and thus also uses the project management provided. Twin CAT 3 C++ projects are "nested projects" in the Twin CAT project folder (Twin CAT Solution). This section of the documentation describes how customers can realize their own project templates. 11.5.1 Overview When a Twin CAT C/C++ project is created, the Twin CAT C++ Project Wizard is started first. The latter generates a framework for a Twin CAT Versioned C++ Project. The actual function is implemented in Twin CAT modules. The Twin CAT Class Wizard is automatically started on creating a new project in order to add the first module. The different modules are generated by the same Twin CAT Class Wizard, but the specific design of the module is realized using templates. Twin CAT 3 Version: 1.18.0 137

## Page 138

Wizards 11.5.2 Files involved Virtually all relevant information is contained in the directory C: \Twin CAT\3.1\Components\Base\Cpp Template: The Twin CAT C++ Project Wizard calls the Twin CAT Module Class Wizard if a Driver Project is to be created. Directory: Driver and Class The respective project types are defined in the Driver directory (for Twin CAT C++ Project Wizard) and Class directory (for the Twin CAT Module Class Wizard), each project type encompassing 3 files: The .vsdir file provides information that is used when the respective assistant wizard is started. This is essentially a name, a brief description and a file name of the type .vsz containing details for this project type. The general description in MSDN can be found here https://msdn.microsoft.com/de-de/library/ Aa291929%28v=VS.71%29.aspx. The .vsz file referenced in the .vsdir file provides information that is needed by the wizard. The most important information here is the wizard that is to be started and a list of parameters. Both wizards have a .xml file as a parameter that describes the transformations of, for example, source files from the template to the specific project. These are located together with the templates for the source code, etc. in the Templates directory. If a driver is to be created, the Twin CAT C++ Project Wizard starts the Twin CAT Module Class Wizard via the Trigger Add Module parameter. The general description in the MSDN can be found here: https://msdn.microsoft.com/de-de/library/ Aa291929%28v=VS.71%29.aspx. The .ico file merely provides an icon. Directory: Templates Both the templates for the source code and the .xml file named in the .vsz file for the Twin CAT Module Class Wizard are located in corresponding subdirectories in the Templates directory. This .xml file describes the procedure for getting from the template to a real project. 11.5.3 Transformations Transformation description (XML file) The configuration file describes (in XML) the transformation of the template files into the project folder. In the normal case these will be .cpp / .h and, if applicable, project files; however, all types of files can be handled. The root node is a <Project File Generator Config> element. The use Project Interface="true" attribute can be set directly at this node. It sets the processing procedure in the Visual Studio mode to generate projects (as opposed to TC-C++ modules). 138 Version: 1.18.0 Twin CAT 3

## Page 139

Wizards Several <File Description> elements, each of which describes the transformation of a file, follow here. After these elements there is a possibility to define symbols that are available for the transformation in a <Symbols> element. Transformation of the template files A <File Description> element is structured as follows: <File Description open File="true"> <Source File>File In Templates Directory.cpp</Source File> <Target File>[!output SYMBOLNAME].cpp</Target File> <Filter>Source Files</Filter> </File Description> • The source file from the templates directory is specified as the <Source File>. • The target file in the Project directory is specified as the <Target File>. A symbol is normally used by means of the [!output...] command. • The attribute "copy Only" can be used to specify whether the file should be transformed, i.e. whether the transformations described in the source file are executed. Otherwise the file is merely copied. • The "open File" attribute can be used to specify whether the file is to be opened after creation of the project in Visual Studio. • Filter: A filter is created in the project. To do this the use Project Interface="true" attribute must be set at the <Project File Generator Config>. Transformation instructions Commands that describe the transformations themselves are used in the template files. The following commands are available: • [!output SYMBOLNAME] This command replaces the command by the value of the symbol. A number of predefined symbols are available. • [!if SYMBOLNAME], [!else] and [!endif] describe a possibility to integrate corresponding text only in certain situations during the transformation. Symbol name Symbol names can be provided for the transformation instructions in 3 ways. These are used by the commands described above in order to carry out replacements. 1. A series of predefined symbols directly in the configuration file: A list of <Symbols> is provided in the XML file. Symbols can be defined here: <Symbols> <Symbol> <Name>Customer Symbol</Name> <Value>Customer String</Value> </Symbol> </Symbols> 2. The generated target file names can be provided by adding the "symbol Name" attribute: <Target File symbol Name="Customer File Name">[!output SYMBOLNAME].txt</ Target File> 3. Important symbols are provided by the system itself. Twin CAT 3 Version: 1.18.0 139

## Page 140

Wizards Symbol Name (Projects) Description PROJECT_NAME The project name from the Visual Studio dialog. PROJECT_NAME_UPPERCASE The project name in upper case letters. WIN32_WINNT 0x0400 DRVID Driver ID in the format: 0x03010000 PLATFORM_TOOLSET Toolset version, e.g. v100 PLATFORM_TOOLSET_ELEMENT Toolset version as an XML element, e.g. <Platform Toolset>v100</Platform Toolset> NEW_GUID_REGISTRY_FORMAT Creates a new GUID in the format: {48583F97-206A-4C7C-9EF2-D5C8A31F7BDC} Symbol Name (Classes) Description PROJECT_NAME The project name from the Visual Studio dialog. HEADER_FILE_NAME Entered by the user in the wizard dialog. SOURCE_FILE_NAME Entered by the user in the wizard dialog. CLASS_NAME Entered by the user in the wizard dialog. CLASS_SHORT_NAME Entered by the user in the wizard dialog. CLASS_ID A new GUID created by the wizard. GROUP_NAME C++ TMC_FILE_NAME Used to identify the TMC file. NEW_GUID_REGISTRY_FORMAT Creates a new GUID in the format: {48583F97-206A-4C7C-9EF2-D5C8A31F7BDC} 11.5.4 Notes on handling Template in customer-specific directory Templates can also be stored outside of the usual Twin CAT directory. 1. In the registry, expand the search path (in this case V12.0, i.e. for VS 2013) in which the node /2 is created: Registry Key: HKEY_CURRENT_USER\Software\Microsoft\Visual Studio\12.0_Config\Projects\ {B9B2C4C6-072A-4B72-83C1-77FD2DEE35AB} \Add Item Templates\Template Dirs\{3d3e7b23-b958-4a99-bfee-d0d953c182d4}\ 2. Increase the Sort Priority. 3. Recommendation: in the directory, create a subdirectory called Class, which is entered in the registry, and a subdirectory called Templates in order to separate the .vsz / .vsdir / .ico files from the templates. 4. Adapt the paths within the files. 140 Version: 1.18.0 Twin CAT 3

## Page 141

Wizards ð As a result, a dedicated order exists for the templates: This directory or directory structure can, for example, now be versioned in the version management system and is also not affected by Twin CAT installations/updates. Quick start A general introduction to the wizard environment in MSDN is the entry point: https://msdn.microsoft.com/de- de/library/7k3w6w59%28v=VS.120%29.aspx. This describes how a template is used for creating a customer-specific module with the Twin CAT C++ Module Wizard. 1. Take an existing module template as the copying template In C:\Twin CAT\3.1\Components\Base\Cpp Template\Templates 2. Rename the .xml file within the folder 3. Copy the corresponding files .ico / .vsdir / .vsz also in the Class/ 4. Now reference the copied .vsz file in the .vsdir file and adapt the description. 5. Enter the .xml file created in step 2 in the .vsz file. Twin CAT 3 Version: 1.18.0 141

## Page 142

Wizards 6. You can now make changes to the source files in the Template/Customer Module Cyclic IO/ directory. The .xml takes care of replacements when creating a project from this template. ð The Twin CAT Module Class Wizard now displays the new project for selection: If the vsxproj, for example, are also to be provided in a changed form, it is recommended to adapt a copy of the Twin CAT C++ Project Wizard. If necessary, the use of settings in .props files should also be considered so that settings can also be changed in existing projects created from a template – e.g. as a result of the .props files being updated by a version management system. Alternative creation on the basis of an existing project A viable way here is to create a finished project and transform it into a template afterwards. 1. Copy the cleaned project into the Templates\ folder. 2. Create a transformation description (XML file). 3. Prepare the source files and the project file by means of the replacements described. 4. Provide the .ico / .vsdir / .vsz files. 142 Version: 1.18.0 Twin CAT 3

## Page 143

Programming Reference 12 Programming Reference Twin CAT offers a wide range of basic functions. They all can be very useful for Twin CAT C++ programmers and are documented here. There is a wide range of C++ samples, which contain the valuable information on the handling of the modules and interfaces. Twin CAT C++ project A Twin CAT C++ project has several parameters that can be opened by double-clicking on the Twin CAT C++ project (project name here “Untitled1”). Renaming is not possible here (see Renaming Twin CAT C++ projects [} 223]) The encryption of the binary module can be set here, a more detailed description of the requirements can be found in chapter Encrypting Modules [} 56]. Twin CAT 3 Version: 1.18.0 143

## Page 144

Programming Reference The option whether the sources should be included can be set here for the two archive types, which are transferred to the target system or sent by email. Accordingly, empty archives are created on deselection. 12.1 Twin CAT C++ Project properties From Twin CAT 3.1 Build 4024.0 The functionality described here is available from Twin CAT 3.1. 4024.0. Different settings can be made in the project properties for a Twin CAT C++ project. The project properties are opened by right-clicking on the C++ project -> Properties. 144 Version: 1.18.0 Twin CAT 3

## Page 145

Programming Reference Twin CAT pages exist in addition to the Visual Studio C++ dialogs for the settings: Twin CAT 3 Version: 1.18.0 145

## Page 146

Programming Reference These are described on the subpages. 12.1.1 Tc SDK 146 Version: 1.18.0 Twin CAT 3

## Page 147

Programming Reference Settings for the Twin CAT SDK Category Field Description Common Twin CAT SDK folder File folder that provides the Twin CAT SDK and shows the value of the environment variable TWINCATSDK. Intrinsics Use intrinsics from The intrinsics should be used. platform toolset 12.1.2 Tc Extract Version Version information from the project is provided in a header file and used for the build process. If the .rc file contains version information, the header file is generated from it. With versioned C++ projects, the version information is read from the TMC file and the macros from the generated header file are used in the .rc file. Category Field Description Extract Version Resource Input File The .rc file to consider. Product Version Input File TMC file containing the product version for versioned projects. File Version Input File TMC file, which contains the file version for versioned projects. Header-Output File Header File in which the information is provided. 12.1.3 Tc Publish Information about publishing modules. Twin CAT 3 Version: 1.18.0 147

## Page 148

Programming Reference Category Field Description General Settings Platform(s) Which platforms should be built in a Publish? Configuration(s) Selection whether to build debug / release. Include Debug Information For which configurations should the debug symbols (PDBs) be provided in the repository? TMC / TML source file(s) TMC / TML files from the project that represent the starting point for the Publish process. Publish as Versioned Library Should the publishing take place in the repository [} 52]? Installation Settings Archive File path for an archive. Extensions .zip (for a ZIP archive) and .exe (for a self-extracting ZIP archive) are allowed. Both contain the content for a repository (versioned C++ projects) or Custom Config/Modules (non-versioned C++ drivers) on another engineering system. Publish Installation Root Folder No installation is performed on the local system with "None". The files are only available under TWINCATSDK/_products/Tc Publish. An archive can be created to manually transfer these files to another system and install them there. If "Default" is selected, an installation into the repository (versioned C++ projects) or Custom Config/Modules (non-versioned C++ drivers) is performed on the local system. Special Settings Additional Files Adding additional files to the Publish process, which are stored in the "deploy" subdirectory during installation. Post publish command Execute a command after the publish, e.g. to clean up. 12.1.4 Tc Sign Twin CAT modules must be signed [} 23], which can be configured here. 148 Version: 1.18.0 Twin CAT 3

## Page 149

Programming Reference Category Field Description Enable signing SHA1 signing Should an operating system signature, which is necessary for the operating system, be carried out? SHA256 signing Should an operating system signature, which is necessary for the operating system, be carried out? Twin CAT signing Should a Twin CAT user certificate be used for signing? This is necessary for the Twin CAT Loader [} 53]. Twin CAT Certificates Twin CAT Certificate Name of the certificate file (directory: C: Name \Program Data\Beckhoff\Twin CAT\3.1\Custom Config\Cert These parameters are ificates). Alternatively, the environment variable used for all configurations Tc Sign Twin Cat Cert Name can be set to the name of the such as debug and certificate file. release. Twin CAT Certificate Password that protects the Twin CAT user certificate Password (stored in plain text, leave blank if necessary). The Tc Sign Tool [} 58] can be used to not store the password of the Twin CAT user certificate in the project, where it would also end up in version management, for example. Verbose Output Should extended information be output during the signature? Windows Certificate Certificate Store Name of the certificate store in the certificate manager of (SHA1) Name the operating system. Certificate Name Name of the certificate in the certificate store. Only included for Certificate ID ID of the certificate. compatibility reasons – Timestamp Server URL of the timestamp server for use during the please switch to Twin CAT URL signature. This is provided by various CAs. Certificates immediately CA Cross Signing Path to Cross Signing certificate. Certificate Path Verbose Output Should extended information be output during the signature? Windows Certificate Certificate Store Name of the certificate store in the certificate manager of (SHA256) Name the operating system. Certificate Name Name of the certificate in the certificate store. Only included for Certificate ID ID of the certificate. compatibility reasons – Timestamp Server URL of the timestamp server for use during signature, please switch to Twin CAT URL provided by the CA. Certificates immediately CA Cross Signing Path to Cross Signing certificate. Certificate Path Verbose Output Should extended information be output during the signature? 12.2 File Description During the development of Twin CAT C++ modules, files in the file system can be handled directly. This is of interest, either to understand how the system works or for specific use cases such as manual file transfer, etc. Here is a list of files related to C++ modules. Twin CAT 3 Version: 1.18.0 149

## Page 150

Programming Reference File Description Further information Engineering / XAE *.sln Visual Studio Solution file, hosts Twin CAT and non-Twin CAT projects *.tsproj Twin CAT project, collection of all nested Twin CAT projects, such as Twin CAT C++ or Twin CAT PLC project _Config/ Folder contains further configuration files (*.xti) See menu Tools| Options| that belong to the Twin CAT project. Twin CAT| XAE- Environment| File Settings _Deployment/ Folder for compiled Twin CAT C++ drivers *.tmc Twin CAT Module Class file (XML-based) See Twin CAT Module Class Editor (TMC) [} 90] *.rc Resource file See Setting version/ vendor information [} 222] *.vcxproj.* Visual Studio C++ project files *Class Factory.cpp/.h Class Factory for this Twin CAT driver *Ctrl.cpp/.h Upload and remove drivers for Twin CAT UM platform *Driver.cpp/.h Upload and remove drivers for Twin CAT RT platform *Interfaces.cpp/.h Declaration of the Twin CAT COM interface classes *W32.cpp./.def/.idl *.cpp/.h One C++/Header file per Twin CAT module in the driver. Insert user code here. Resource.h Required by *.rc file Tc Pch.cpp/.h Used for creating precompiled headers %TC_INSTALLPATH% Compiled driver that is loaded via the See Versioned C++ \Repository\<Vendor>\<Prj Nam Tc Loader. Projects [} 52] e>\<Version>\<Platform>\*.tmx Twin CAT 3.1.4024.x: C:\Twin CAT\3.1\Repository\C++ Module Vendor\Untitled1\0.0.0.1\Twin CAT RT *\Unititled1.tmx From Twin CAT 3.1.4026.x: C: \Program Data\Beckhoff\Twin CAT\3.1\Repositor y\C++ Module Vendor\Untitled1\0.0.0.1\Twin CAT RT *\Unititled1.tmx %TC_INSTALLPATH% Published Twin CAT C++ project normally See Export modules \Custom Config\Modules\* Twin CAT 3.1.4024.x: C:\Twin CAT\3.1\Custom Config\Modules\* From Twin CAT 3.1.4026.x: C:\Program Files (x86)\Beckhoff \Twin CAT\3.1\Config\Modules\* Runtime / XAR %TC_BOOTPRJPATH% Current configuration setup \Current Config\* Windows: Twin CAT 3.1.4024.x: C:\Twin CAT\3.1\Boot 150 Version: 1.18.0 Twin CAT 3

## Page 151

Programming Reference File Description Further information From Twin CAT 3.1.4026.x: Windows: C:\Program Data\Beckhoff \Twin CAT\3.1\Boot Twin CAT/BSD: /usr/local/etc/Twin CAT/3.1/Boot %TC_DRIVERAUTOINSTALLP Compiled, platform-specific driver that is loaded ATH% \*.sys/pdb via the operating system. Windows: Twin CAT 3.1.4024.x: C:\Twin CAT\3.1\Driver\Auto Install (loaded by the system) From Twin CAT 3.1.4026.x: <not available> Please migrate to TMX based C++ projects Twin CAT/BSD®: <not available> %TC_INSTALLPATH% Compiled platform-specific driver that is loaded \Boot\Repository\<Vendor>\<Prj via the Tc Loader. Name>\<Version>\*.tmx Windows: Twin CAT 3.1.4024.x: C:\Twin CAT\3.1\Boot\Repository\C++ Module Vendor\Untitled1\0.0.0.1\Untitled1.tmx From Twin CAT 3.1.4026.x: C:\Program Data\Beckhoff \Twin CAT\3.1\Boot\Repository\C++ Module Vendor\Untitled1\0.0.0.1\Untitled1.tmx Twin CAT/BSD: /usr/local/etc/Twin CAT/3.1/ Boot\/Repository\C++ Module Vendor\Untitled1/0.0.0.1/Untitled1.tmx %TC_BOOTPRJPATH% Twin CAT Module Instance file \TM\OBJECTID.tmi Describes variables of the driver File name is Object ID.tmi Windows: Twin CAT 3.1.4024.x: C:\Twin CAT\3.1\Boot\TMI\OTCID.tmi From Twin CAT 3.1.4026.x: Windows: C:\Program Data\Beckhoff \Twin CAT\3.1\Boot\TMI\OTCID.tmi Twin CAT/BSD: /usr/local/etc/Twin CAT/3.1/Boot/TMI/OTCID.tmi Temporary files *.sdf Intelli Sense Database *.suo / *.v12.suo User-specific and Visual Studio-specific files *.tsproj.bak Automatically generated backup file from tsproj ipch/ Intermediate directory created for precompiled headers Twin CAT 3 Version: 1.18.0 151

## Page 152

Programming Reference Compilation procedure The procedure that initiates a Build or Rebuild on a Twin CAT C++ project in the Twin CAT Engineering XAE is described here. This is to be taken into account, for example, if company-specific environments and building processes are to be integrated. The configurations that are built in the case of a Build or Rebuild depend on the current selection in Visual Studio: The correct target architecture (in this case Twin CAT RT (x64)) is set appropriately by selecting the target system. The Configuration Manager allows the dedicated setting of the build configuration. When selecting Build or Rebuild (and thus also Activate Configuration), the following steps are performed: 1. The sources are located in the respective project directory. 2. The compilations are generated in an architecture-specific manner below the project directory _products\Twin CAT RT (x64)\Release\<Project Name>. 3. After the link process, the .tmx/.pdb file is then stored in the project directory. 4. Pressing the Activate Configuration button transfers .tmx/.pdb from the engineering repository to the target system (this may be a local copy). When Publish is selected on the project, it builds for the selected platforms and stores the result in the engineering repository: C: \Program Data\Beckhoff\Twin CAT\3.1\Repository\<vendor>\<Project Name>\<version>\Twin CAT RT (x64)\Release\, whereby the TMC file is also updated. 12.3 Online Change From Twin CAT 3.1 Build 4024.0 The functionality described here is available from Twin CAT 3.1. 4024.0. Twin CAT 3.1 supports the exchange of C++ modules at runtime, i.e. without interrupting the real-time program. For this purpose, different versions [} 52] of a Twin CAT Executable (TMX) are stored on the target system,. For all module instances from a TMX, a switchover between the versions can be initiated by the engineering. The procedure is roughly sketched: ü Online Change capable module in TMX 1. Twin CAT instantiates the new module. The old module is still called cyclically by the task. 2. Twin CAT calls ITc Online Change::Prepare Online Change() of the new module. This call can access the old module and accept data that does not change due to the cyclic calls of the module - for example parameter values. 3. Twin CAT calls ITc Online Change::Perform Online Change() of the new module. This call can access the old module and take over data which have changed cyclically before. This call is executed if no cyclic call is made by a task. The old module is not called again by the task, but the new module is called. The Perform Online Change() method should use as little computing time as possible so that this switchover can take place from one task cycle to the other. 4. After completion, the task will call the new module cyclically. 152 Version: 1.18.0 Twin CAT 3

## Page 153

Programming Reference The Online Change can be carried out through this dialog in engineering. When dealing with the Online Change, there are therefore some aspects to consider: • The project must provide a revision control. • The Data Areas for these modules are kept outside the Tc COM module and made available to the modules. This means that they do not need to consider the data or the mapping of the symbols in the Data Areas. • The Data Areas of the module must not change. • References to internal data structures must not be passed on. Access must always take place via interfaces that are retrieved via the Tc Query Interface, since these references are updated during an Online Change. After a restart, Twin CAT will start the driver in the initial version of the modules. 12.4 Limitations Twin CAT 3 C++ modules [} 38] are executed in Windows kernel mode. Developers must therefore be aware of some limitations: Twin CAT 3 Version: 1.18.0 153

## Page 154

Programming Reference • Win32 API [} 154] is not available in kernel mode • Windows kernel mode API must not be used directly. Twin CAT SDK provides functions, which are supported. • User mode libraries (DLL) cannot be used. (see Third Party Libraries [} 236]) • The memory capacity for dynamic allocation in a real-time context is limited by the router memory (this can be configured during engineering), see Memory allocation [} 154]. • A subset of the C++ runtime library functions (CRT) is supported • C++ exceptions are not supported. • Runtime Type Information (RTTI [} 154]) is not supported. • Subset of STL is supported (see STL / Containers [} 215]) • Support for functions from math.h through Twin CAT implementation (see Mathematical Functions [} 212]) Twin CAT functions as replacement for Win32 API functions The original Win32 API is not available in Windows kernel mode. For this reason a list of the common functions of the Win32 API and their equivalents for Twin CAT is provided here: Win32API Twin CAT functionality Win Sock TF6311 TCP/UDP real-time Message boxes Tracing [} 216] File I/O See Interface ITc File Access [} 168], Interface ITc File Access Async [} 175] and Sample19: Synchronous File Access [} 300], Sample20: File IO- Write [} 301], Sample20a: File IO-Cyclic Read / Write [} 301] Synchronization See Sample11a: Module communication: Method call C++ module to C++ module [} 295] Visual C CRT See Rtl R0.h RTTI dynamic_cast function in Twin CAT Twin CAT has no support for dynamic_cast<>. Instead, it may be possible to use the TCOM strategy. Define an ICustom interface, which is derived from ITc Unknown and contains the methods, which are called from a derived class. The base class CMy Base is derived from ITc Unknown and implements this interface. The class CMy Derived is derived from CMy Base and from ICustom. It overwrites the Tc Query Interface method, which can then be used instead of dynamic cast. Tc Query Interface can also be used to display the Is Type() function through evaluation of the return value. See Interface ITc Unknown [} 191]. 12.5 Memory allocation Generally we recommend reserving memory with the aid of member variables of the module class. This is done automatically for data areas defined in the TMC editor. It is also possible to allocate and release memory dynamically. • Operator new / delete • Tc Mem Allocate / Tc Mem Free This memory allocation can be used in the transitions [} 47] or in the OP state of the state machine. 154 Version: 1.18.0 Twin CAT 3

## Page 155

Programming Reference If the memory allocation is made in a non-real-time context, the memory is allocated in the non-paged pool of the operating system (blue in the diagram). In the Twin CAT real-time context, the memory is allocated in the router memory (red in the diagram). The memory can also be released in the transitions or the OP state; we recommend to always release the memory in the "symmetric" transition, e.g. allocation in PS, release in SP. When using static variables, some special features [} 156] have to be considered. In addition, some notes on the implementation of transitions can be provided: • Transitions IP, PS and SP, PI are executed in a non-real-time context (e.g. Windows Kernel Mode). • Transitions SO, OS, however, are executed in the Twin CAT RT Task Context (more precisely: Tc COM Server Task). • Transitions must be implemented according to the "all-or-nothing" pattern. This means that all steps that are carried out successfully must be undone if a subsequent step fails. • If memory is allocated in the OP state, it must be released in the OS transition at the latest. • The OS, SP, PI transitions should be implemented in such a way that they are always successful. No error codes should be returned. • Transitions should be implemented symmetrically, i.e. OS and SO should be inverse, ditto for PS <-> SP and IP <->PI. • Transition SO should log in the module to the task as the last step (if an ITc Caller is present) • Transition OS should log off the module from the task as a first step (if an ITc Caller is present) • Semaphores ◦ Can be created and deleted in a non-real-time context ◦ Use (pend / post) is only permitted in a real-time context • Several modules can wait for each other in the states. The Init Seq (default "PSO") is used to specify the states in which the module instances should wait for the overall system (and thus all other modules) to be switched on. Twin CAT 3 Version: 1.18.0 155

## Page 156

Programming Reference 12.6 Static variables Memory allocation between Windows and real-time context in conjunction with static variables If global instances are used, be aware of the following: • A maximum of 128 global instances may exist in total. It should be noted that global instances can also be used by Twin CAT's own modules. • If the number is exceeded, the destructors are no longer called. • From Twin CAT 3.1 4026, a message is displayed in the "Output" of the engineering if the limit is exceeded: Too many static objects detected on shutdown of class factory <Project Name>.tmx. Max Number of static objects exceeded by N item(s). This may result in a memory leak. • The program code can query the currently used or available global instances: #include "Crt Init.h" int overflow = cpp Get Number Handler Overflow(); int free = Tc Crt Get Free Number Atexit Handler(); • Memory allocated in the real-time context must be released in the OS transition, for example, so that this does not happen via the destructor. • When the constructor is executed, Twin CAT system resources cannot yet be accessed, because the connection via the Classfactory to the Tc COM object server has not yet been established. Below you will see how to deal with this. This code includes three examples of global instances: class My Class A { public: My Class A() {} ~My Class A() {} private: int v; } My Class A A; class My Class B { static My Class A Value; }; My Class A& Get Instance() { static My Class A a; return a; } Singletons for the initialization of global instances In order to delay the time, global or so-called singleton instances can also be created as local static objects. It is very important when using global class instances that the destructors are called late and at this point there is no longer a connection to the Twin CAT system, so that Twin CAT resources must be released beforehand. Here is a sample code showing a singleton in Twin CAT: #include "Tc Interfaces.h" class Version Provider : public ITc Version Provider { public: DECLARE_IUNKNOWN_NODELETE() Version Provider() { m_Version = { 1, 2, 3, 0}; } virtual HRESULT TCOMAPI Get Version(T_Version& version) { 156 Version: 1.18.0 Twin CAT 3

## Page 157

Programming Reference version = m_Version; return S_OK; }; private: T_Version m_Version; }; BEGIN_INTERFACE_MAP(Version Provider) INTERFACE_ENTRY(IID_ITc Version Provider, ITc Version Provider) END_INTERFACE_MAP() class My Singleton { public: static My Singleton& Instance(ITc Version Provider* ip = NULL, bool b Release=false) { static My Singleton g_instance(ip); if (b Release) g_instance. Release(); return g_instance; } T_Version Get Version() { T_Version v = {0, 0, 0, 0}; if (m_sp Tc Inst != NULL) { m_sp Tc Inst->Get Version(v); } return v; } private: My Singleton(ITc Version Provider* ip = NULL) : m_sp Tc Inst(ip) { } void Release() { m_sp Tc Inst = NULL; } ITc Version Provider Ptr m_sp Tc Inst; }; Here the usage is shown: // actual instance which is an example for a Twin CAT resource Version Provider vp; // Initialize singleton My Singleton::Instance(&vp); // use singleton to access information provided by Twin CAT resource T_Version v1 = My Singleton::Instance(). Get Version(); Assert::Is True( v1.major == 1 && v1.minor == 2 && v1.build == 3 && v1.revision == 0); // Deinitialize singleton and release reference to Twin CAT resource My Singleton::Instance(NULL, true); // use singleton after deinitialization which has to implement some default behaviour for this case T_Version v2 = My Singleton::Instance(). Get Version(); Assert::Is True( v2.major == 0 && v2.minor == 0 && v2.build == 0 && v2.revision == 0); 12.7 Multi-task data access synchronization When one set of data is accessed by multiple tasks, the tasks may access the same data simultaneously, depending on the task/real-time configuration. If the data is written by at least one of the tasks, the data may have an inconsistent state during or after a change. To prevent this, all concurrent accesses must be synchronized so that only one task can access the shared data at a time. If the same data is accessed by several tasks and the data is written for at least one of these accesses, all read and write accesses must be synchronized. This applies regardless of whether the tasks are run on a single or multiple CPU cores. WARNING Inconsistencies and other risks due to unsecured data access If concurrent accesses are not synchronized, there is a risk that the data records will be inconsistent or invalid. Depending on how the data is used in the further course of the program, this can result in incorrect program behavior, undesired axis movement, or even a sudden program standstill. Damage to equipment and workpieces may occur, or people's health and lives may be endangered, depending on the controlled system. Twin CAT 3 Version: 1.18.0 157

## Page 158

Programming Reference General synchronization options between the Tc COM modules are already described in chapter Module-to- module communication [} 49]. The following mechanisms were described: • Data exchange via the process image (IO mapping). During this process, the cycle transition, and thus Twin CAT, ensures data synchronicity between the sources and targets. • Method calls via interfaces in which Critical Sections can be used. • ADS, which transfers data in the form of a transport medium and thus ensures synchronicity of the data. • Common data area to be protected by a Critical Section. Ideally, however, you should try to avoid the need for synchronization. Otherwise, the simplest way is usually the exchange via the process image, which copies the data between the cycles from the output process images to the input process images and thus ensures a consistent state. If this is not sufficient and data has to be accessed from different contexts, one of the following options can be used. It is important to differentiate between the task contexts that are to access the data. In the Twin CAT Runtime, a distinction is made between the Windows kernel mode thread contexts (Windows context for short) and the Twin CAT real-time task contexts (RT context). During initialization of Twin CAT modules, the IP, PS, SP and PI transitions are executed in the Windows context. The SO and OS transitions are executed in the RT context. The SDK offers appropriate synchronization options for such scenarios. Nevertheless, the Tc COM modules should be designed such that they are independent of each other, at least in the Windows context, and thus do not require synchronization. The transitions in the RT context can use Critical Sections if required. For the Critical Section and semaphores it applies that in case of a lock the task waits for the release. In the meantime the core is released for other tasks. With Critical Sections the active task inherits the priority of the waiting task ("Priority Inheritance"). 12.7.1 Critical Sections Instances of Critical Sections are created through Twin CAT real-time. This instance can be initialized in the Windows context as well as in the RT context. The Critical Section instance can only be used in the RT context. Twin CAT real-time uses "priority inheritance" to prevent a task with lower priority from indirectly blocking a task with high priority. CCritical Section Instance The CCritical Section Instance class provides the interface to handle Critical Sections and has the required memory. To create a Critical Section the class requires the object ID of the Twin CAT real-time instance, which is available via OID_TCRTIME_CTRL, as well as a reference to the Twin CAT object server via a pointer to ITCom Object Server. Methods: • CCritical Section Instance(OTCID oid=0, ITCom Object Server* ip Srv=NULL); The default constructor that initializes the object ID of the Critical Section Provider. If the pointer is given to the object server, the Critical Section is also initialized. • ~CCritical Section Instance(); The destructor deletes the Cricital Section instance. • void Set Oid Critical Section(OTCID oid); Sets the Critical Section Provider, which is given by Twin CAT real-time and whose object ID is available via OID_TCRTIME_CTRL. • bool Has Oid Critical Section(); Returns TRUE if the object ID is set to a value other than 0, otherwise FALSE. The object ID is not checked to verify whether it belongs to a Critical Section Provider. • bool Is Initialized Critical Section(); Returns TRUE if the Critical Section was successfully initialized. 158 Version: 1.18.0 Twin CAT 3

## Page 159

Programming Reference • HRESULT Create Critical Section(ITCom Object Server* ip Srv); If the Critical Section is initialized, it is deleted and a new Critical Section is initialized. Returns S_OK if successful. Error cases are indicated by the return of error codes: ADS_E_INVALIDPARM Invalid Critical Section Provider ADS_E_NOINTERFACE The object ID is set to a reference that is not a Critical Section Provider, i.e. ITc RTime is not implemented. E_FAIL Internal error from the Critical Section Provider. • HRESULT Create Critical Section(OTCID oid, ITCom Object Server* ip Srv); Initializes the Critical Section. Delete Critical Section() must be called if this method is used again. Return values as in Create Critical Section(ITCom Object Server* ip Srv); • HRESULT Delete Critical Section(); Critical Section is deleted. Always returns S_OK. • HRESULT Enter Critical Section(); blocked until the Critical Section is released. • HRESULT Leave Critical Section(); Leaves the Critical Section and thus releases it again. Returns MAKE_RTOS_HRESULT(OS_CS_ERR) if the caller is not the owner. Enter Critical Section() and Leave Critical Section() must be called in the RT context, otherwise the following return value is returned: ADS_E_INVALIDCONTEXT Return value if Critical Section is entered outside the RT context. The Critical Section is not entered. If these methods are used without initializing the Critical Section, S_OK is returned without further action. All other methods can be used in the RT context as well as in the Windows context. In the CCritical Section Instance class, the Enter Critical Section() can be called multiple times by the same task. Leave() must then be called just as often. Critical Sections allow nested calls and require an associated Leave Critical Section() call for each Enter Critical Section() call. The Critical Section is released when the last Leave Critcal Section() is called. Sample: The sample [} 295] shows how to use a Critical Section to prevent concurrent access to a date via an interface method call. Critical Section Concurrent The CCritical Section Instance Concurrent class allows concurrent access. This can be used if several tasks have read access to the data to be protected, but all other accesses must be prevented in the case of write access. Methods: • CCritical Section Instance Concurrent(UINT concurrent, OTCID oid=0, ITCom Object Server* ip Srv=NULL); The parameter "concurrent" defines the number of tasks that can simultaneously enter the Critical Section via Cs Enter Critical Section Concurrent(). If "concurrent" is 1, the Critical Section Concurrent variant works like a Critical Section. The value 0 is not allowed. It would prevent the Critical Section from being initialized. • ~CCritical Section Instance Concurrent(); The destructor implicitly deletes the Critical Section • void Set Oid Critical Section(OTCID oid); Sets the Critical Section Provider, which is given by Twin CAT real-time and whose object ID is available via OID_TCRTIME_CTRL. • bool Has Oid Critical Section(); Returns TRUE if the object ID is set to a value other than 0, otherwise FALSE. The object ID is not checked to verify whether it belongs to a Critical Section Provider. • bool Is Initialized Critical Section(); Returns TRUE if the Critical Section was successfully initialized. • HRESULT Create Critical Section(ITCom Object Server* ip Srv); If the Critical Section is initialized, it is deleted and a new Critical Section is initialized. Returns S_OK if successful. Error cases are indicated by the return of error codes: Twin CAT 3 Version: 1.18.0 159

## Page 160

Programming Reference ADS_E_INVALIDPARM Invalid Critical Section Provider ADS_E_NOINTERFACE The object ID is set to a reference that is not a Critical Section Provider, i.e. ITc RTime is not implemented. E_FAIL Internal error from the Critical Section Provider. • HRESULT Create Critical Section(OTCID oid, ITCom Object Server* ip Srv); Initializes the Critical Section. Delete Critical Section() must be called if this method is used again. Return values as in Create Critical Section(ITCom Object Server* ip Srv); • HRESULT Delete Critical Section(); Critical Section is deleted. Always returns S_OK. • HRESULT Enter Critical Section(); Blocked until the Critical Section is released and can be accessed exclusively. • HRESULT Leave Critical Section(); Leaves the Critical Section and thus releases it again. Returns MAKE_RTOS_HRESULT(OS_CS_ERR) if the caller is not the owner. • HRESULT Enter Critical Section Concurrent(); Enters the Critical Section in parallel with other tasks. The number of parallel accesses is defined by the parameter "concurrent" in the constructor. When this maximum number is reached, the call is blocked until one of the parallel accesses has ended. Enter Critical Section(), Enter Critical Section Concurrent() and Leave Critical Section() must be called in the RT context, otherwise the following return value is returned: ADS_E_INVALIDCONTEXT Return value if Critical Section is entered outside the RT context. The Critical Section is not entered. If these methods are used without initializing the Critical Section, S_OK is returned without further action. All other methods can be used in the RT context as well as in the Windows context. For the CCritical Section Instance Concurrent class, it is not allowed for the Enter Critical Section() method to be called multiple times by the same task if the concurrent parameter is greater than 1 during initialization. 12.7.2 Semaphores Semaphores are used to synchronize access to limited resources. They can also be used to implement a notification event. Semaphores are provided by the Twin CAT real-time through the CSemaphore Instance class. CSemaphore Instance The CSemaphore Instance class provides the interface for handling semaphores. To create a semaphore, the instance requires the object ID of the Twin CAT real-time instance, which is available via OID_TCRTIME_CTRL, as well as a reference to the Twin CAT object server via a pointer to ITCom Object Server. Methods: • HRESULT Sem Create(WORD n Cnt Init, OTCID oid, ITCom Object Server* ip Srv); Creates the semaphores with n Cnt Init as initial value of the available resources. Returns S_OK if successful and E_FAIL if the semaphore cannot be generated. • HRESULT Sem Delete(); Sem Delete() deletes the semaphore. Returns S_OK. • HRESULT Sem Post() Sem Post() increases the number of available resources. If a task is waiting for the semaphores, the task with the highest priority is released, i.e. it can continue its execution. Returns S_OK if successful. Possible error codes: MAKE_RTOS_HRESULT(51) Semaphore overflow. For example, if the internal memory is insufficient. • HRESULT Sem Pend(OSTICKS n Timeout); Reduces the number of available resources; if no resources are available, the task is blocked at this point. Sem Pend() waits for a semaphore until it is available. A timeout can be specified in OSTICKS and is 160 Version: 1.18.0 Twin CAT 3

## Page 161

Programming Reference therefore processor dependent. The ITc RTime interface in can be used to calculate it. In the sample Tc Semaphore Sample a method Timeout Ms To Ticks was used for this purpose. Special values for n Timeout: RTIME_NOWAIT (-1) Method immediately returns S_OK if the semaphore is available. Method returns a timeout if no resource is available. RTIME_ENDLESSWAIT (0) Method waits indefinitely for availability of the semaphores The method returns S_OK if the semaphore was successfully obtained; otherwise: MAKE_RTOS_HRESULT(10) Indicates a timeout. If n Timeout is set as RTIME_NOWAIT, this semaphore is not available. Sample: Sample24: Semaphores [} 306] 12.7.3 FIFO template classes The header file Fifo.h provides different FIFO Template classes. All classes recognize when their memory is full and will not accept new elements until an element is removed. The element types can be primitive data types ("Plain Old Datatypes", PODs). It is not possible to store element types with virtual tables in a FIFO buffer. Pointers are allowed (irrespective of type). CFi Fo List Base The class CFifo List Base is the base implementation of a FIFO. This template class has a Storage Type instance that is responsible for storing elements of one type. It uses a Sync Type instance to maintain synchronized access to the storage and data it contains. There are different protection options: • CNo Sync / Sync Obects.h: No access protection within the FIFO. An external Critical Section can be used. • CSpin Lock / Tc Spinlock.h: Protection by a spinlock, as described above. The Add(), Remove() and Clear() methods have corresponding _Unprotected_ options, which can be used with the Lock() and Unlock() methods to implement a synchronized sequence of Add() and Delete() operations. Methods: • CFi Fo List Base(); The constructor. • Lock() and Unlock(); Are passed to the Sync Type synchronization instance. • Clear(), Clear_Unprotected(); Are passed on to the Storage Type instance. • Add(), Add_Unprotected(); Add an element. • Add Block(); Add multiple elements. If a block is larger than the free memory, only the elements that match the free memory are added. The number of added elements is returned. • Remove(), Remove_Unprotected(); Removes an element from the FIFO. Returns FALSE if no element was present, otherwise TRUE. • Remove Block(); Removes multiple elements from the FIFO. If fewer elements are stored there, only the stored elements are removed. The number of removed elements is returned. • Get Entry XBefore Head(); Fetches the element before the xth element from the head without removing the element. For example, if 0 is used as parameter, the first element is fetched. Otherwise the parameter must be greater than 0. Returns FALSE if the element does not exist, otherwise TRUE. • Count(); Returns the number of stored elements. • Size(); Returns the size of the memory, i.e. the maximum number of elements the memory can hold. • Free Count(); Returns the number of elements added to the memory. • Get Next Entry(); Iterates over the elements and starts at the head. Twin CAT 3 Version: 1.18.0 161

## Page 162

Programming Reference CFi Fo List The class CFi Fo List is based on CFi Fo List Base and uses CFi Fo List Storage Static as storage type in conjunction with the synchronization type CSync Default. This implementation does not add methods and requires element types and memory size as template parameters. CFi Fo List Dyn The class CFi Fo List Dyn uses the dynamic Storage Type CFifo List Storage Dynamic in conjunction with the synchronization type CSync Default. This implementation does not add methods and requires element types and memory size as template parameters. Handover3Buffer The class CHandover3Buffer is used to pass elements from one task to another. The memory contains 3 elements of a given type. The writing task can always write the element. The reading task can always read the element when an element has been written. It reads the element that was written fully. Elements are not removed after they are read. Access via indices for reading and writing to memory is synchronized by the Interlocked Exchange R0 function, so that it is accessible from the Windows and RT context. Methods: • CHandover3Buffer(); The constructor. • Write(); Writes an element into memory. Returns FALSE if the memory has an invalid state. Otherwise TRUE. • Read(); Reads an element from memory. Returns FALSE if the memory is empty or is in an invalid state. Otherwise TRUE. CHandover Fifo The CHandover Fifo class is also used to exchange elements between tasks. The size of the memory is always a power of two. It can be set via the template parameter DEPTH_EXP. The default value is 3, resulting in a size of 8 elements. Methods: • Insert()/Add(); Writes an element into memory via a pointer or reference. Returns FALSE if no memory is available, otherwise TRUE. • Remove(); Removes and returns an element from memory via a pointer or reference. Returns FALSE if no element is available, otherwise TRUE. Sample: Tc Handover Sample.tszip 12.8 Interfaces Several interfaces are available for the interaction of the modules developed by the user with the Twin CAT 3 system. These are described (at API level) in detail on these pages. 162 Version: 1.18.0 Twin CAT 3

## Page 163

Programming Reference Name Description ITc Unknown [} 191] ITc Unknown defines the reference count as well as the querying of a reference to a more specific interface. ITCom Object [} 181] The ITCom Object interface is implemented by every Twin CAT module. ITc Cyclic [} 166] The interface is implemented by Twin CAT modules that are called once per task cycle. ITc Cyclic Caller [} 166] Interface for logging the Itc Cyclic interface of a module onto and off from a Twin CAT task. ITc File Access [} 168] Interface for accessing the file system ITc File Access Async [} 175] Asynchronous access to file operations. ITc Post Cyclic [} 186] The interface is implemented by Twin CAT modules that are called once per task cycle following the output update. ITc Post Cyclic Caller [} 163] Interface for logging the ITc Post Cyclic interface of a module onto and off from a Twin CAT task. ITc Io Cyclic [} 176] This interface is implemented by Twin CAT modules that are called during the input update and output update within a task cycle. ITc Io Cyclic Caller [} 178] Interface for logging the ITc Io Cyclic interface of a module onto and off from a Twin CAT task. ITc RTime Task [} 187] Query of extended Twin CAT task information. ITc Task [} 188] Query of the timestamp and task-specific information of a Twin CAT task. ITc Task Notification Executes a callback if the cycle time was exceeded during the previous cycle. [} 191] Twin CAT SDK Twin CAT SDK contains a number of functions, which can be found in C:\Twin CAT\3.1\sdk\Include. • The Tc COM framework is provided here (in particular Tc Interfaces.h and Tc Services.h). • Tasks and data area access is provided via Tc Io Interfaces.h. • SDK functions are the mathematical functions [} 212]. • Subset of STL [} 215]. • Twin CAT runtime Rtl R0.h [} 193] • Methods for ADS communication [} 194] • Classes / functions with names beginning with "Os" must not be used in a real-time context. 12.8.1 Interface ITc Post Cyclic Caller Interface for logging in or out of the ITc Post Cyclic interface of a module in a Twin CAT task. Syntax TCOM_DECL_INTERFACE("03000026-0000-0000-e000-000000000064", ITc Cyclic Caller) struct__declspec(novtable) ITc Post Cyclic Caller : public ITc Unknown Ca Required include: Tc Io Interfaces.h Methods Name Description Add Post Module [} 164] Login module that implements the ITc Post Cyclic interface. Remove Post Module [} 165] Log off the previously logged in ITc Post Cyclic interface of a module. Twin CAT 3 Version: 1.18.0 163

## Page 164

Programming Reference The ITc Post Cyclic Caller interface is implemented by Twin CAT tasks. A module uses this interface to login its ITc Post Cyclic interface to a task, usually as the last initialization step in the Safe OP to OP transition. After login, the Post Cycle Update() method of the module instance is called. The interface is also used to log off the module so that it is no longer called by the task. 12.8.1.1 Method ITc Post Cyclic Caller:Add Post Module Logs the ITc Post Cyclic interface of a module to a cyclic caller, e.g. a Twin CAT task. Syntax virtual HRESULT TCOMAPI Add Post Module(STc Post Cyclic Entry* p Entry, ITc Post Cyclic* ip Mod, ULONG_PTR context=0, ULONG sort Order=0)=0; Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. The error ADSERR_DEVICE_INVALIDSTATE is returned if the cyclic caller, i.e. the Twin CAT task is not in the OP state. Parameter Name Type Description p Entry STc Post Cyclic Entry [in] Pointer to a list item that is inserted into the internal list of the cyclic caller; see also description. ip Mod ITc Post Cyclic [in] Interface pointer used by the cyclic caller. context ULONG_PTR [optional] A context value that is transferred to the ITc Post Cyclic::Post Cyclic Update() method with each call. sort Order ULONG [optional] The sort order can be used for controlling the order of execution if various module instances are executed by the same cyclic caller. Description A Twin CAT module class uses a Smart Pointer to refer to the cyclic caller of type ITc Post Cyclic Caller Ptr. The object ID of the task is stored in this Smart Pointer and a reference to the task can be obtained via the Twin CAT object server. In addition, the Smart Pointer class already contains a list item. Therefore the Smart Pointer can be used as the first parameter for the Add Post Module method. The following code sample illustrates the login of the ITc Post Cyclic Caller interface. RESULT hr = S_OK; if ( m_sp Post Cyclic Caller. Has OID() ) { if ( SUCCEEDED_DBG(hr = m_sp Srv->Tc Query Smart Object Interface(m_sp Post Cyclic Caller)) ) { if ( FAILED(hr = m_sp Post Cyclic Caller->Add Post Module(m_sp Post Cyclic Caller, THIS_CAST(ITc Post Cyclic))) ) { m_sp Post Cyclic Caller = NULL; } } } 164 Version: 1.18.0 Twin CAT 3

## Page 165

Programming Reference 12.8.1.2 Method ITc Post Cyclic Caller:Remove Post Module Remove a module instance from being called by a cyclic caller. Syntax virtual HRESULT TCOMAPI Remove Post Module(STc Post Cyclic Entry* p Entry)=0; Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. The method returns E_FAIL if the entry is not in the internal list. Parameter Name Type Description p Entry STc Post Cyclic Entry Refers to the list item to be removed from the internal list of the cyclic caller. Comparable with the Add Post Module() method, the smart pointer is used for the cyclic caller as a list item if the module instance is to be removed from the cyclic caller. Declaration and use of the Smart Pointer: ITc Post Cyclic Caller Info Ptr m_sp Post Cyclic Caller; if ( m_sp Post Cyclic Caller ) { m_sp Post Cyclic Caller->Remove Post Module(m_sp Post Cyclic Caller); } m_sp Post Cyclic Caller = NULL; 12.8.2 Return values ITc interfaces methods generally return an HRESULT. The following return values can be returned in the case of ITc interfaces: Name HRESULT S_OK 0x0000 0000 S_FALSE 0x0000 0001 E_NOTIMPL 0x8000 4001 E_NOINTERFACE 0x8000 4002 E_POINTER 0x8000 4003 E_ABORT 0x8000 4004 E_FAIL 0x8000 4005 E_UNEXPECTED 0x8000 FFFF E_ACCESSDENIED 0x8007 0005 E_HANDLE 0x8007 0006 E_OUTOFMEMORY 0x8007 000E E_INVALIDARG 0x8007 0057 In addition, there is a possibility for ADS Return Codes [} 334] to be returned as HRESULT. These are also available as macros in the SDK, where they are known, for example, as ADS_E_BUSY for the ADS Error Code ADSERR_DEVICE_BUSY. Twin CAT 3 Version: 1.18.0 165

## Page 166

Programming Reference 12.8.3 Interface ITc Cyclic The ITc Cyclic interface is implemented by Twin CAT modules that are called once per task cycle. Syntax TCOM_DECL_INTERFACE("03000010-0000-0000-e000-000000000064", ITc Cyclic) struct__declspec(novtable) ITc Cyclic : public ITc Unknown Required include: Tc Io Interfaces.h Methods Name Description Cycle Update [} 166] Is called once per task cycle if the interface is logged on to a cyclic caller. The ITc Cyclic interface is implemented by Twin CAT modules. This interface is passed to the ITc Cyclic Caller::Add Module() method when a module logs itself on to a task, usually as the last initialization step during the transition from Safe OP to OP. After login, the Cycle Update() method of the module instance is called. 12.8.3.1 Method ITc Cyclic: Cycle Update The Cycle Update method is normally called by a Twin CAT task after the interface has been logged in. Syntax HRESULT TCOMAPI Cycle Update(ITc Task* ip Task, ITc Unknown* ip Caller, ULONG_PTR context) Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. At present, the return value is ignored by the Twin CAT tasks. Parameter Name Type Description ip Task ITc Task Refers to the current task context. ip Caller ITc Unknown Refers to the calling instance. Context ULONG_PTR Context contains the value that was passed to the ITc Cyclic Caller::Add Module() method. Description In a task cycle, the Cycle Update() method is called after Input Update() has been called for all registered module instances. As a result, this method must be used to implement cyclic processing. 12.8.4 Interface ITc Cyclic Caller Interface for logging in or out of the ITc Cyclic interface of a module in a Twin CAT task. Syntax TCOM_DECL_INTERFACE("0300001E-0000-0000-e000-000000000064", ITc Cyclic Caller) struct__declspec(novtable) ITc Cyclic Caller : public ITc Unknown Required include: Tc Io Interfaces.h 166 Version: 1.18.0 Twin CAT 3

## Page 167

Programming Reference Methods Name Description Add Module [} 167] Login module that implements the ITc Cyclic interface. Remove Module [} 168] Log off the previously logged in ITc Cyclic interface of a module. The ITc Cyclic Caller interface is implemented by Twin CAT tasks. A module uses this interface to login its ITc Cyclic interface to a task, usually as the last initialization step during the transition from Safe OP to OP. After login, the Cycle Update() method of the module instance is called. The interface is also used to log off the module so that it is no longer called by the task. 12.8.4.1 Method ITc Cyclic Caller:Add Module Logs the ITc Cyclic interface of a module to a cyclic caller, e.g. a Twin CAT task. Syntax virtual HRESULT TCOMAPI Add Module(STc Cyclic Entry* p Entry, ITc Cyclic* ip Mod, ULONG_PTR context=0, ULONG sort Order=0)=0; Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. The error ADSERR_DEVICE_INVALIDSTATE is returned if the cyclic caller, i.e. the Twin CAT task, is not in the OP state. Parameter Name Type Description p Entry STc Cyclic Entry [in] Pointer to a list item that is inserted into the internal list of the cyclic caller; see also description [} 167]. ip Mod ITc Cyclic [in] Interface pointer used by the cyclic caller. context ULONG_PTR [optional] A context value that is passed to the ITc Cyclic::Cycle Update() method each time it is called. sort Order ULONG [optional] The sort order can be used for controlling the order of execution if various module instances are executed by the same cyclic caller. Description A Twin CAT module class normally uses a Smart Pointer to refer to the cyclic caller type ITc Cyclic Caller Ptr. The object ID of the task is stored in this Smart Pointer and a reference to the task can be obtained via the Twin CAT object server. In addition, the Smart Pointer class already contains a list item. Therefore the Smart Pointer can be used as the first parameter for the Add Module method. The following sample code shows the login of the ITc Cyclic Caller interface. RESULT hr = S_OK; if ( m_sp Cyclic Caller. Has OID() ) { if ( SUCCEEDED_DBG(hr = m_sp Srv->Tc Query Smart Object Interface(m_sp Cyclic Caller)) ) { if ( FAILED(hr = m_sp Cyclic Caller->Add Module(m_sp Cyclic Caller, THIS_CAST(ITc Cyclic))) ) { m_sp Cyclic Caller = NULL; Twin CAT 3 Version: 1.18.0 167

## Page 168

Programming Reference } } } 12.8.4.2 Method ITc Cyclic Caller:Remove Module Remove a module instance from being called by a cyclic caller. Syntax virtual HRESULT TCOMAPI Remove Module(STc Cyclic Entry* p Entry)=0; Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. Parameter Name Type Description p Entry STc Cyclic Entry Refers to the list item to be removed from the internal list of the cyclic caller. The method returns E_FAIL if the entry is not in the internal list. Comparable with the Add Module() method, the smart pointer is used for the cyclic caller as a list item if the module instance is to be removed from the cyclic caller. Declaration and use of the Smart Pointer: ITc Cyclic Caller Info Ptr m_sp Cyclic Caller; if ( m_sp Cyclic Caller ) { m_sp Cyclic Caller->Remove Module(m_sp Cyclic Caller); } m_sp Cyclic Caller = NULL; 12.8.5 Interface ITc File Access Interface for accessing the file system from Twin CAT C++ modules Syntax TCOM_DECL_INTERFACE("742A7429-DA6D-4C1D-80D8-398D8C1F1747", ITc File Access) __declspec(novtable) ITc File Access: public ITc Unknown Required include: Tc File Access Interfaces.h 168 Version: 1.18.0 Twin CAT 3

## Page 169

Programming Reference Methods Name Description File Open [} 169] Opens a file. File Close [} 170] Closes a file. File Read [} 170] Reads from a file. File Write [} 171] Writes to a file. File Seek [} 171] Specifies the position within a file for further actions. File Tell [} 171] Queries the currently set position within a file. File Rename [} 172] Renames a file. File Delete [} 172] Deletes a file. File Get Status [} 172] Gets the status of a file. File Find First [} 173] Searches for a file, first iteration. File Find Next [} 174] Searches for a file, next iteration. File Find Close [} 174] Closes a file search. Mk Dir [} 175] Creates a directory. Rm Dir [} 175] Deletes a directory. The ITc File Access interface is used to access files in file systems. Because the methods provided cause blockages, this interface should not be used in Cycle Update() / real- time context. The derived interface ITc File Access Async [} 175] adds a Check() method that can be used instead. See Sample20a: File IO-Cyclic Read / Write [} 301]. The interface is implemented via the CID_Tc File Access module class. 12.8.5.1 Method ITc File Access:File Open Opens a file. Syntax virtual HRESULT TCOMAPI File Open(PCCH sz File Name, Tc File Access Mode Access Mode, PTc File Handle ph File); Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. A particularly interesting error code is ADSERR_DEVICE_TIMEOUT if the timeout (5 seconds) has elapsed. Parameter Name Type Description sz File Name PCCH [in] the name of the file to be opened. Access Mode Tc File Access Mode [in] method of accessing the file; see Tc File Access Services.h. ph File Tc File Handle [out] returned file handle. Access Modes can be used as follows: typedef enum Tc File Access Mode { am Read = 0x00000001, am Write = 0x00000002, am Append = 0x00000004, Twin CAT 3 Version: 1.18.0 169

## Page 170

Programming Reference am Plus = 0x00000008, am Binary = 0x00000010, am Read Binary = 0x00000011, am Write Binary = 0x00000012, am Text = 0x00000020, am Read Text = 0x00000021, am Write Text = 0x00000022, am Ensure Directory = 0x00000040, am Read Binary ED = 0x00000051, am Write Binary ED = 0x00000052, am Read Text ED = 0x00000061, am Write Text ED = 0x00000062, am Encryption = 0x00000080, am Read Bin Enc = 0x00000091, am Write Bin Enc = 0x00000092, am Read Bin Enc ED = 0x000000d1, am Write Bin Enc ED = 0x000000d2, } Tc File Access Mode, *PTc File Access Mode; 12.8.5.2 Method ITc File Access:File Close Closes a file. Syntax virtual HRESULT TCOMAPI File Close(PTc File Handle ph File); Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. A particularly interesting error code is ADSERR_DEVICE_TIMEOUT if the timeout (5 seconds) has elapsed. Parameter Name Type Description ph File Tc File Handle [out] returned file handle of the file to be closed 12.8.5.3 Method ITc File Access:File Read Reads data from a file. Syntax virtual HRESULT TCOMAPI File Read(Tc File Handle h File, PVOID p Data, UINT cb Data, PUINT pcb Read); Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. A particularly interesting error code is ADSERR_DEVICE_TIMEOUT if the timeout (5 seconds) has elapsed. Parameter Name Type Description h File Tc File Handle [in] refers to the previously opened file. p Data PVOID [out] storage location of the data to be read. cb Data PVOID [in] maximum size of the data to be read (size of the memory behind p Data). pcb Read PUINT [out] size of the data read. 170 Version: 1.18.0 Twin CAT 3

## Page 171

Programming Reference 12.8.5.4 Method ITc File Access:File Write Write data to a file. Syntax virtual HRESULT TCOMAPI File Write(Tc File Handle h File, PCVOID p Data, UINT cb Data, PUINT pcb Write); Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. A particularly interesting error code is ADSERR_DEVICE_TIMEOUT if the timeout (5 seconds) has elapsed. Parameter Name Type Description h File Tc File Handle [in] refers to the previously opened file. p Data PVOID [in] storage location of the data to be written. cb Data PVOID [in] size of the data to be written (size of the memory behind p Data). pcb Read PUINT [out] size of the written data. 12.8.5.5 Method ITc File Access:File Seek Specifies the position within a file for further actions. Syntax virtual HRESULT TCOMAPI File Seek(Tc File Handle h File, UINT ui Pos); Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. A particularly interesting error code is ADSERR_DEVICE_TIMEOUT if the timeout (5 seconds) has elapsed. Parameter Name Type Description h File Tc File Handle [in] refers to the previously opened file. ui Pos UINT [in] position at which setting is to take place. 12.8.5.6 Method ITc File Access:File Tell Queries the currently set position within a file. Syntax virtual HRESULT TCOMAPI File Tell(Tc File Handle h File, PUINT pui Pos); Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. A particularly interesting error code is ADSERR_DEVICE_TIMEOUT if the timeout (5 seconds) has elapsed. Twin CAT 3 Version: 1.18.0 171

## Page 172

Programming Reference Parameter Name Type Description h File Tc File Handle [in] refers to the previously opened file. pui Pos PUINT [out] storage location of the position to be returned. 12.8.5.7 Method ITc File Access:File Rename Renames a file. Syntax virtual HRESULT TCOMAPI File Rename(PCCH sz Old Name, PCCH sz New Name); Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. A particularly interesting error code is ADSERR_DEVICE_TIMEOUT if the timeout (5 seconds) has elapsed. Parameter sz Old Name PCCH [in] the file name to be changed. sz New Name PCCH [in] the new filename. 12.8.5.8 Method ITc File Access:File Delete Deletes a file. Syntax virtual HRESULT TCOMAPI File Delete(PCCH sz File Name); Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. A particularly interesting error code is ADSERR_DEVICE_TIMEOUT if the timeout (5 seconds) has elapsed. Parameter Name Type Description sz File Name PCCH [in] name of the file to be deleted. 12.8.5.9 Method ITc File Access:File Get Status Queries the status of a file. Syntax virtual HRESULT TCOMAPI File Get Status(PCCH sz File Name, PTc File Status p File Status)); Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. 172 Version: 1.18.0 Twin CAT 3

## Page 173

Programming Reference A particularly interesting error code is ADSERR_DEVICE_TIMEOUT if the timeout (5 seconds) has elapsed. Parameter Name Type Description sz File Name PCCH [in] the name of the file in question. p File Status PTc File Status [out] the status of the file, cf. Tc File Access Services.h . Description This method queries status information regarding a given file name. This includes the following information: typedef struct Tc File Status { union { ULONGLONG ul File Size; struct { ULONG ul File Size Low; ULONG ul File Size High; }; }; ULONGLONG ul Create Time; ULONGLONG ul Modified Time; ULONGLONG ul Read Time; DWORD dw Attribute; DWORD w Reserved0; } Tc File Status, *PTc File Status; 12.8.5.10 Method ITc File Access:File Find First Option to scroll through the files in a directory. Syntax virtual HRESULT TCOMAPI File Find First (PCCH sz File Name, PTc File Find Data p File Find Data , PTc File Find Handle ph File Find); Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. A particularly interesting error code is ADSERR_DEVICE_TIMEOUT if the timeout (5 seconds) has elapsed. Parameter Name Type Description sz File Name PCCH [in] directory or path and name of the file sought. The file name can contain placeholders such as asterisk (*) or question mark (?). p File Find Data PTc File Find Data [out] the description of the first file, cf. Tc File Access Services.h ph File Find PTc File Find Handle [out] handle for searching further with File Find Next. Description This method starts by searching for files in a given directory. The method grants access to PTc File Find Data of the first file found, with the following information: typedef struct Tc File Find Data { Tc File Handle h File; DWORD dw File Attributes; ULONGLONG ui64Creation Time; Twin CAT 3 Version: 1.18.0 173

## Page 174

Programming Reference ULONGLONG ui64Last Access Time; ULONGLONG ui64Last Write Time; DWORD dw File Size High; DWORD dw File Size Low; DWORD dw Reserved1; DWORD dw Reserved2; CHAR c File Name[260]; CHAR c Alternate File Name[14]; WORD w Reserved0; } Tc File Find Data, *PTc File Find Data; 12.8.5.11 Method ITc File Access:File Find Next Continue scanning the files in a directory. Syntax virtual HRESULT TCOMAPI File Find Next (Tc File Find Handle h File Find, PTc File Find Data p File Find Data); Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. A particularly interesting error code is ADSERR_DEVICE_TIMEOUT if the timeout (5 seconds) has elapsed. Parameter Name Type Description h File Find PTc File Find Handle [in] handle for searching further with File Find Next. p File Find Data PTc File Find Data [out] the description of the next file. Compare with Tc File Access Services.h Description This method searches for the next file in a directory. The method grants access to PTc File Find Data of the file found, with the following information: typedef struct Tc File Find Data { Tc File Handle h File; DWORD dw File Attributes; ULONGLONG ui64Creation Time; ULONGLONG ui64Last Access Time; ULONGLONG ui64Last Write Time; DWORD dw File Size High; DWORD dw File Size Low; DWORD dw Reserved1; DWORD dw Reserved2; CHAR c File Name[260]; CHAR c Alternate File Name[14]; WORD w Reserved0; } Tc File Find Data, *PTc File Find Data; 12.8.5.12 Method ITc File Access:File Find Close Close the search for files in a directory. Syntax virtual HRESULT TCOMAPI File Find Close (Tc File Find Handle h File Find); Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. 174 Version: 1.18.0 Twin CAT 3

## Page 175

Programming Reference A particularly interesting error code is ADSERR_DEVICE_TIMEOUT if the timeout (5 seconds) has elapsed. Parameter Name Type Description h File Find PTc File Find Handle [in] handle to exit the search. 12.8.5.13 Method ITc File Access:Mk Dir Create a directory in a file system. Syntax virtual HRESULT TCOMAPI Mk Dir(PCCH sz Dir); Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. A particularly interesting error code is ADSERR_DEVICE_TIMEOUT if the timeout (5 seconds) has elapsed. Parameter Name Type Description sz Dir PCCH [in] directory to be created. 12.8.5.14 Method ITc File Access:Rm Dir Remove a directory from the file system. Syntax virtual HRESULT TCOMAPI Rm Dir(PCCH sz Dir); Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. A particularly interesting error code is ADSERR_DEVICE_TIMEOUT if the timeout (5 seconds) has elapsed. Parameter Name Type Description sz Dir PCCH [in] directory to be deleted. 12.8.6 Interface ITc File Access Async Asynchronous access to file operations. This interface extends ITc File Access [} 168]. Syntax TCOM_DECL_INTERFACE("C04AC244-C126-466E-982E-93EC571F2277", ITc File Access Async) struct __declspec(novtable) ITc File Access Async: public ITc File Access Required include: Tc File Access Interfaces.h Twin CAT 3 Version: 1.18.0 175

## Page 176

Programming Reference Properties Name Description PID_Tc File Access Async Segment Size Size of the segments transferred to system service. PID_Tc File Access Async Timeout Ms Sets the timeout in [ms]. PID_Tc File Access Async Net Id(Str) Net Id of the system service to be contacted. Methods Name Description Check [} 176] Check the status of the previously called file operation. Interface can be obtained from module instance with class ID CID_Tc File Access Async. When using the asynchronous interface, the interface methods inherited from the synchronous variant return ADS_E_PENDING if a query has been successfully submitted but not yet completed. If the call is received while the previous request was still being processed, the error code ADS_E_BUSY is returned. Description of the module parameters: • PID_Tc File Access Async Ads Provider: Object ID of a task that provides the ADS interface. • PID_Tc File Access Async Net Id / PID_Tc File Access Async Net Id Str: Ams Net Id of the system service used for file access. The "Str" variant takes the Ams Net Id as string. Please use one. • PID_Tc File Access Async Timeout Ms: Timeout for a file access. • PID_Tc File Access Async Segment Size: The read and write access to file is fragmented with this segment size. See Sample20a: File IO-Cyclic Read / Write [} 301]. 12.8.6.1 Method ITc File Access Async::Check() Check the status of the previously called file operation. Syntax virtual HRESULT TCOMAPI Check(); Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. Particularly interesting error codes are • ADSERR_DEVICE_TIMEOUT if the timeout (5 seconds) has elapsed. • ADSERR_DEVICE_PENDING if the file operation is not completed. Parameter none 12.8.7 Interface ITc Io Cyclic This interface is implemented by Twin CAT modules that are called during the input update and output update within a task cycle. Syntax TCOM_DECL_INTERFACE("03000011-0000-0000-e000-000000000064", ITc Io Cyclic) struct __declspec(novtable) ITc Io Cyclic : public ITc Unknown 176 Version: 1.18.0 Twin CAT 3

## Page 177

Programming Reference Required include: Tc Io Interfaces.h Methods Name Description Input Update [} 177] Is called at the beginning of a task cycle if the interface is logged on to a cyclic I/O caller. Output Update [} 177] Is called at the end of a task cycle if the interface is logged on to a cyclic I/O caller. ITc Io Cyclic can be used to implement a Twin CAT module that acts as a fieldbus driver or I/O filter module. This interface is passed to the method ITc Io Cyclic Caller::Add Io Driver when a module logs on to a task, usually as the last initialization step in the transition from Safe OP to OP. After login, the Input Update() and Output Update() methods of the module instance are each called once per task cycle. 12.8.7.1 Method ITc Io Cyclic:Input Update Is called at the beginning of a task cycle if the interface is logged on to a cyclic I/O caller. Syntax virtual HRESULT TCOMAPI Input Update(ITc Task* ip Task, ITc Unknown* ip Caller, DWORD dw State In, ULONG_PTR context = 0)=0; Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. Parameter Name Type Description ip Task ITc Task Refers to the current task context. ip Caller ITc Unknown Refers to the calling instance. dw State In DWORD Future extensions reserved; at present this value is always 0. context ULONG_PTR Context contains the value that was passed to the ITc Cyclic Caller::Add Io Driver() method. Description In a task cycle the Input Update() method is first called for all registered module instances. Therefore this method must be used for updating the data areas of the Input-Source type of the module. 12.8.7.2 Method ITc Io Cyclic:Output Update Is called at the end of a task cycle if the interface is logged on to a cyclic I/O caller. Syntax virtual HRESULT TCOMAPI Output Update(ITc Task* ip Task, ITc Unknown* ip Caller, PDWORD pdw State Out = NULL, ULONG_PTR context = 0)=0; Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. Twin CAT 3 Version: 1.18.0 177

## Page 178

Programming Reference Parameter Name Type Description ip Task ITc Task Refers to the current task context. ip Caller ITc Unknown Refers to the calling instance. pdw State Out DWORD [out] reserved for future extensions, currently the return value is ignored. context ULONG_PTR Context contains the value that was passed to the ITc Cyclic Caller::Add Io Driver() method. Description In a task cycle the Output Update() method is called for all registered module instances. Therefore this method must be used for updating the data areas of the type Output-Destination of the module. 12.8.8 Interface ITc Io Cyclic Caller Interface for logging in or out of the ITc Io Cyclic interface of a module in a Twin CAT task. Syntax TCOM_DECL_INTERFACE("0300001F-0000-0000-e000-000000000064", ITc Io Cyclic Caller) struct__declspec(novtable) ITc Io Cyclic Caller : public ITc Unknown Required include: Tc Io Interfaces.h Methods Name Description Add Io Driver [} 178] Login module that implements the ITc Io Cyclic interface. Remove Io Driver [} 179] Log off the previously logged in ITc Io Cyclic interface of a module. The ITc Io Cyclic Caller interface is implemented by Twin CAT tasks. A module uses this interface to login its ITc Io Cyclic interface to a task, usually as the last initialization step in the Safe OP to OP transition. After login, the Cycle Update() method of the module instance is called. The interface is also used to log off the module so that it is no longer called by the task. 12.8.8.1 Method ITc Io Cyclic Caller:Add Io Driver Logs the ITc Io Cyclic interface of a module to a cyclic I/O caller, e.g. a Twin CAT task. Syntax virtual HRESULT TCOMAPI Add Io Driver(STc Io Cyclic Entry* p Entry, ITc Io Cyclic* ip Drv, ULONG_PTR context=0, ULONG sort Order=0)=0; Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. 178 Version: 1.18.0 Twin CAT 3

## Page 179

Programming Reference Parameter Name Type Description p Entry STc Io Cyclic Entry Pointer to a list item that is inserted into the internal list of the cyclic I/O caller; see also description [} 167]. ip Drv ITc Io Cyclic [in] interface pointer used by the cyclic I/O caller. context ULONG_PTR [optional] a context value that is transferred to the ITc Io Cyclic::Input Update() and ITc Io Cyclic::Output Update methods with each call. sort Order ULONG [optional] The sort order can be used for controlling the order of execution if various module instances are executed by the same cyclic caller. Description A Twin CAT module class normally uses a Smart Pointer to refer to the cyclic I/O caller of type ITc Io Cyclic Caller Ptr. The object ID of the cyclic I/O caller is stored in this Smart Pointer and a reference can be obtained via the Twin CAT object server. In addition, the Smart Pointer class already contains a list item. Therefore the Smart Pointer can be used as the first parameter for the Add Io Driver method. The following code sample illustrates the login of the ITc Io Cyclic Caller interface. HRESULT hr = S_OK; if ( m_sp Io Cyclic Caller. Has OID() ) { if ( SUCCEEDED_DBG(hr = m_sp Srv->Tc Query Smart Object Interface(m_sp Io Cyclic Caller)) ) { if ( FAILED(hr = m_sp Io Cyclic Caller->Add Io Driver(m_sp Io Cyclic Caller, THIS_CAST(ITc Io Cyclic))) ) { m_sp Io Cyclic Caller = NULL; } } } 12.8.8.2 Method ITc Io Cyclic Caller:Remove Io Driver Remove a module instance from being called by a cyclic I/O caller. Syntax virtual HRESULT TCOMAPI Remove Io Driver(STc Io Cyclic Entry* p Entry)=0; Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. The method returns E_FAIL if the entry is not in the internal list. Parameter Name Type Description p Entry STc Io Cyclic Entry Refers to the list item to be removed from the internal list of the cyclic I/O caller. Comparable with the Add Io Driver() method, the smart pointer is used for the cyclic I/O caller as a list item if the module instance is to be removed from the cyclic I/O caller. Declaration and use of the Smart Pointer: ITc Io Cyclic Caller Info Ptr m_sp Io Cyclic Caller; if ( m_sp Io Cyclic Caller ) Twin CAT 3 Version: 1.18.0 179

## Page 180

Programming Reference { m_sp Io Cyclic Caller->Remove Io Driver(m_sp Io Cyclic Caller); } m_sp Cyclic Caller = NULL; 12.8.9 ITCom Online Change interface The ITCom Online Change interface is used to perform Online Changes of modules. Syntax TCOM_DECL_INTERFACE ("D28A8CD2-5477-4B75-AF0F-998841AF9E44", ITCom Online Change) Methods Name Description Prepare Online Change [} 180] This method is called by Twin CAT to prepare for the Online Change. Perform Online Change [} 180] This method is called by Twin CAT to perform the Online Change. The implementation of this interface is necessary for a module to be capable of Online Change. Furthermore such a module must be created in a versioned C++ project. • Here [} 152] is a general description of the procedure. • This procedure can be followed for existing modules: Online Change [} 152]. 12.8.9.1 Method ITCom Online Change:Prepare Online Change This method is called by Twin CAT to prepare for the Online Change. It runs asynchronously in the background, which must be taken into account when accessing the existing object. The preparation should include all operations that can already be performed. Syntax virtual HRESULT TCOMAPI Prepare Online Change(ITCom Object* ip Old Obj, Tmc Inst Data* p Old Info) = 0; Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. Parameter Name Type Description ip Old Obj ITCom Object* Reference to the existing object to be exchanged. p Old Info Tmc Inst Data* Reference to information of the existing object. Via ip Old Obj, the data of the existing object is made available for transfer so that it can be applied. For example: ULONG n Data = sizeof(m_Parameter); PVOID p Data = &m_Parameter; ip Old Obj->Tc Get Obj Para(PID_Module1Parameter, n Data, p Data); 12.8.9.2 Method ITCom Online Change:Perform Online Change This method is called by Twin CAT to perform the Online Change. 180 Version: 1.18.0 Twin CAT 3

## Page 181

Programming Reference It is called blocking. It should therefore only take a short time. Syntax virtual HRESULT TCOMAPI Perform Online Change(ITCom Object* ip Old Obj, Tmc Inst Data* p Old Info) = 0; Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. Parameter Name Type Description ip Old Obj ITCom Object* Reference to the existing object to be exchanged. p Old Info Tmc Inst Data* Reference to information of the existing object. Via ip Old Obj, the data of the existing object is made available for transfer so that it can be applied. For example: ULONG n Data = sizeof(m_Parameter); PVOID p Data = &m_Parameter; ip Old Obj->Tc Get Obj Para(PID_Module1Parameter, n Data, p Data); 12.8.10 ITCom Object interface The ITCom Object interface is implemented by every Twin CAT module. It makes basic functionalities available. Syntax TCOM_DECL_INTERFACE("00000012-0000-0000-e000-000000000064", ITCom Object) struct__declspec(novtable) ITCom Object: public ITc Unknown Methods Name Description Tc Get Object Id(OTCID& obj Id) Saves the object ID using the given OTCID reference. [} 181] Tc Set Object Id [} 182] Sets the object ID of the object to the given OTCID. Tc Get Object Name [} 182] Saves the object names in the buffer with the given length. Tc Set Object Name [} 182] Sets the object name of the object to given CHAR*. Tc Set Obj State [} 183] Initializes a transition to a predefined state. Tc Get Obj State [} 183] Queries the current state of the object. Tc Get Obj Para [} 183] Queries an object parameter identified with its PTCID. Tc Set Obj Para [} 184] Sets an object parameter identified with its PTCID. Tc Get Parent Obj Id [} 184] Saves the parent object ID with the help of the given OTCID reference. Tc Set Parent Obj Id [} 185] Sets the parent object ID to the given OTCID. The ITCom Object interface is implemented by every Twin CAT module. It makes functionalities available regarding the state machine and information from/to the Twin CAT system. 12.8.10.1 ITc Com Object:Tc Get Object Id method The method saves the object ID with the help of the given OTCID reference. Twin CAT 3 Version: 1.18.0 181

## Page 182

Programming Reference Syntax HRESULT Tc Get Object Id( OTCID& obj Id ) Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. Parameter Name Type Description obj Id OTCID& Reference to OTCID value. 12.8.10.2 ITc Com Object:Tc Set Object Id method The Tc Set Object Id method sets the object ID of the object to the given OTCID. Syntax HRESULT Tc Set Object Id( OTCID obj Id ) Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. At present, the return value is ignored by the Twin CAT tasks. Parameter Name Type Description obj Id OTCID The OTCID to be set - indicates the success of the ID change. 12.8.10.3 ITc Com Object:Tc Get Object Name method The Tc Get Object Name method saves the object names in the buffer with the given length. Syntax HRESULT Tc Get Object Name( CHAR* obj Name, ULONG name Len ); Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. Parameter Name Type Description obj Name CHAR* The name to be set. name Len ULONG The maximum length to be written. 12.8.10.4 ITc Com Object:Tc Set Object Name method The Tc Set Object Name method sets the object name of the object to the given CHAR*. 182 Version: 1.18.0 Twin CAT 3

## Page 183

Programming Reference Syntax HRESULT Tc Set Object Name( CHAR* obj Name ) Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. Parameter Name Type Description obj Name CHAR* The name to be set of the object. 12.8.10.5 ITc Com Object:Tc Set Obj State method The Tc Set Obj State method initializes a transition to the given state. Syntax HRESULT Tc Set Obj State(TCOM_STATE state, ITCom Object Server* ip Srv, PTCom Init Data Hdr p Init Data); Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. Parameter Name Type Description state TCOM_STATE Displays the new state. ip Srv ITCom Object Server* Obj Server that handles the object. p Init Data PTCom Init Data Hdr Points to a list of parameters (optional); see the IMPLEMENT_ITCOMOBJECT_EVALUATE_INITDATA macro as an example of how the list can be iterated. 12.8.10.6 ITc Com Object:Tc Get Obj State method The Tc Get Obj State method queries the current state of the object. Syntax HRESULT Tc Get Obj State(TCOM_STATE* p State) Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. Parameter Name Type Description p State TCOM_STATE* Pointer to the state. 12.8.10.7 ITc Com Object:Tc Get Obj Para method The Tc Get Obj Para method queries an object parameter identified by means of its PTCID. Twin CAT 3 Version: 1.18.0 183

## Page 184

Programming Reference Syntax HRESULT Tc Get Obj Para(PTCID pid, ULONG& n Data, PVOID& p Data, PTCGP pgp=0) Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. Parameter Name Type Description pid PTCID Parameter-ID of the object parameter. n Data ULONG& Max. length of data. p Data PVOID& Pointer to the data. pgp PTCGP Reserved for future expansion, pass NULL. 12.8.10.8 ITc Com Object:Tc Set Obj Para method The Tc Set Obj Para method sets an object parameter identified by means of its PTCID. Syntax HRESULT Tc Set Obj Para(PTCID pid, ULONG n Data, PVOID p Data, PTCGP pgp=0) Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. Parameter Name Type Description pid PTCID Parameter-ID of the object parameter. n Data ULONG Max. length of data. p Data PVOID Pointer to the data. pgp PTCGP Reserved for future expansion, pass NULL. 12.8.10.9 ITc Com Object:Tc Get Parent Obj Id method The Tc Get Parent Obj Id method saves the parent object ID with the help of the given OTCID reference. Syntax HRESULT Tc Get Parent Obj Id( OTCID& obj Id ) Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. Parameter Name Type Description obj Id OTCID& Reference to OTCID value. 184 Version: 1.18.0 Twin CAT 3

## Page 185

Programming Reference 12.8.10.10 ITc Com Object:Tc Set Parent Obj Id method The Tc Set Parent Obj Id method sets the parent object ID with the help of the given OTCID reference. Syntax HRESULT Tc Set Parent Obj Id( OTCID obj Id ) Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. At present, the return value is ignored by the Twin CAT tasks. Parameter Name Type Description obj Id OTCID Reference to OTCID value. 12.8.11 ITCom Object interface (C++ convenience) The ITCom Object interface is implemented by every Twin CAT module. It makes basic functionalities available. Twin CAT C++ provides additional functions, which are not directly defined through the interface. Syntax Required include: Tc Interfaces.h Methods Name Description OTCID Tc Get Object Id [} 185] Queries the object ID. Tc Try To Release Op State [} 185] Releases resources; must be implemented. Further methods exist, which are not itemized here. This functionality is provided as standard by the module wizards. 12.8.11.1 Tc Get Object Id method The method queries the object ID. Syntax OTCID Tc Get Object Id(void) Return value Name Description OTCID Returns the OTCID of the object. 12.8.11.2 Tc Try To Release Op State method The method Tc Try To Release Op State releases resources, e.g. data pointers, in order to prepare for exiting the OP state. Twin CAT 3 Version: 1.18.0 185

## Page 186

Programming Reference Syntax BOOL Tc Try To Release Op State(void) Return value TRUE or FALSE is returned. Description The Tc Try To Release Op State method must be implemented to remove possible mutual dependencies between module instances. It is only called if another module holds a reference to this module. 12.8.12 Interface ITc Post Cyclic The interface is implemented by Twin CAT modules that are called once per task cycle following the output update (comparable to the attribute Tc Call After Output Update of the PLC). Syntax TCOM_DECL_INTERFACE("03000025-0000-0000-e000-000000000064", ITc Post Cyclic) struct__declspec(novtable) ITc Post Cyclic : public ITc Unknown Required include: Tc Io Interfaces.h Methods Name Description Post Cycle Update Is called once per task cycle after the output update if the interface has been logged on to a cyclic caller. [} 186] The ITc Post Cyclic interface is implemented by Twin CAT modules. This interface is passed to the ITc Cyclic Caller::Add Post Module() method when a module logs itself on to a task, usually as the last initialization step during the transition from Safe OP to OP. After login, the Post Cycle Update() method of the module instance is called. 12.8.12.1 Method ITc Post Cyclic:Post Cyclic Update The Post Cyclic Update method normally called by a Twin CAT task after the output update, after the interface has been logged in. Syntax HRESULT TCOMAPI Post Cycle Update(ITc Task* ip Task, ITc Unknown* ip Caller, ULONG_PTR context) Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. At present, the return value is ignored by the Twin CAT tasks. Parameter Name Type Description ip Task ITc Task Refers to the current task context. ip Caller ITc Unknown Refers to the calling instance. Context ULONG_PTR Context contains the value that was passed to the method ITc Post Cyclic Caller::Add Post Module(). 186 Version: 1.18.0 Twin CAT 3

## Page 187

Programming Reference Description Within a task cycle, the Post Cycle Update() method is called after Output Update() has been called for all registered module instances. As a result, this method must be used to implement such cyclic processing. 12.8.13 Interface ITc RTime Task Query of extended Twin CAT task information. Syntax TCOM_DECL_INTERFACE("02000003-0000-0000-e000-000000000064", ITc RTime Task) struct __declspec(novtable) ITc RTime Task : public ITc Task Required include: Tc Rt Interfaces.h Methods Name Description Get Cpu Account [} 187] Query of the CPU account of a Twin CAT task. Twin CAT task information can be queried and used with this interface. See Sample30: Timing Measurement [} 311] 12.8.13.1 Method ITc RTime Task::Get Cpu Account() Query of the CPU account of a Twin CAT task. Syntax virtual HRESULT TCOMAPI Get Cpu Account(PULONG p Account)=0; Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. E_POINTER if the parameter p Account = NULL. Parameter Name Type Description p Account PULONG [out] Twin CAT Task CPU account is stored in this parameter. The Get Cpu Account() method can be used to query the current computing time used for the task. Code snippet showing the use of Get Cpu Account(), e.g. within an ITc Cyclic::Cycle Update() method: // CPU account in 100 ns interval ITc RTime Task Ptr sp RTime Task = ip Task; ULONG n Cpu Account For Compute Something = 0; if (sp RTime Task != NULL) { ULONG n Start = 0; hr = FAILED(hr) ? hr : sp RTime Task->Get Cpu Account(&n Start); Compute Something(); ULONG n Stop = 0; hr = FAILED(hr) ? hr : sp RTime Task->Get Cpu Account(&n Stop); n Cpu Account For Compute Something = n Stop - n Start; } Twin CAT 3 Version: 1.18.0 187

## Page 188

Programming Reference 12.8.14 Interface ITc Task Query of the timestamp and task-specific information of a Twin CAT task. Syntax TCOM_DECL_INTERFACE("02000002-0000-0000-e000-000000000064", ITc Task) struct __declspec(novtable) ITc Task : public ITc Unknown Required include: Tc Rt Interfaces.h Methods Name Description Get Cycle Counter [} 190] Querying the number of task cycles since task start. Get Cycle Time [} 190] Querying the task cycle time in nanoseconds, i.e. time between "begin of task" and next "begin of task". Get Priority [} 188] Querying the task priority. Get Current Sys Time [} 189] Querying the time when the task cycle starts at intervals of 100 nanoseconds since January 1, 1601 (UTC). Get Current Dc Time [} 189] Querying the distributed clock time when the task cycle starts in nanoseconds since January 1, 2000. Get Cur Pentium Time [} 190] Querying the time when the method is called at intervals of 100 nanoseconds since January 1, 1601 (UTC). With the ITc Task interface the time can be measured in real-time context. 12.8.14.1 Method ITc Task:Get Priority Querying the task priority. Syntax virtual HRESULT TCOMAPI Get Priority(PULONG p Priority)=0; 188 Version: 1.18.0 Twin CAT 3

## Page 189

Programming Reference Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. E_POINTER if the parameter p Priority = NULL. Parameter Name Type Description p Priority PULONG [out] Priority value of the task is stored in this parameter. Sample30: Timing Measurement [} 311] illustrates the use of this method. 12.8.14.2 Method ITc Task:Get Current Sys Time Querying the time when the task cycle starts at intervals of 100 nanoseconds since January 1, 1601 (UTC). Syntax virtual HRESULT TCOMAPI Get Current Sys Time(PLONGLONG p Sys Time)=0; Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. E_POINTER if the parameter p Sys Time = NULL. Parameter Name Type Description p Sys Time PLONGLONG [out] This parameter stores the current system time at the beginning of the task cycle. Sample30: Timing Measurement [} 311] illustrates the use of this method. 12.8.14.3 Method ITc Task:Get Current Dc Time Querying the distributed clock time when the task cycle starts in nanoseconds since January 1, 2000. Syntax virtual HRESULT TCOMAPI Get Current Dc Time(PLONGLONG p Dc Time)=0; Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. E_POINTER if the parameter p Dc Time = NULL. Parameter Name Type Description p Dc Time PLONGLONG [out] This parameter stores the distributed clock time at the beginning of the task cycle. Twin CAT 3 Version: 1.18.0 189

## Page 190

Programming Reference Sample30: Timing Measurement [} 311] illustrates the use of this method. 12.8.14.4 Method ITc Task:Get Cur Pentium Time Querying the time when the method is called at intervals of 100 nanoseconds since January 1, 1601 (UTC). Syntax virtual HRESULT TCOMAPI Get Cur Pentium Time(PLONGLONG p Cur Time)=0; Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. E_POINTER if the parameter p Cur Time = NULL. Parameter Name Type Description p Cur Time PLONGLONG [out] This parameter stores the current time (UTC) in 100 nanosecond intervals since January 1, 1601. Sample30: Timing Measurement [} 311] illustrates the use of this method. 12.8.14.5 Method ITc Task:Get Cycle Counter Querying the number of task cycles since task start. Syntax virtual HRESULT TCOMAPI Get Cycle Counter(PULONGLONG p Cnt)=0; Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. E_POINTER if the parameter p Cnt = NULL. Parameter Name Type Description p Cnt PULONGLONG [out] The number of task cycles since the task was started is stored in this parameter. Sample30: Timing Measurement [} 311] illustrates the use of this method. 12.8.14.6 Method ITc Task:Get Cycle Time Querying the task cycle time in nanoseconds, i.e. time between "begin of task" and next "begin of task". Syntax virtual HRESULT TCOMAPI Get Cycle Time(PULONG p Cycle Time NS)=0; 190 Version: 1.18.0 Twin CAT 3

## Page 191

Programming Reference Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. E_POINTER if the parameter p Cnt = NULL. Parameter Name Type Description p Cycle Time NS PULONG [out] The configured task cycle time is stored in nanoseconds in this parameter. Sample30: Timing Measurement [} 311] illustrates the use of this method. 12.8.15 Interface ITc Task Notification Executes a callback if the cycle time was exceeded during the previous cycle. This interface provides comparable functions such as PLC Plc Task System Info->Cycle Time Exceeded. Syntax TCOM_DECL_INTERFACE("9CDE7C78-32A0-4375-827E-924B31021FCD", ITc Task Notification) struct __declspec(novtable) ITc Task Notification: public ITc Unknown Required include: Tc Rt Interfaces.h Methods Name Description Notify Cycle Time Exceeded [} 191] Called if the cycle time was exceeded. Note that the callback does not take place during the calculations, but at the end of the cycle. Therefore, this method does not offer any mechanism for immediately stopping the calculations. 12.8.15.1 Method ITc Task Notification::Notify Cycle Time Exceeded() Called when the cycle time has previously expired, i.e., not immediately upon timeout, but afterwards. Syntax virtual HRESULT TCOMAPI Notify Cycle Time Exceeded (); Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. Parameter Name Type Description ip Task ITc Task Refers to the current task context. context ULONG_PTR Context 12.8.16 Interface ITc Unknown ITc Unknown defines the reference count as well as the querying of a reference to a more specific interface. Twin CAT 3 Version: 1.18.0 191

## Page 192

Programming Reference Syntax TCOM_DECL_INTERFACE("00000001-0000-0000-e000-000000000064", ITc Unknown) Declared in: Tc Interfaces.h Required include: - Methods Name Description Tc Add Ref [} 192] Increments the reference counter. Tc Query Interface [} 192] Query of the reference to an implemented interface via the IID. Tc Release [} 193] Decrements the reference counter. Every Tc COM interface is derived directly or indirectly from ITc Unknown. As a result, every Tc COM module class implements ITc Unknown because it is derived from ITCom Object. The standard implementation of ITc Unknown ensures that the object is deleted after the last reference is released. For this reason, an interface pointer must not be dereferenced after calling Tc Release(). 12.8.16.1 Method ITc Unknown:Tc Add Ref Increments the reference counter and returns the new value. Syntax ULONG Tc Add Ref( ) Return value Resulting reference count value. 12.8.16.2 Method ITc Unknown:Tc Query Interface Query of an interface pointer with regard to an interface that is given by interface ID (IID). Syntax HRESULT Tc Query Interface(RITCID iid, PPVOID pip Itf ) Return value If successful, S_OK ("0") or another positive value will be returned, cf. Return values [} 165]. Extended messages refer in particular to the column HRESULT in ADS Return Codes [} 334]. If the demanded interface is not available, the method returns ADSERR_DEVICE_NOINTERFACE. Parameter Name Type Description iid RITCID Interface IID. pip Itf PPVOID Pointer to interface pointer. Is set when the requested interface type is available from the corresponding instance. Description Query of the reference to an implemented interface via the IID. It is recommended to use Smart Pointers to initialize and hold interface pointers. Variant 1: 192 Version: 1.18.0 Twin CAT 3

## Page 193

Programming Reference HRESULT Get Trace Level(ITc Unkown* ip, Tc Trace Level& tl) { HRESULT hr = S_OK; if (ip != NULL) { ITCom Object Ptr sp Obj; hr = ip->Tc Query Interface(sp Obj. Get IID(), &sp Obj); if (SUCCEEDED(hr)) { hr = sp Obj->Tc Get Obj Para(PID_Tc Trace Level, &tl, sizeof(tl)); } return hr; } } The interface ID associated with the Smart Pointer can be used as a parameter in Tc Query Interface. The "&" operator will return the pointer to the internal interface pointer member variable of the Smart Pointer. Variant 1 assumes that the interface pointer is initialized when Tc Query Interface indicates success. If the range remains, then the destructor of the Smart Pointer sp Obj releases the reference. Variant 2: HRESULT Get Trace Level(ITc Unkown* ip, Tc Trace Level& tl) { HRESULT hr = S_OK; ITCom Object Ptr sp Obj = ip; if (sp Obj != NULL) { sp Obj->Tc Get Obj Param(PID_Tc Trace Level, &tl); } else { hr = ADS_E_NOINTERFACE; } return hr; } If the interface pointer ip is assigned to the Smart Pointer sp Obj, then the Tc Query Interface method is called implicitly with IID_ITCom Object on the instance to which ip refers. This results in a shorter code, but the original return code of Tc Query Interface is lost. 12.8.16.3 Method ITc Unknown:Tc Release This method decrements the reference counter. Syntax ULONG Tc Release( ) Return value Resulting reference count value. Description Decrements the reference counter and returns the new value. If the reference counter is 0, the object deletes itself. 12.9 Runtime Library (Rtl R0.h) Twin CAT has its own implementation of the runtime library. These functions are declared in Rtl R0.h, a part of Twin CAT SDK. Twin CAT 3 Version: 1.18.0 193

## Page 194

Programming Reference Methods provided Name Description abs Calculates the absolute value. atof Converts a string (char *buf) into a double. Bit Scan Forward Searches for a set bit (1) from LSB to MSB. Bit Scan Reverse Searches for a set bit (1) from MSB to LSB. labs Calculates the absolute value. memcmp Compares two buffers. memcpy Copies one buffer into another. memcpy_byte Copies one buffer into another (bytewise). memset Sets the bytes of a buffer to a value. qsort Quick Sort for sorting a list. snprintf Writes formatted data into a character string. sprintf Writes formatted data into a character string. sscanf Reads data from a character string after specification of a format. strcat Appends one character string to another. strchr Searches for a character in a character string. strcmp Compares two character strings. strcpy Copies a character string. strlen Determines the length of a character string. strncat Appends one character string to another. strncmp Compares two character strings. strncpy Copies a character string. strstr Searches for a character string within a character string. strtol Converts a character string into an integer. strtoul Converts a character string into an unsigned integer. swscanf Reads data from a character string after specification of a format. tolower Converts a letter into a lower-case letter. toupper Converts a letter into an upper-case letter. vsnprintf Writes formatted data into a character string ('\0' scheduling). vsprintf Writes formatted data into a character string. All functions are based on the C++ runtime library. 12.10 ADS Communication ADS based on client-server principle. An ADS query calls the corresponding indication methods on the server side. The ADS response calls the corresponding confirmation method on the client side. 194 Version: 1.18.0 Twin CAT 3

## Page 195

Programming Reference ADS client-server sequence In this section both the outgoing and incoming ADS communication is described for Twin CAT 3 C++ modules. ADS command set Description Ads Read Device Info [} 195] The general device information can be read with this command. Ads Read [} 197] ADS read command for retrieving data from an ADS device. Ads Write [} 199] ADS write command for transferring data to an ADS device. Ads Read State [} 203] ADS command to query the state of an ADS device. Ads Write Control [} 205] ADS control command to change the state of an ADS device. Ads Add Device Notification [} 207] Observe variable. The client is informed in case of an event. Ads Del Device Notification [} 209] Removes the variable that was previously linked. Ads Device Notification [} 210] Used to transfer the device notification event. Ads Read Write [} 201] ADS read/write command. Data is transmitted to an ADS device (write) and its response data read with one call. The ADS Return Codes [} 334] apply to the entire ADS communication. To get started, take a look at Sample07: Receiving ADS Notifications [} 263]. 12.10.1 Ads Read Device Info 12.10.1.1 Ads Read Device Info Req The method Ads Device Info Req enables the transfer of an ADS Device Info command for reading the identification and version number of an ADS server. Ads Read Device Info Con is called on receipt of the response. Syntax int Ads Read Device Info Req( Ams Addr& r Addr, ULONG invoke Id ); Return value Type: int Twin CAT 3 Version: 1.18.0 195

## Page 196

Programming Reference Error code - see Ads Statuscodes [} 334]. Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. 12.10.1.2 Ads Read Device Info Ind The Ads Device Info Ind method refers to an ADS Device Info command for reading the identification and version number of an ADS server. Ads Read Device Info Res [} 196] must then be called. Syntax void Ads Read Device Info Ind( Ams Addr& r Addr, ULONG invoke Id ); Return value void Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. 12.10.1.3 Ads Read Device Info Res The method Ads Read Device Info Res sends an ADS Read Device Info. Ads Read Device Info Con [} 197] forms the counterpart and is subsequently called. Syntax int Ads Read Device Info Res( Ams Addr& r Addr, ULONG invoke Id, ULONG n Result, CHAR name[ADS_FIXEDNAMESIZE], Ads Version version ); Return value Type: int Error code - see Ads Statuscodes [} 334]. Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the responding ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. n Result ULONG [in] contains the result of the ADS write command; see Ads Statuscodes [} 334]. name char[ADS_FIXEDNAMESIZE [in] contains the name of the device. version Ads Version [in] structure of build (int), revision (byte) and version (byte) of the device. 196 Version: 1.18.0 Twin CAT 3

## Page 197

Programming Reference 12.10.1.4 Ads Read Device Info Con The Ads Read Device Info Con method enables the receipt of an ADS read confirmation of device information. The receiving module must provide this method. The counterpart Ads Read Device Info Req [} 195]must be called beforehand. Syntax void Ads Read Device Info Con( Ams Addr& r Addr, ULONG invoke Id, ULONG n Result, CHAR name[ADS_FIXEDNAMESIZE], Ads Version version ); Return value void Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the responding ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. n Result ULONG [in] contains the result of the ADS write command; see Ads Statuscodes [} 334]. name char[ADS_FIXEDNAMESIZE] [in] contains the name of the device. version Ads Version [in] structure of build (int), revision (byte) and version (byte) of the device. 12.10.2 Ads Read 12.10.2.1 Ads Read Req The Ads Read Req method enables the sending of an ADS read command for the data transmission from an ADS device. Ads Read Con [} 199] is called on receipt of the response. Syntax int Ads Read Req( Ams Addr& r Addr, ULONG invoke Id, ULONG index Group, ULONG index Offset, ULONG cb Length ); Return value Type: int Error code - see Ads Statuscodes [} 334]. Twin CAT 3 Version: 1.18.0 197

## Page 198

Programming Reference Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. index Group ULONG [in] Contains the index group number (32-bit, unsigned) of the requested ADS service. index Offset ULONG [in] Contains the index offset number (32-bit, unsigned) of the requested ADS service. cb Length ULONG [in] contains the length in bytes of the data to be read (p Data). 12.10.2.2 Ads Read Ind The Ads Read Ind method enables the receipt of an ADS read request. The Ads Read Res [} 198] must be called to send the result. Syntax void Ads Read Ind( Ams Addr& r Addr, ULONG invoke Id, ULONG index Group, ULONG index Offset, ULONG cb Length ); Return value Type: int ADS Return Code - see Ads Statuscodes [} 334]. Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the responding ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. index Group ULONG [in] Contains the index group number (32-bit, unsigned) of the requested ADS service. index Offset ULONG [in] Contains the index offset number (32-bit, unsigned) of the requested ADS service. cb Length ULONG [in] contains the length in bytes of the data to be read (p Data). 12.10.2.3 Ads Read Res The method Ads Read Res enables the sending of an ADS read response. Ads Read Con [} 199] forms the counterpart and is subsequently called. Syntax int Ads Read Res( Ams Addr& r Addr, ULONG invoke Id, ULONG n Result, ULONG cb Length, PVOID p Data ); Return value Type: int ADS Return Code - see Ads Statuscodes [} 334]. 198 Version: 1.18.0 Twin CAT 3

## Page 199

Programming Reference Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the responding ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. n Result ULONG [in] contains the result of the ADS read command; see Ads Statuscodes [} 334]. cb Length ULONG [in] contains the length in bytes of the data read (p Data). p Data PVOID [in] pointer to the data buffer in which the data are located. 12.10.2.4 Ads Read Con The method Ads Read Con enables the receipt of an ADS read confirmation. The receiving module must provide this method. The counterpart is Ads Read Req [} 197] and must have been called beforehand. Syntax void Ads Read Con( Ams Addr& r Addr, ULONG invoke Id, ULONG n Result, ULONG cb Length, PVOID p Data ); Return value void Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the responding ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. n Result ULONG [in] contains the result of the ADS read command; see Ads Statuscodes [} 334]. cb Length ULONG [in] contains the length in bytes of the data read (p Data). p Data PVOID [in] pointer to the data buffer in which the data are located. 12.10.3 Ads Write 12.10.3.1 Ads Write Req The method Ads Write Req enables the sending of an ADS write command for transferring data to an ADS device. Ads Write Con [} 201] is called on receipt of the response. Syntax int Ads Write Req( Ams Addr& r Addr, ULONG invoke Id, ULONG index Group, ULONG index Offset, ULONG cb Length, PVOID p Data ); Return value Type: int Error code - see Ads Statuscodes [} 334]. Twin CAT 3 Version: 1.18.0 199

## Page 200

Programming Reference Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. index Group ULONG [in] contains the index group number (32-bit, unsigned) of the requested ADS service. index Offset ULONG [in] contains the index offset number (32-bit, unsigned) of the requested ADS service. cb Length ULONG [in] contains the length in bytes of the data to be written (p Data). p Data PVOID [in] pointer to the data buffer in which the written data are located. 12.10.3.2 Ads Write Ind The Ads Write Ind method specifies an ADS write command to transfer data to an ADS device. The Ads Write Res [} 200] must be called to confirm the operation. Syntax void Ads Write Ind( Ams Addr& r Addr, ULONG invoke Id, ULONG index Group, ULONG index Offset, ULONG cb Length, PVOID p Data ); Return value void Error code - see Ads Statuscodes [} 334]. Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. index Group ULONG [in] Contains the index group number (32-bit, unsigned) of the requested ADS service. index Offset ULONG [in] Contains the index offset number (32-bit, unsigned) of the requested ADS service. cb Length ULONG [in] Contains the length in bytes of the data to be written (p Data). p Data PVOID [in] pointer to the data buffer in which the written data are located. 12.10.3.3 Ads Write Res The Ads Write Res method sends an ADS write response. Ads Write Con [} 201] forms the counterpart and is subsequently called. Syntax int Ads Write Res( Ams Addr& r Addr, ULONG invoke Id, ULONG n Result ); Return value Type: int 200 Version: 1.18.0 Twin CAT 3

## Page 201

Programming Reference Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the responding ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. n Result ULONG [in] Contains the result of the ADS write command; see Ads Statuscodes [} 334]. ADS Return Code - see Ads Statuscodes [} 334]. 12.10.3.4 Ads Write Con The Ads Write Con method enables the receipt of an ADS write confirmation. The receiving module must provide this method. Ads Write Req [} 199] is the counterpart and must have been called beforehand. Syntax void Ads Write Con( Ams Addr& r Addr, ULONG invoke Id, ULONG n Result ); Return value void Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the responding ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. n Result ULONG [in] contains the result of the ADS write command; see Ads Statuscodes [} 334]. 12.10.4 Ads Read Write 12.10.4.1 Ads Read Write Req The Ads Read Write Req method enables an ADS read/write command to be sent for data transmission to and from an ADS device. The Ads Read Write Con [} 203] is called when the response is received. Syntax int Ads Read Write Req( Ams Addr& r Addr, ULONG invoke Id, ULONG index Group, ULONG index Offset, ULONG cb Read Length, ULONG cb Write Length, PVOID p Data ); Return value Type: int Error code - see Ads Statuscodes [} 334]. Twin CAT 3 Version: 1.18.0 201

## Page 202

Programming Reference Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. index Group ULONG [in] contains the index group number (32-bit, unsigned) of the requested ADS service. index Offset ULONG [in] contains the index offset number (32-bit, unsigned) of the requested ADS service. cb Read Length ULONG [in] contains the length in bytes of the data to be read (p Data). cb Write Length ULONG [in] contains the length in bytes of the data to be written (p Data). p Data PVOID [in] pointer to the data buffer in which the written data are located. 12.10.4.2 Ads Read Write Ind The Ads Read Write Ind method specifies an ADS read/write command to transfer data to an ADS device. The Ads Read Write Res [} 204] must be called in order to send the result. Syntax void Ads Read Write Ind( Ams Addr& r Addr, ULONG invoke Id, ULONG index Group, ULONG index Offset, ULONG cb Read Length, ULONG cb Write Length, PVOID p Data ); Return value void Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. index Group ULONG [in] contains the index group number (32-bit, unsigned) of the requested ADS service. index Offset ULONG [in] contains the index offset number (32-bit, unsigned) of the requested ADS service. cb Read Length ULONG [in] contains the length in bytes of the data to be read (p Data). cb Write Length ULONG [in] contains the length in bytes of the data to be written (p Data). p Data PVOID [in] pointer to the data buffer in which the written data are located. 12.10.4.3 Ads Read Write Res The Ads Read Write Res method enables the receipt of an ADS read/write confirmation. Ads Read Write Con [} 203] forms the counterpart and is subsequently called. Syntax int Ads Read Write Res( Ams Addr& r Addr, ULONG invoke Id, ULONG n Result, ULONG cb Length, PVOID p Data ); Return value Type: int ADS Return Code - see Ads Statuscodes [} 334]. 202 Version: 1.18.0 Twin CAT 3

## Page 203

Programming Reference Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the responding ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. n Result ULONG [in] contains the result of the ADS write command; see Ads Statuscodes [} 334]. cb Length ULONG [in] contains the length in bytes of the data read (p Data). p Data PVOID [in] pointer to the data buffer in which the data are located. 12.10.4.4 Ads Read Write Con The Ads Read Write Con method enables the receipt of an ADS read/write confirmation. The receiving module must provide this method. Ads Read Write Req [} 201] is the counterpart and must be called beforehand. Syntax void Ads Read Write Con( Ams Addr& r Addr, ULONG invoke Id, ULONG n Result, ULONG cb Length, PVOID p Data ); Return value void Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the responding ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. n Result ULONG [in] contains the result of the ADS write command; see Ads Statuscodes [} 334]. cb Length ULONG [in] contains the length in bytes of the data read (p Data). p Data PVOID [in] pointer to the data buffer in which the data are located. 12.10.5 Ads Read State 12.10.5.1 Ads Read State Req The Ads Read State Req method enables the transmission of an ADS state read command for reading the ADS and device state from an ADS server. When the response is received, Ads Read State Con [} 205] is called. Syntax int Ads Read State Req(Ams Addr& r Addr, ULONG invoke Id); Return value Type: int Error code - see Ads Statuscodes [} 334]. Twin CAT 3 Version: 1.18.0 203

## Page 204

Programming Reference Parameter Name Type Description r Addr Ams Addr [in] Structure with Net Id and port number of the ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. 12.10.5.2 Ads Read State Ind The Ads Read State Ind method displays an ADS state read command for reading the ADS state and the device state from an ADS device. The Ads Read State Res [} 204] must be called to send the result. Syntax void Ads Read State Ind( Ams Addr& r Addr, ULONG invoke Id ); Return value void Parameter Name Type Description r Addr Ams Addr [in] Structure with Net Id and port number of the ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. 12.10.5.3 Ads Read State Res The method Ads Write Res enables the sending of an ADS state read response. Ads Read State Con [} 205] forms the counterpart and is subsequently called. Syntax int Ads Read State Res( Ams Addr& r Addr, ULONG invoke Id, ULONG n Result, USHORT ads State, USHORT device State ); Return value Type: int Error code - see Ads Statuscodes [} 334]. Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the responding ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. n Result ULONG [in] contains the result of the ADS write command; see Ads Statuscodes [} 334]. ads State USHORT [in] contains the ADS state of the device. device State USHORT [in] contains the device state of the device. 204 Version: 1.18.0 Twin CAT 3

## Page 205

Programming Reference 12.10.5.4 Ads Read State Con The Ads Write Con method enables the receipt of an ADS state read confirmation. The receiving module must provide this method. Ads Read State Req [} 203] is the counterpart and must be called beforehand. Syntax void Ads Read State Con( Ams Addr& r Addr, ULONG invoke Id, ULONG n Result, USHORT ads State, USHORT device State ); Return value void Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the responding ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. n Result ULONG [in] contains the result of the ADS write command; see Ads Statuscodes [} 334]. ads State USHORT [in] contains the ADS state of the device. device State USHORT [in] contains the device state of the device. 12.10.6 Ads Write Control 12.10.6.1 Ads Write Control Req The Ads Write Control Req method can be used to send an ADS write control command to change the ADS and device state of an ADS server. Ads Write Control Con [} 206] is called when the response is received. Syntax int Ads Write Control Req( Ams Addr& r Addr, ULONG invoke Id, USHORT ads State, USHORT device State, ULONG cb Length, PVOID p Data ); Return value Type: int Error code - see Ads Statuscodes [} 334]. Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. ads State USHORT [in] new ADS state (see enum n Ads State in Ads.h). device State USHORT [in] new device state. cb Length ULONG [in] contains the length in bytes of the data (p Data). p Data PVOID [in] pointer to the data buffer in which the written data are located. Twin CAT 3 Version: 1.18.0 205

## Page 206

Programming Reference 12.10.6.2 Ads Write Control Ind The Ads Write Control Ind method can be used to send an ADS write control command to change the ADS and device state of an ADS device. The Ads Write Control Res [} 206] must be called to confirm the process. Syntax void Ads Write Control Ind( Ams Addr& r Addr, ULONG invoke Id, USHORT ads State, USHORT device State, ULONG cb Length, PVOID p Device Data ); Return value void Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. ads State USHORT [in] contains the index group number (32-bit, unsigned) of the requested ADS service. device State USHORT [in] contains the index offset number (32-bit, unsigned) of the requested ADS service. cb Length ULONG [in] contains the length in bytes of the data (p Data). p Data PVOID [in] pointer to the data buffer in which the written data are located. 12.10.6.3 Ads Write Control Res The Ads Write Control Res method enables the sending of an ADS write control response. Ads Write Control Con [} 206] forms the counterpart and is subsequently called. Syntax int Ads Write Control Res( Ams Addr& r Addr, ULONG invoke Id, ULONG n Result ); Return value Type: int ADS Return Code - see Ads Statuscodes [} 334]. Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the responding ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. n Result ULONG [in] contains the result of the ADS write command; see Ads Statuscodes [} 334]. 12.10.6.4 Ads Write Control Con The Ads Write Con method enables the receipt of an ADS write control confirmation. The receiving module must provide this method. Ads Write Control Req [} 205] is the counterpart and must be called beforehand. Syntax void Ads Write Control Con( Ams Addr& r Addr, ULONG invoke Id, ULONG n Result ); 206 Version: 1.18.0 Twin CAT 3

## Page 207

Programming Reference Return value void Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the responding ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. n Result ULONG [in] contains the result of the ADS write command; see Ads Statuscodes [} 334]. 12.10.7 Ads Add Device Notification 12.10.7.1 Ads Add Device Notification Req The Ads Add Device Notification Req method enables the sending an ADS add device notification command to add a device notification to an ADS device. Ads Add Device Notification Con [} 208] is called when the response is received. Syntax int Ads Add Device Notification Req( Ams Addr& r Addr, ULONG invoke Id, ULONG index Group, ULONG index Offset, Ads Notification Attrib note Attrib); Return value Type: int Error code - see Ads Statuscodes [} 334]. Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. index Group ULONG [in] contains the index group number (32-bit, unsigned) of the requested ADS service. index Offset ULONG [in] contains the index offset number (32-bit, unsigned) of the requested ADS service. note Attrib Ads Notification Attrib [in] contains the specification of the notification parameters (cb Length, Trans Mode, Max Delay). 12.10.7.2 Ads Add Device Notification Ind The Ads Add Device Notification Ind method should enable the sending of Ads Device Notification [} 210]. The Ads Add Device Notification Res [} 208] must be called to confirm the process. Syntax void Ads Add Device Notification Ind( Ams Addr& r Addr, ULONG invoke Id, ULONG index Group, ULONG index Offset, Ads Notification Attrib note Attrib ); Twin CAT 3 Version: 1.18.0 207

## Page 208

Programming Reference Return value void Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the responding ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. index Group ULONG [in] contains the index group number (32-bit, unsigned) of the requested ADS service. index Offset ULONG [in] contains the index offset number (32-bit, unsigned) of the requested ADS service. note Attrib Ads Notification Attrib [in] contains the specification of the notification parameters (cb Length, Trans Mode, Max Delay). 12.10.7.3 Ads Add Device Notification Res The Ads Add Device Notification Res method enables the sending of an ADS device add notification response. Ads Add Device Notification Con [} 208] forms the counterpart and is subsequently called. Syntax void Ads Add Device Notification Con( Ams Addr& r Addr, ULONG invoke Id, ULONG n Result, ULONG handle ); Return value void Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the responding ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. n Result ULONG [in] contains the result of the ADS write command; see Ads Statuscodes. Handle ULONG [in] handle to generated device notification. 12.10.7.4 Ads Add Device Notification Con The Ads Add Device Notification Con method confirms an ADS device addition notification request. Ads Add Device Notification Req [} 207] forms the counterpart and must be called beforehand. Syntax void Ads Add Device Notification Con( Ams Addr& r Addr, ULONG invoke Id, ULONG n Result, ULONG handle ); Return value void 208 Version: 1.18.0 Twin CAT 3

## Page 209

Programming Reference Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the responding ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. n Result ULONG [in] contains the result of the ADS write command; see Ads Statuscodes. Handle ULONG [in] handle to generated device notification. 12.10.8 Ads Del Device Notification 12.10.8.1 Ads Del Device Notification Req The Ads Del Device Notification Req method enables the sending of an ADS device delete notification command to remove a device notification from an ADS device. The Ads Del Device Notification Con [} 210] is called when the response is received. Syntax int Ads Del Device Notification Req( Ams Addr& r Addr, ULONG invoke Id, ULONG h Notification ); Return value Type: int Error code - see Ads Statuscodes [} 334]. Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. h Notification ULONG [in] contains the handle of the notification to be removed. 12.10.8.2 Ads Del Device Notification Ind The Ads Add Device Notification Con method enables the receipt of an ADS device deletion notification confirmation. The receiving module must provide this method. The Ads Del Device Notification Res [} 210] must be called to confirm the process. Syntax void Ads Del Device Notification Con( Ams Addr& r Addr, ULONG invoke Id, ULONG n Result ); Return value void Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the responding ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. n Result ULONG [in] contains the result of the ADS write command; see Ads Statuscodes [} 334]. Twin CAT 3 Version: 1.18.0 209

## Page 210

Programming Reference 12.10.8.3 Ads Del Device Notification Res The Ads Add Device Notification Res method enables the receipt of an ADS device deletion notification. Ads Del Device Notification Con [} 210] forms the counterpart and is subsequently called. Syntax int Ads Del Device Notification Res( Ams Addr& r Addr, ULONG invoke Id, ULONG n Result ); Return value Int Returns the result of the ADS command, see Ads Statuscodes [} 334]. Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the responding ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. n Result ULONG [in] contains the result of the ADS command; see Ads Statuscodes [} 334]. 12.10.8.4 Ads Del Device Notification Con The Ads Add Device Notification Con method enables the receipt of an ADS device deletion notification confirmation. The receiving module must provide this method. Ads Del Device Notification Req [} 209] forms the counterpart and must be called beforehand. Syntax void Ads Del Device Notification Con( Ams Addr& r Addr, ULONG invoke Id, ULONG n Result ); Return value void Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the responding ADS server. invoke Id ULONG [in] handle of the transmitted command; the Invoke Id is specified by the source device and serves to identify the commands. n Result ULONG [in] contains the result of the ADS write command; see Ads Statuscodes [} 334]. 12.10.9 Ads Device Notification 12.10.9.1 Ads Device Notification Req The Ads Add Device Notification Req method enables the sending of an ADS device notification to inform an ADS device. The Ads Device Notification Ind [} 211] is called on the counterpart. Syntax int Ads Device Notification Req( Ams Addr& r Addr, ULONG invoke Id, ULONG cb Length, Ads Notification Stream notifications[] ); 210 Version: 1.18.0 Twin CAT 3

## Page 211

Programming Reference Return value Type: int ADS Return Code - see Ads Statuscodes [} 334]. Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. n Result ULONG [in] contains the result of the device notification display. notifications[] Ads Notification Stream [in] contains information about the device notification(s). 12.10.9.2 Ads Device Notification Ind The Ads Device Notification Ind method enables the receipt from an ADS device notification display. The receiving module must provide this method. Receipt is not acknowledged. Ads Device Notification Con [} 211] must be called on the Ads Device Notification Req [} 210] side to check the transmission. Syntax void Ads Device Notification Ind( Ams Addr& r Addr, ULONG invoke Id, ULONG cb Length, Ads Notification Stream* p Notifications ); Return value void Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the responding ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. cb Length ULONG [in] contains the length of p Notifications. p Notifications Ads Notification Stream* [in] Pointer to the notifications. This array consists of Ads Stamp Header with notification handle and data via Ads Notification Sample. 12.10.9.3 Ads Device Notification Con The sender can use the Ads Add Device Notification Con method to check the transmission of an ADS device notification. Ads Device Notification Req [} 210] must be called beforehand. Syntax void Ads Device Notification Con( Ams Addr& r Addr, ULONG invoke Id, ULONG n Result ); Return value void Twin CAT 3 Version: 1.18.0 211

## Page 212

Programming Reference Parameter Name Type Description r Addr Ams Addr& [in] Structure with Net Id and port number of the ADS server. invoke Id ULONG [in] Handle of the command, which was sent. The Invoke Id is specified by the source device and is used for the identification of the commands. n Result ULONG [in] contains the result of the device notification display. 12.11 Mathematical Functions Twin CAT has implemented its own mathematical functions because the math.h implementation from Microsoft is not real-time capable. These functions are declared in Tc Math.h, a part of Twin CAT SDK. For x64 the operations are executed via SSE; on x86 systems the FPU is used. Twin CAT 3.1 4018 or earlier Twin CAT 3.1 4018 provides an fpu87.h with the same methods. This continues to exist and redirects to Tc Math.h. 212 Version: 1.18.0 Twin CAT 3

## Page 213

Programming Reference Methods provided Name Description sqr_ Calculates the square. sqrt_ Calculates the square root. sin_ Calculates the sine. cos_ Calculates the cosine. tan_ Calculates the tangent. atan_ Calculates the angle whose tangent is the specified value. atan2_ Calculates the angle whose tangent is the quotient of two specified values. asin_ Calculates the angle whose sine is the specified value. acos_ Calculates the angle whose cosine is the specified value. exp_ Calculates e to the specified power. log_ Calculates the logarithm of a specified value. log10_ Calculates the base 10 logarithm of a specified value. fabs_ Calculates the absolute value. fmod_ Calculates the remainder. ceil_ Calculates the smallest integer that is greater than or equal to the specified number. floor_ Calculates the largest integer that is smaller than or equal to the specified number. pow_ Calculates a specified number to the specified power. sincos_ Calculates the sine and cosine of x. fmodabs_ Calculates the absolute value that meets the Euclidean definition of the mod operation. round_ Calculates a value and rounds to the nearest integer. round_digits_ Calculates a rounded value with a specified number of decimal places. coubic_ Calculates the cubic value. ldexp_ Calculates a real number (double) from mantissa and exponent. ldexpf_ Calculates a real number (float) from mantissa and exponent. sinh_ Calculates the hyperbolic sine of the specified angle. cosh_ Calculates the hyperbolic cosine of the specified angle. tanh_ Calculates the hyperbolic tangent of the specified angle. finite_ Determines whether the specified value is finite. isnan_ Determines whether the specified value is not a number (NAN). rands_ Calculates a pseudo random number between 0 and 32767. The parameter holdrand is set randomly and changed with every call. • The functions have the extension "_" (underscore), which identifies them as Twin CAT implementation. • Most are analog math.h, designed by Microsoft, only for the data type double. See also MSDN documentation of analog math.h functions. Twin CAT 3 Version: 1.18.0 213

## Page 214

Programming Reference 12.12 Time Functions Twin CAT provides functions for time conversion, they are declared in Tc Time Conversion.h, which is part of Twin CAT SDK. Methods provided Name Description Tc Day Of Week(WORD day, WORD month, WORD year) Determines the day of the week. Input: day (0..30) and month (1..12) Return: 0 is Sunday, 6 is Saturday Tc Is Leap Year Determines whether the given year is a leap year. Tc Days In Year Determines the number of days in a given year. Tc Days In Month Determines the number of days in a given month. Tc System Time To File Time(const SYSTEMTIME* Converts the given system time into a file time. lp System Time, FILETIME *lp File Time); Tc File Time To System Time(const FILETIME *lp File Time, Converts the given file time into a system time. SYSTEMTIME* lp System Time); Tc System Time To File Time(const SYSTEMTIME* Converts the given system time into a file time lp System Time, ULONGLONG& ul64File Time); (ULONGLONG format). Tc File Time To System Time(const ULONGLONG& Converts the given file time (ULONGLONG ul64File Time, SYSTEMTIME* lp System Time); format) into a system time. Tc Is ISO8601Time Format(PCCH s DT) Checks whether a PCCH follows the time format ISO8601. Tc Decode Date Time(PCCH s DT) Converts a ULONG as Date Time from the PCCH into ISO8601 format. Tc Decode Dc Time(PCCH s DT) Converts a LONGLONG as Dc Time from the PCCH into ISO8601 format. Tc Decode File Time(PCCH s FT) Converts a LONGLONG as File Time from the PCCH into ISO8601 format. Tc Encode Date Time(ULONG value, PCHAR p, UINT len) Converts a string (p, len) into ISO8601 format on the basis of the ULONG value in Date Time format. Minimum length for p is 24 bytes. Tc Encode Dc Time(LONGLONG value, PCHAR p, UINT Converts a string (p, len) into ISO8601 format on len) the basis of the LONGLONG in Dc Time format. Minimum length for p is 32 bytes. Tc Encode File Time(LONGLONG value, PCHAR p, UINT Converts a string (p, len) into ISO8601 format on len) the basis of the LONGLONG in File Time format. Minimum length for p is 32 bytes. Tc Dc Time To File Time(LONGLONG dc Time) Converts a LONGLONG as File Time from the LONGLONG into Dc Time. Tc File Time To Dc Time(LONGLONG file Time); Converts a LONGLONG as Dc Time from the LONGLONG into File Time. Tc Dc Time To Date Time(LONGLONG dc Time) Converts a ULONG as Date Time from the LONGLONG into Dc Time. Tc Date Time To Dc Time(ULONG date Time) Converts a ULONG as Dc Time from the LONGLONG into Date Time. Tc File Time To Date Time(LONGLONG file Time) Converts a ULONG as Date Time from the LONGLONG into File Time. Tc Date Time To File Time(ULONG date Time) Converts a LONGLONG as File Time from the ULONG into Date Time. • Further information on different time sources is described here: https://infosys.beckhoff.com/content/1031/ethercatsystem/2469114379.html 214 Version: 1.18.0 Twin CAT 3

## Page 215

Programming Reference 12.13 STL / Containers Twin CAT 3 C++ supports STL with regard to • List • Map • Set • Stack • String • Vector • WString • Algorithms (such as binary_search) ◦ See %TWINCAT3DIR%\Sdk\Include\Stl\Stl\algorithm for a specific list of supported algorithms. Restrictions • Class templates do not exist for all data types. • Some header files should not be used directly. More detailed documentation on memory management, which uses STL, can be found in chapter Memory allocation [} 154]. 12.14 Error messages - understanding In Twin CAT you receive very detailed information about errors that occur. For instance, this error message means: • The error occurred during the transition from SAFE OP to OP. • The affected object is "Untitled1_Obj1" (CModule1). • The error code 1821 / 0x71d indicates that the object ID is invalid. Therefore, you should examine the method "Set Obj State SP()", which is responsible for this transition, in more detail. In the case of the generated standard code, you can see that the addition of the module takes place there. The reason for this error is that no task has been assigned to this module, so the module cannot have a task in which it is executed. Twin CAT 3 Version: 1.18.0 215

## Page 216

Programming Reference 12.15 Module messages for the Engineering (logging / tracing) Overview Twin CAT 3 C++ offers the option of sending messages from a C++ module to the Twin CAT 3 Engineering as tracing or logging. Syntax The syntax for recording messages is as follows: m_Trace. Log(TLEVEL, FNMACRO"A message", …); With these properties: • TLEVEL categorizes a message into one of five levels. The recording of the higher level always includes the recording of the lower levels: i.e. a message classified at level "tl Warning" will occur with level "tl Always", "tl Error" and "tl Warning" - it will NOT record the "tl Info" and "tl Verbose" messages. Level 0 tl Always Level 1 tl Error Level 2 tl Warning Level 3 tl Info Level 4 tl Verbose • FNMACRO can be used to place the function name before the message to be printed ◦ FENTERA: Used when entering a function; prints the function name followed by ">>>". 216 Version: 1.18.0 Twin CAT 3

## Page 217

Programming Reference ◦ FNAMEA: Used within a function; prints the function name. ◦ FLEAVEA: Used when exiting a function; prints the function name followed by "<<<". • The %q format specifier is used to output pointers and other variables of platform-specific size. Sample HRESULT CModule1::Cycle Update(ITc Task* ip Task, ITc Unknown* ip Caller, ULONG_PTR context) { HRESULT hr = S_OK; // Sample to showcase trace logs ULONGLONG cnt = 0; if (SUCCEEDED(ip Task->Get Cycle Counter(&cnt))) { if (cnt%500 == 0) m_Trace. Log(tl Always, FENTERA "Level tl Always: cycle= %llu", cnt); if (cnt%510 == 0) m_Trace. Log(tl Error, FENTERA "Level tl Error: cycle=%llu", cnt); if (cnt%520 == 0) m_Trace. Log(tl Warning, FENTERA "Level tl Warning: cycle=%lld", cnt); if (cnt%530 == 0) m_Trace. Log(tl Info, FENTERA "Level tl Info: cycle=%llu", cnt); if (cnt%540 == 0) m_Trace. Log(tl Verbose, FENTERA "Level tl Verbose: cycle=%llu", cnt); } // TODO: Replace the sample with your cyclic code m_counter++; m_Outputs. Value = m_counter; return hr; } Use tracking level The tracking level can be preconfigured at the level of the module instance. 1. Navigate to the instance of the module in the solution tree. 2. Select the Parameter (Init) tab on the right. 3. Make sure that you activate Show Hidden Parameter. 4. Select the tracking level. Twin CAT 3 Version: 1.18.0 217

## Page 218

Programming Reference 5. To test everything, select the highest level tl Verbose. Alternatively, you can change the tracking level at runtime by going to the instance, selecting a level at Value for Trace Level Max parameters, right-clicking in front of the first column, and selecting Online Write. Filter message categories Visual Studio Error List allows you to filter entries by category. The three categories Errors, Warnings and Messages can be enabled or disabled independently by simply switching the keys. In this screenshot only warnings are enabled - errors and messages are disabled: 218 Version: 1.18.0 Twin CAT 3

## Page 219

Programming Reference In this screenshot, only messages are enabled - errors and warnings, on the other hand, are disabled for the display: Twin CAT 3 Version: 1.18.0 219

## Page 220

How to...? 13 How to...? The following section contains a set of frequently asked questions about general programming samples and the handling of Twin CAT C++ modules. 13.1 Using the Automation Interface The Automation Interface can be used for C++ projects. This includes creating projects [} 87] and using the wizard for creating module classes [} 88]. In addition, the project properties can be set and the TMC Code Generator and the publishing of modules called. The corresponding documentation [} 341] is part of the Automation Interface. Irrespective of the programming language, access to and creation and handling of Tc COM modules [} 344] may be relevant. From there, common System Manager tasks such as linking of variables can be executed. 13.2 Windows 10 as target system up to Twin CAT 3.1 Build 4022.2 For Windows 10 target systems the transferred files cannot be overwritten; they have to be renamed first. Up to Twin CAT 3.1 Build 4022.2, the Rename Destination option must be enabled for this purpose in the TMC Editor deployment [} 131]. In later versions this is done implicitly when the target system uses Windows 10 as operating system. 13.3 Publishing modules on the command line By means of the following call, the module publishing process in the Twin CAT Engineering (XAE) can also be initiated from the command line: msbuild Cpp Project.vcxproj /t:Tc Publish TMX The Cpp Project.vcxproj parameter must be adapted according to the existing project file. The output is done into the repository under C:\Program Data\Beckhoff\Twin CAT\3.1\Repository (Twin CAT 3.1 Build 4024: C:\Twin CAT\3.1\Repository). 13.4 Clone Runtime data can be transferred from one machine to another via file copy if both machines are from the same platform and are connected with equivalent hardware equipment. The following steps describe a simple procedure for transferring a binary configuration from one machine (“source”) to another (“target”). 1. Purge the boot folder on the source machine. ð < TC3.1.4026.0: C:\Twin CAT\3.1\Boot ð >=TC3.1.4026.0: C:\Program Data\Beckhoff\Twin CAT\3.1\Boot 2. Create (or enable) the module on the source machine. 3. Transfer the boot folder from the source to the target machine. This folder also contains the repository which contains the required TMX files. The folder is located at the following location on both the source and target machines. ð < TC3.1.4026.0: C:\Twin CAT\3.1\Boot ð >=TC3.1.4026.0: C:\Program Data\Beckhoff\Twin CAT\3.1\Boot 4. For Twin CAT driver projects (.sys): Transfer the driver MYDRIVER.sys and if necessary also the PDB file. 220 Version: 1.18.0 Twin CAT 3

## Page 221

How to...? ð < TC3.1.4026.0: C:\Twin CAT\3.1\Driver\Auto Install\MYDRIVER.sys ð >=TC3.1.4026.0: C:\Program Data\Beckhoff\Twin CAT\3.1\Driver\Auto Install\MYDRIVER.sys 5. For Twin CAT driver projects (.sys) and if the drivers are new on a machine: Twin CAT must perform a registration once. Switch Twin CAT to Run mode via Sys Tray (right click -> System -> Start/Restart). Alternatively, this call can be used (replace “%1” as driver name): ð < TC3.1.4026.0: sc create %1 bin Path= c:\Twin CAT\3.1\Driver\Auto Install\%1.sys type= kernel start= auto group= "file system" Display Name= %1 error= normal ð >=TC3.1.4026.0: sc create %1 bin Path= C: \Program Data\Beckhoff\Twin CAT\3.1\Driver\Auto Install\%1.sys type= kernel start= auto group= "file system" Display Name= %1 error= normal ð You can now start the target machine. Handling licenses Note that licenses cannot be transferred in this way. Please use preinstalled licenses, volume licenses, or other methods for providing licenses. 13.5 Access Variables via ADS Variables of C++ modules can be reached via ADS if the variables are marked in the TMC Editor as "Create Symbol": The name of the variable for access by ADS is derived from the name of the instance. For the Trace Level Max parameter it could be: Untitled1_Obj1 (CModule1). Trace Level Max 13.6 Tc Call After Output Update for C++ modules Comparable with the PLC attribute Tc Call After Output Update, C++ modules can be called following the output update. The ITc Post Cyclic [} 186] interface is used in the same way as the ITc Cyclic [} 166] interface. 13.7 Order determination of the execution in a task Different module instances can be assigned to a task, so the user needs a mechanism to determine the order of execution in the task. It is configured under Sort Order in the context [} 135] of the Twin CAT Module Instance Configurator [} 133]. Twin CAT 3 Version: 1.18.0 221

## Page 222

How to...? See Sample26: Order of execution in a task [} 309], how this is to be implemented. 13.8 Setting version/vendor information Windows offers a mechanism to query vendor and version resources that are defined in the course of a .rc file for the compilation time. Windows These are accessible, for example, via the Details tab of each properties file. 222 Version: 1.18.0 Twin CAT 3

## Page 223

How to...? Twin CAT/BSD This information is not available in the files. Twin CAT offers this behavior via the familiar Windows mechanisms of .rc files, which are generated in the course of the Twin CAT C++ project creation. Edit the .rc file in the Source Files folder with the resource editor in order to define these properties: 13.9 Renaming Twin CAT C++ projects The automated renaming of Twin CAT C++ projects is not possible. At this point instructions will be given on manually renaming a project. In summary, one can say that the C++ project will be renamed together with the corresponding files. ü A project, "Old Project", exists and is to be renamed "New Project". 1. If Tc COM instances exist in the project and are to be retained along with their links, first move them by drag & drop out of the project into System->Tc COM Objects. Twin CAT 3 Version: 1.18.0 223

## Page 224

How to...? 2. Remove the old project from the Twin CAT Solution using Remove. 3. Compilations of the "Old Project" can be deleted. To do this, delete the corresponding .sys/.pdb files in "_Deployment". Any existing .aps file can also be deleted. 4. Rename the C++ project directory and the project files (.vcxproj, .vcxproj.filters). If version management is in use, this renaming must be carried out via the version management system. 5. If a .vcvproj.user file exists, check the contents; this is where user settings are stored. Also rename this file if necessary. 6. Open the Twin CAT Solution. Re-link the renamed project to the C++ node using Add existing item: navigate to the renamed subdirectory and select the .vcxproj file there. 7. Rename the Class Factory, services and interfaces as well as header/source code files to the new project name. In addition, rename the TMC file and the corresponding files in the project folders "Twin CAT RT Files" and "Twin CAT UM Files". This renaming should also be mapped in the version management system; if the version management system is not integrated in Visual Studio, this step must also be carried out in the version management system. Replace all occurrences in the source code (case-sensitive): "OLDPROJECT" becomes "NEWPROJECT" and "Old Project" becomes "New Project". Use the Find and Replace dialog in Visual Studio for this; note that the "New Project Project" in the Solution Explorer has to be selected. 224 Version: 1.18.0 Twin CAT 3

## Page 225

How to...? ð NOTICE Incorrect source code The simple renaming of all occurrences of the character string may result in incorrect source code, for example if the project name is used within a method name. • If such occurrences are possible, carry out the renaming individually (Replace instead of Replace All). How to build the project: Twin CAT 3 Version: 1.18.0 225

## Page 226

How to...? 1. A) If instances from the project should exist, update them. To do this, right-click on the instance, select TTMI/TMC File->Reload TMI/TMC File… and select the renamed new TMC file. B) Alternatively, carry this out via System->Tc COM Objects and the Project Objects tab by right- clicking on the OTCID. 2. Move System->Tc COM into the project. 3. Clean up the target system(s). For Twin CAT C++ driver: Delete the files "Old Project.sys/.pdb" in C:\Twin CAT\3.1\Driver\Auto Install. For Twin CAT Versioned C++ projects: The repository can be cleaned up below C: \Twin CAT\3.1\Repository 4. Test the project. 13.10 Delete Module A Twin CAT C++ module can be deleted from a C++ project with the help of the TMC Editor. 1. Right-click on the module (in this case CModule2) 2. Select Delete. 226 Version: 1.18.0 Twin CAT 3

## Page 227

How to...? 3. Confirm the deletion via TMC. 4. Note that the .cpp and .h files are retained – delete them manually if necessary. Delete other components concerned (e.g. header files, structures). See Compiler error messages for more information. 13.11 Add revision control and Online Change subsequently An existing C++ driver project with C++ Tc COM modules can subsequently be migrated to a versioned C++ project. The changeover takes place in several steps: 1. Click on C++ Project Twin CAT Upgrade C+ Project in the context menu, this is the most convenient option. Alternatively, you can find manual instructions here: Convert C++ project to a versioned C++ project [} 227]. 2. You can then add the online change capability; this must be done manually: Make C++ module class online change-capable [} 230]. Alternatively, it may be useful to create a new versioned C++ project yourself and transfer the differences. 13.11.1 C++ Project -> Revision control These instructions describe how to add subsequently a revision control to a Twin CAT C++ project. The code to be changed is stored in bold in the source code. ü C++ project. For the sample "Untitled1" is used as C++ project name. In addition, an empty, new project with a versioned C++ project is to be created. This serves as a copy template. 1. Open the file Untitled1.vcxproj in an editor. 2. Make the following addition: <Property Group Label="Globals"> <Project Guid>{….}</Project Guid> <Root Namespace>Untitled1</Root Namespace> <Keyword>Win32Proj</Keyword> <Automatic Retarget Platform Version>true</Automatic Retarget Platform Version> </Property Group> <Property Group Label="Tc General"> <Tc General Use Tmx>true</Tc General Use Tmx> </Property Group> <Import Project="$(VCTargets Path)\Microsoft. Cpp. Default.props" /> 3. Transfer the Untitled1.rc and Untitled1W32.rc files from the new project to the project to be migrated, overwriting the Untitled1.rc file. 4. Open the project. 5. Under Twin CAT UM Files -> Context menu / Add Existing Items select the file Unititled1W32.rc and add it to the project. Twin CAT 3 Version: 1.18.0 227

## Page 228

How to...? 6. This file only needs to be built for Twin CAT UM platforms, so it should otherwise be excluded for the build process. This is done via right-click and properties: 7. Open the TMC Editor. 8. Set the name of the class factory and the version to "0.0.0.1". 228 Version: 1.18.0 Twin CAT 3

## Page 229

How to...? 9. Under Deployment, delete all entries. 10. Change in header Modul1.h DECLARE_IPERSIST_LIB(): public: DECLARE_IUNKNOWN() DECLARE_IPERSIST_LIB() DECLARE_ITCOMOBJECT_LOCKOP() 11. Add Modul1.cpp to the source code: #pragma hdrstop #include "Module1.h" #include "Untitled1Version.h" #ifdef _DEBUG 12. Add Modul1.cpp to the source code: END_INTERFACE_MAP() IMPLEMENT_IPERSIST_LIB(CModule1, VID_Untitled1, CID_Untitled1CModule1) IMPLEMENT_ITCOMOBJECT(CModule1) IMPLEMENT_ITCOMOBJECT_SETSTATE_LOCKOP2(CModule1) 13. Call the code generator. 14. Change in the file Untitled1Classfactory.cpp: CUntitled1Class Factory::CUntitled1Class Factory() : CObj Class Factory() { Tc Dbg Unit Set Image Name(TCDBG_UNIT_IMAGE_NAME_TMX(SRVNAME_UNTITLED1)); #if defined(TCDBG_UNIT_VERSION) Tc Dbg Unit Set Version(TCDBG_UNIT_VERSION(Untitled1)); #endif //defined(TCDBG_UNIT_VERSION) } Twin CAT 3 Version: 1.18.0 229

## Page 230

How to...? 15. Change the signing in the project properties in the tab Tc Sign [} 148]. To do this, switch SHA1 signing off and Twin CAT signing on; provide Twin CAT user certificate and password at the same time. 16. Trigger the Rebuild of the project. ð The result is a C++ project that supports revision control. If a module is to be made Online Change capable, this can be achieved by the following instructions [} 230]. 13.11.2 C++ Module -> Online Change These instructions describe how to subsequently make a module Online Change-capable in a versioned Twin CAT C++ project. ü Versioned C++ project with C++ module, which is not yet Online Change capable. For this sample, a module "Module1" is assumed. In addition, an empty, new project can be created with an Online Change-capable module, from which the changes can be more easily adopted. 1. Open the project and the TMC Editor. 2. Set the Auto generate on save option for the module so that the Class ID is changed automatically. 230 Version: 1.18.0 Twin CAT 3

## Page 231

How to...? 3. Under Implemented Interfaces, delete the interfaces ITc ADI and ITc Watchsource and add ITCom Online Change. 4. Delete the Cyclic Caller under Interface Pointer. Twin CAT 3 Version: 1.18.0 231

## Page 232

How to...? 5. Under Parameters some predefined parameters have to be added. Press + under Parameters and select Predefined to select the predefined Parameter IDs: You create the following parameters with the given names, in each case without code generation: "PID_Library ID" with the name "Library ID" "PID_Module Cls Id" with the name "Module Cls Id" "PID_Ctx_Task Sort Orders with the name "Sort Orders" "PID_Ctx_Task Oids" with the name "Contexts" "IOFFS_Tc Io Data Area Size" with the name "Data Areas" ð The result in the overview: 232 Version: 1.18.0 Twin CAT 3

## Page 233

How to...? 6. Start the code generation. 7. Some changes must be made in the header of the module "Module1.h". First, delete the declarations of the interfaces that are no longer required and the corresponding maps in two places. class CModule1 : public ITCom Object , public ITc ADI , public ITc Watch Source ///<Auto Generated Content id="Inheritance List"> , public ITc Cyclic ///</Auto Generated Content> { public: DECLARE_IUNKNOWN() DECLARE_IPERSIST(CID_Untitled1CModule1) DECLARE_ITCOMOBJECT_LOCKOP() DECLARE_ITCADI() DECLARE_ITCWATCHSOURCE() DECLARE_OBJPARAWATCH_MAP() DECLARE_OBJDATAAREA_MAP() 8. Create a new member variable in the header: ///</Auto Generated Content> ITc ADIPtr m_sp ADI; // TODO: Custom variable 9. Some changes need to be made to the source code of the module "Module1.cpp". First, delete the implementations of the interfaces that are no longer required in two places. BEGIN_INTERFACE_MAP(CModule1) INTERFACE_ENTRY_ITCOMOBJECT() INTERFACE_ENTRY(IID_ITc ADI, ITc ADI) INTERFACE_ENTRY(IID_ITc Watch Source, ITc Watch Source) ///<Auto Generated Content id="Interface Map"> INTERFACE_ENTRY(IID_ITc Cyclic, ITc Cyclic) ///</Auto Generated Content> END_INTERFACE_MAP() IMPLEMENT_ITCOMOBJECT(CModule1) IMPLEMENT_ITCOMOBJECT_SETSTATE_LOCKOP2(CModule1) IMPLEMENT_ITCADI(CModule1) IMPLEMENT_ITCWATCHSOURCE(CModule1) 10. Delete the implementation of the maps belonging to the deleted interfaces: BEGIN_SETOBJPARA_MAP(CModule1) SETOBJPARA_DATAAREA_MAP() ///<Auto Generated Content id="Set Object Parameter Map"> SETOBJPARA_VALUE(PID_Tc Trace Level, m_Trace Level Max) SETOBJPARA_VALUE(PID_Module1Parameter, m_Parameter) SETOBJPARA_ITFPTR(PID_Ctx_Task Oid, m_sp Cyclic Caller) ///</Auto Generated Content> END_SETOBJPARA_MAP() /////////////////////////////////////////////////////////////////////////////// // Get parameters of CModule1 BEGIN_GETOBJPARA_MAP(CModule1) GETOBJPARA_DATAAREA_MAP() ///<Auto Generated Content id="Get Object Parameter Map"> GETOBJPARA_VALUE(PID_Tc Trace Level, m_Trace Level Max) GETOBJPARA_VALUE(PID_Module1Parameter, m_Parameter) GETOBJPARA_ITFPTR(PID_Ctx_Task Oid, m_sp Cyclic Caller) ///</Auto Generated Content> END_GETOBJPARA_MAP() /////////////////////////////////////////////////////////////////////////////// // Get watch entries of CModule1 BEGIN_OBJPARAWATCH_MAP(CModule1) OBJPARAWATCH_DATAAREA_MAP() ///<Auto Generated Content id="Object Parameter Watch Map"> ///</Auto Generated Content> END_OBJPARAWATCH_MAP() /////////////////////////////////////////////////////////////////////////////// Twin CAT 3 Version: 1.18.0 233

## Page 234

How to...? // Get data area members of CModule1 BEGIN_OBJDATAAREA_MAP(CModule1) ///<Auto Generated Content id="Object Data Area Map"> OBJDATAAREA_VALUE(ADI_Module1Inputs, m_Inputs) OBJDATAAREA_VALUE(ADI_Module1Outputs, m_Outputs) ///</Auto Generated Content> END_OBJDATAAREA_MAP() 11. The m_sp API pointer must be obtained in the transition P->S in the state machine: HRESULT CModule1::Set Obj State PS(PTCom Init Data Hdr p Init Data) { m_Trace. Log(tl Verbose, FENTERA); HRESULT hr = S_OK; IMPLEMENT_ITCOMOBJECT_EVALUATE_INITDATA(p Init Data); // query Tc COM object server for ITc ADI interface with own object id, // which retrieves a reference to the TMC module instance handler m_sp ADI. Set OID(m_obj Id); hr = FAILED(hr) ? hr : m_sp Srv->Tc Query Smart Object Interface(m_sp ADI); // TODO: Add initialization code 12. Add the following in the state machine in the transition S->O, the calls to Add Module To Caller or Remove Module From Caller are omitted. HRESULT hr = S_OK; // Retrieve pointer to data areas via ITc ADI interface from TMC module handler ///<Auto Generated Content id="Data Area Pointer Initialization"> ///</Auto Generated Content> // TODO: Add any additional initialization // Cleanup if transition failed at some stage if ( FAILED(hr) ) { Set Obj State OS(); } 13. Add the following in the state machine in the transition O->S, the call Remove Module From Caller is omitted: HRESULT hr = S_OK; // Release pointer to data areas via ITc ADI interface from TMC module handler ///<Auto Generated Content id="Data Area Pointer Release"> ///</Auto Generated Content> // TODO: Add any additional deinitialization 14. The Add Module To Caller and Remove Module From Caller methods are not required and can be deleted. 15. Change the accesses to the Data Areas: HRESULT CModule1::Cycle Update(ITc Task* ip Task, ITc Unknown* ip Caller, ULONG_PTR context) { HRESULT hr = S_OK; // TODO: Replace the sample with your cyclic code m_Counter+=m_p Inputs->Value; m_p Outputs->Value=m_Counter; return hr; } 16. Implement the ITc Online Change. The functions are created by the previous code generation, but must not return NOTIMPL. ///<Auto Generated Content id="Implementation Of_ITCom Online Change"> /////////////////////////////////////////////////////////////////////////////// // Prepare Online Change is called after this instance has been set to PREOP in non RT context. // Parameter ip Old Obj refers to the currently active instance which is still in OP. // Retrieve parameter values that are not changed during OP via ip Old Obj here. // // Parameter p Old Info refers to instance data which includes the library Id and // the module class id. This information can be used to implement switch from one // specific version to another. HRESULT CModule1::Prepare Online Change(ITCom Object* ip Old Obj, Tmc Inst Data* p Old Info) { HRESULT hr = S_OK; ULONG n Data = sizeof(m_Parameter); PVOID p Data = &m_Parameter; ip Old Obj->Tc Get Obj Para(PID_Module1Parameter, n Data, p Data); return hr; } /////////////////////////////////////////////////////////////////////////////// // Perform Online Change is called after this instance has been set to SAFEOP in RT context. // Parameter ip Old Obj refers to old instance which is now in SAFEOP. // Allows to retrieve data after the last cyclic update of the old instance and 234 Version: 1.18.0 Twin CAT 3

## Page 235

How to...? // before the first cyclic update of this instance. HRESULT CModule1::Perform Online Change(ITCom Object* ip Old Obj, Tmc Inst Data* p Old Info) { HRESULT hr = S_OK; ULONG n Data = sizeof(m_Counter); PVOID p Data = &m_Counter; ip Old Obj->Tc Get Obj Para(PID_Module1Counter, n Data, p Data); return hr; } ///</Auto Generated Content> 17. Start the TMC Code Generator again to generate the code for the initialization of the data area pointers. 13.12 Initialization of TMC-member variables All member variables of a Tc COM module must be initialized. The TMC Code Generator supports this with: ///<Auto Generated Content id="Member Initialization"> The TMC Code Generator replaces this with: ///<Auto Generated Content id="Member Initialization"> m_Trace Level Max = tl Always; memset(&m_Parameter, 0, sizeof(m_Parameter)); memset(&m_Inputs, 0, sizeof(m_Inputs)); memset(&m_Outputs, 0, sizeof(m_Outputs)); ///</Auto Generated Content> The projects generated with the Twin CAT C++ Wizard prior to Twin CAT 3.1 Build 4018 do not use this property, but can easily be adapted by inserting this line in the corresponding code (e.g. Constructor): ///<Auto Generated Content id="Member Initialization"> 13.13 Using PLC strings as method parameters To transfer a character string from PLC to C++ as a method parameter, use a pointer with length information when declaring the method in TMC: Such a method can be called by means of implementing a method within the wrapper function block. The reason is the different handling of method parameters in the two worlds: • PLC: Uses the call by value for STRING(nn) data types. • Twin CAT C++ (TMC): Uses the call by reference. Twin CAT 3 Version: 1.18.0 235

## Page 236

How to...? 13.14 Third Party Libraries C/C++ code existing in Kernel mode cannot be linked with or execute libraries from third parties that were developed for execution in Usermode. There is therefore no possibility to use any DLL directly in Twin CAT C++ modules. The connection of the Twin CAT 3 real-time environment can be realized via ADS communication instead. You can implement a Usermode application that makes use of the third-party library that provides Twin CAT functions via ADS. This action of an ADS component in Usermode can take place both as a client (i.e. the DLL transmits data to the Twin CAT real-time if necessary) and as a server (i.e. the Twin CAT real-time fetches data from the Usermode if necessary). Such an ADS component in Usermode can also be used in the same way from the PLC. In addition, ADS can communicate beyond device limits. The following samples illustrate the use of ADS in C++ modules: Sample03: C++ as ADS server [} 248] Sample07: Receiving ADS Notifications [} 263] Sample08: provision of ADS-RPC [} 264] 13.15 Linking via TMC editor (Tc Link To) Similar to the PLC, in Twin CAT C++ a link to the hardware, for example, can be predefined at the time of encoding. This is done in the TMC editor at the symbol to be linked. A Tc Link To property with the value of the target is specified. The screenshot below illustrates this: 236 Version: 1.18.0 Twin CAT 3

## Page 237

How to...? Note that such an instruction applies to all instances of the module: Twin CAT 3 Version: 1.18.0 237

## Page 238

How to...? 13.16 Online Change per ADS The Online Change [} 152] is normally carried out from XAE Engineering. However, it is also possible to carry out the Online Change via ADS and thus in your own programs: • ADS WRITE • Ams Port: 11 • Idx Grp: Object ID • Idx Offset: 16#03002119 (PID_Library Id) 238 Version: 1.18.0 Twin CAT 3

## Page 239

How to...? • Daten: Library Id (“<vendor>|<library>|<version>”) Twin CAT 3 Version: 1.18.0 239

## Page 240

Troubleshooting 14 Troubleshooting This is a list of pitfalls and glitches within the handling of Twin CAT C++ modules. 14.1 Build - "The target ... does not exist in the project" In particular when transferring a Twin CAT Solution from one machine to another, Visual Studio may display error messages to the effect that not all targets (such as Build, Rebuild, Clean) exist in the project. Check the configuration of the "platform toolset" of the C++ project. It may need to be reconfigured if solutions migrate from one Visual Studio version to another: 14.2 Debug - "Unable to attach" If this error message appears when starting the debugger in order to debug a Twin CAT C++ project, then a configuration step is missing: 240 Version: 1.18.0 Twin CAT 3

## Page 241

Troubleshooting In this case, navigate to System -> Real-Time, select the C++ Debugger tab and activate the option Enable C++ Debugger. 14.3 Activation – “invalid object id” (1821/0x71d) If the ADS Return Code 1821 / 0x71d is reported during the course of the start, check the context of the module instance as described in Quick start [} 74]. Twin CAT 3 Version: 1.18.0 241

## Page 242

Troubleshooting 14.4 Using C++ classes in Twin CAT C++ module When adding (non-Twin CAT) C++ classes using the Visual Studio context menu Add->Class..., the compiler/linker reports: Error 4 error C1010: unexpected end of file while looking for precompiled header. Did you forget to add '#include ""' to your source? Insert the following lines at the start of your generated class file: #include "Tc Pch.h" #pragma hdrstop 242 Version: 1.18.0 Twin CAT 3

## Page 243

C++-samples 15 C++-samples Sample code and configurations for this product can be obtained from the corresponding repository on Git Hub: https://github.com/Beckhoff/TC1300_Samples. There you have the option to clone the repository or download a ZIP file containing the sample. This picture provides an overview in graphical form and places the emphasis on the interaction possibilities of a C++ module. Twin CAT 3 Version: 1.18.0 243

## Page 244

C++-samples Beyond that, this is a table with brief descriptions of the samples. 244 Version: 1.18.0 Twin CAT 3

## Page 245

C++-samples Number Title Description 01 Sample01: Cyclic This article describes the implementation of a Twin CAT 3 C++ module that uses an IO module mapped with physical IO. This sample describes the module with IO quick start for the purpose of creating a C++ module that increments a [} 247] counter at each cycle and assigns the counter to the logical output "Value" in the data area. The data area can be assigned to the physical IO or another logical input of another module instance. 02 Sample02: Cyclic Describes the flexibility of C++ code when working with IOs that are configured at the task. Thanks to this approach, a finally compiled C++ with IO Task module can affect various IOs connected with the IO task much more [} 247] flexibly. One application could be to check cyclic analog input channels, where the number of input channels can differ from one project to another. 03 Sample03: ADS Describes the design and implementation of one's own ADS interface in a C++ module. Server Client The sample contains two parts: [} 248] • ADS server implemented in Twin CAT 3 C++ with user-specific ADS interface, ADS Client UI implemented in C#, which transmits user-specific ADS messages to the ADS server. 05 Sample05: Co E Shows how Co E registers of Ether CAT devices can be accessed over ADS. access via ADS [} 257] 06 Sample06: ADS Shows how symbols in an ADS server can be accessed via the ADS interface. C# ADS client connects to a module implemented in PLC/C++/ C# client uploads Matlab®. Upload the available symbol information and read/write ADS symbols subscription for process values. [} 258] 07 Sample07: Describes the implementation of a Twin CAT 3 C++ module that receives ADS notifications regarding data changes on other modules. Receiving ADS Notifications [} 263] 08 Sample08: Describes the implementation of methods that can be called by ADS via the task. Provision of ADS- RPC [} 264] 10 Sample10: Describes the interaction between two C++ modules with a direct data pointer. The two modules must be implemented on the same CPU core in Module the same real-time context. communication: Use of data pointers [} 267] 11 Sample11: This sample contains two parts: Module • A C++ module which functions as a state machine that provides an communication: interface with methods for starting/stopping and also for setting/ Method call PLC maintaining the state machine. module to C++ Second PLC module for interacting with the first module by calling methods module [} 268] from the C++ module. 11a Sample11a: This sample contains two classes in one driver (can also be done between two drivers). Module communication: • One module that provides a calculation method. Access is protected Method call C++ through a Critical Section. module to C++ A second module that acts as the caller to use the methods in the other module [} 295] module. Twin CAT 3 Version: 1.18.0 245

## Page 246

C++-samples Number Title Description 12 Sample12: Describes how two modules can interact with each other via mapping of symbols from the data area of different modules. The two modules can be Module executed on the same or different CPU cores. communication: Using IO mapping [} 296] 13 Sample13: Describes how a Twin CAT 3 C++ module calls a PLC function block using Tc COM interface methods. Module communication: Method call C++ module to PLC module [} 297] 19 Sample19: Describes how the file IO functionality can be used in a C++ module in a synchronous manner. Synchronous File The sample writes process values to a file. Writing to the file is triggered by Access [} 300] a deterministic cycle - the execution of file IO is decoupled (asynchronous), i.e. the deterministic cycle continues and is not hindered by writing to the file. The status of the routine for decoupled writing to the file can be checked. 20 Sample20: File IO- Describes how the file IO functionality can be used with the C++ module. The sample writes process values to a file. Writing to the file is triggered by Write [} 301] a deterministic cycle - the execution of file IO is decoupled (asynchronous), i.e. the deterministic cycle continues and is not hindered by writing to the file. The status of the routine for decoupled writing to the file can be checked. 20a Sample20a: A more extensive sample than S20 and S19. It describes the cyclic read and/or write access to files from a C++ module. File IO-Cyclic Read / Write [} 301] 22 Sample22: Describes how the Twin CAT Automation Device Driver (ADD) is to be written for access to the DPRAM. Automation Device Driver (ADD): Access DPRAM [} 303] 23 Sample23: Describes the use of Structured Exception Handling (SEH) based on five variants. Structured Exception Handling (SEH) [} 304] 24 Sample24: Describes the use of semaphores. Semaphores [} 306] 25 Sample25: Static Describes how to use the C++ static library contained in another C++ module. Library [} 307] 26 Sample26: Order Describes the determination of the task execution order, if a task is assigned to more than one module. of execution in a task [} 309] 30 Sample30: Timing Describes the measurement of the C++ cycle or execution time. Measurement [} 311] 246 Version: 1.18.0 Twin CAT 3

## Page 247

C++-samples Number Title Description 31 Sample31: Describes the implementation of a behavior in C++, which is comparable to a TON function block of PLC / 61131. Functionblock TON in Twin CAT3 C++ [} 312] 37 Sample37: Describes the loading and saving of the state of an object during the initialization and de-initialization. Archive data [} 314] Tc COM Tc COM samples Several samples are provided to illustrate the module communication between PLC and C++. [} 315] 15.1 Sample01: Cyclic module with IO This article describes how to implement a Twin CAT 3 C++ module which is using the module IO mapped to physical IO. Download You can obtain the source code for this sample here: https://github.com/Beckhoff/TC1300_Samples/tree/main/S01-Cyclic IO 1. Using a Visual Studio with Twin CAT installed, open the project via Open Project .... 2. Configure signing for this project by switching on Twin CAT signing with a right-click on Project- >Properties->Tc Sign and configure your certificate and password if necessary. Further information on signing C++ projects can be found in the chapter Twin CAT [} 24]. 3. Select your target system. 4. Build the sample (e.g. Build->Build Solution). 5. Activate the configuration by clicking . ð The sample is ready for operation. Description This sample describes the quick start for the purpose of creating a C++ module that increments a counter on each cycle and assigns the counter to the logical output Value in the data area. The data area can be assigned to the physical IO or another logical input or another module instance. The sample is described step by step in the short instructions [} 61]. Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340291083.zip 15.2 Sample02: Cyclic C++ logic, which uses IO from the IO Task This article describes the implementation of a Twin CAT 3 C++ module that uses an image of an IO Task. Download Here you can access the source code for this sample: https://github.com/Beckhoff/TC1300_Samples/tree/main/S02-Cyclic IOTask 1. Using a Visual Studio with Twin CAT installed, open the project via Open Project .... Twin CAT 3 Version: 1.18.0 247

## Page 248

C++-samples 2. Configure signing for this project by switching on Twin CAT signing with a right-click on Project- >Properties->Tc Sign and configure your certificate and password if necessary. Further information on signing C++ projects can be found in the chapter Twin CAT [} 24]. 3. Select your target system. 4. Build the sample (e.g. Build->Build Solution). 5. Activate the configuration by clicking . ð The sample is ready for operation. Source code that is not automatically generated by the wizard is marked with a start flag "//sample code" and end flag "//sample code end". This allows you to search for these character strings in the files to get an idea of the details. Description This sample describes the flexibility of C++ code when working with IOs configured at the task. This approach enables a compiled C++ module to respond more flexibly, if a different number of IOs are linked to the IO task. One application option would be cyclic testing of analog input channels with a different number of channels, depending on the project. The sample contains • the C++ module Tc Io Task Image Access Drv with a module instance Tc Io Task IMage Access Drv_Obj1 • A "Task1" with an image, 10 input variables (Var1.. Var10) and 10 output variables (Var11.. Var20). • They are linked: The instance is called by the task and uses the image of Task1. The C++ code accesses the values via a data image, which is initialized during the transition from SAFEOP to OP (SO). In the cyclically executed method Cycle Update the value of each input variable is checked by calling the helper method Check Value. If it is less than 0, the corresponding output variable is set to 1, if it is greater than 0, it is set to 2, if it is 0, the output is set to 3. After activation of the configuration you can access the variables via the Solution Explorer and set them. Double-click on the Task1 image of system for an overview. The input variables can be opened and then set with the Online tab. Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340292747.zip 15.3 Sample03: C++ as ADS server This article describes: • The creation of a Twin CAT 3 C++ module that acts as an ADS server. The server provides an ADS interface for starting / stopping / resetting a counter variable in the C++ module. The counter is available as a module output and can be assigned to an output terminal (analog or a number of digital IOs). How the TC3 ADS server function written in C++ is to be implemented. [} 249] • The creation of a C# ADS client to interact with the C++ ADS server. The client provides a UI for connection locally or via a network to an ADS server with the ADS interface to be counted. The UI enables the starting / stopping / reading / overwriting and resetting of the counter. Sample code: ADS Client UI written in C# [} 253]. Understanding the sample Options for the automatic determination of an ADS port are used in the sample. The disadvantage of this is that the client has to be configured at each start in order to access the correct ADS port. 248 Version: 1.18.0 Twin CAT 3

## Page 249

C++-samples Alternatively, the ADS port can be hard-coded in the module as shown below. Disadvantage here: The C++ module cannot be instanced more than once as it is not possible to share an ADS port. 15.3.1 Sample03: TC3 ADS Server written in C++ This article describes how to create a TC3-C++ module acting as a ADS-server. The server will provide an ADS interface to start / stop / reset an counter variable insight the C++ module. Download Here you can access the source code for this sample: https://github.com/Beckhoff/TC1300_Samples/tree/main/S03-ADSServer . 1. Using a Visual Studio with Twin CAT installed, open the project via Open Project .... 2. Configure signing for this project by switching on Twin CAT signing with a right-click on Project- >Properties->Tc Sign and configure your certificate and password if necessary. Further information on signing C++ projects can be found in the chapter Twin CAT [} 24]. 3. Select your target system. 4. Build the sample (e.g. Build->Build Solution). 5. Activate the configuration by clicking . ð The sample is ready for operation. Description This sample contains a C++ module that acts as an ADS server. The server grants access to a counter that can be started, stopped and read. The header file of the module defines the counter variable m_b Count, and the corresponding .cpp file initializes the value in the constructor and implements the logic in the Cycle Update method. The Ads Read Write Ind method in the .cpp file analyzes the incoming messages and returns the return values. A define in the header file is added for a further added message type. Details such as the definition of the ADS message types are described in the following cookbook, where you can compile the sample manually. Cookbook This is a step by step description about the creation of the C++ module. Twin CAT 3 Version: 1.18.0 249

## Page 250

C++-samples 1. Create a new Twin CAT 3 project solution Follow the steps for creating a new Twin CAT 3 project [} 61]. 2. Create a C++ project with ADS port Follow the steps for the creation of a new Twin CAT 3 C++ project [} 62]. Select Twin CAT Module Class with ADS port in the Class templates dialog. 3. Add the sample logic to the project 1. Open the header file <My Class>.h (in this sample Module1.h) and add the counter m_b Count to the protected area as a new member variable: class CModule1 : public ITCom Object , public ITc Cyclic ,... { public: DECLARE_IUNKNOWN() .... protected: DECLARE_ITCOMOBJECT_SETSTATE(); ///<Auto Generated Content id="Members"> ITc Cyclic Caller Info Ptr m_sp Cyclic Caller; ..... ///</Auto Generated Content> ULONG m_Read By Oid And Pid; BOOL m_b Count; }; 2. Open the class file <My Class>.cpp (in this sample Module1.cpp) and initialize the new values in the constructor: CModule1::CModule1() ..... { memset(&m_Counter, 0, sizeof(m_Counter)); memset(&m_Inputs, 0, sizeof(m_Inputs)); memset(&m_Outputs, 0, sizeof(m_Outputs)); m_b Count = FALSE; // by default the counter should not increment m_Counter = 0; // we also initialize this existing counter } ð The sample code has been added. 3.a. Add the sample logic to the ADS server interface. Usually, the ADS server receives an ADS message, which contains two parameters (index Group and index Offset) and perhaps further p Data. Designing an ADS interface Our counter is to be started, stopped, reset, overwritten with a value or send a value to the ADS client on request: 250 Version: 1.18.0 Twin CAT 3

## Page 251

C++-samples index Group index Offset Description 0x01 0x01 m_b Count = TRUE, counter is incremented. 0x01 0x02 Counter value is transferred to ADS client. 0x02 0x01 m_b Count = FALSE, counter is no longer incremented. 0x02 0x02 Reset counter. 0x03 0x01 Overwrite counter with value transferred by ADS client. These parameters are defined in modules1Ads.h – change the source code to add a new command for IG_RESET. #include "Tc Def.h" enum Module1Index Groups : ULONG { Module1Index Group1 = 0x00000001, Module1Index Group2 = 0x00000002, // add command IG_OVERWRITE = 0x00000003 // and new command }; enum Module1Index Offsets : ULONG { Module1Index Offset1 = 0x00000001, Module1Index Offset2 = 0x00000002 }; Change the source code in your <My Class>::Ads Read Write Ind() method (in this case in Module1.cpp). switch(index Group) { case Module1Index Group1: switch(index Offset) { case Module1Index Offset1: ... // TODO: add custom code here m_b Count = TRUE; // received IG=1 IO=1, start counter Ads Read Write Res(r Addr, invoke Id, ADSERR_NOERR, 0,NULL); break; case Module1Index Offset2: ... // TODO: add custom code here // map counter to data pointer p Data = &m_Counter; // received IG=1 IO=2, provide counter value via ADS Ads Read Write Res(r Addr, invoke Id, ADSERR_NOERR, 4 ,p Data); //comment this: Ads Read Write Res(r Addr, invoke Id,ADSERR_NOERR, 0, NULL); break; } break; case Module1Index Group2: switch(index Offset) { case Module1Index Offset1: ... // TODO: add custom code here // Stop incrementing counter m_b Count = FALSE; // map counter to data pointer p Data = &m_Counter; Ads Read Write Res(r Addr, invoke Id, ADSERR_NOERR, 4,p Data); break; case Module1Index Offset2: ... // TODO: add custom code here // Reset counter m_Counter = 0; // map counter to data pointer p Data = &m_Counter; Ads Read Write Res(r Addr, invoke Id, ADSERR_NOERR, 4, p Data); break; } break; Twin CAT 3 Version: 1.18.0 251

## Page 252

C++-samples case IG_OVERWRITE: switch(index Offset) { case Module1Index Offset1: ... // TODO: add custom code here // override counter with value provided by ADS-client unsigned long *p Counter = (unsigned long*) p Data; m_Counter = *p Counter; Ads Read Write Res(r Addr, invoke Id, ADSERR_NOERR, 4, p Data); break; } break; } break; default: __super::Ads Read Write Ind(r Addr, invoke Id, index Group,index Offset, cb Read Length, cb Write Length, p Data; break; } 3.b. Insert the sample logic into the cyclic part The <My Class>::Cycle Update() method is cyclically called – this is the point where the logic is to be changed. // TODO: Replace the sample with your cyclic code m_Counter+=m_Inputs. Value; // replace this line m_Outputs. Value=m_Counter; In this case the counter m Counter is incremented if the boolean variable m_b Count is TRUE. Insert this if-case into your cyclic method. HRESULT CModule1::Cycle Update(ITc Task* ip Task, ITc Unknown* ip Caller, ULONG context) { HRESULT hr = S_OK; // handle pending ADS indications and confirmations Check Orders(); .... // TODO: Replace the sample with your cyclic code if (m_b Count) // new part { m_Counter++; } m_Outputs. Value=m_Counter; } 4. Execute server sample 1. Run the Twin CAT TMC Code Generator in order to provide the inputs/outputs for the module. 2. Save the project. 3. Compile the project. 4. Create a module instance. 5. Create a cyclic task and configure the C++ module for the execution in this context. 6. Scan the hardware IO and assign the symbol Value of outputs to certain output terminals (this is optional). 7. Activate [} 76] the Twin CAT project. ð The sample is ready for operation. 5. Determine the ADS port of the module instance Generally the ADS port may be • pre-numbered, so that the same port is always used for this module instance. • kept customizable, in order to offer several module instances the option to have their own ADS port assigned on startup of the Twin CAT system. 252 Version: 1.18.0 Twin CAT 3

## Page 253

C++-samples In this sample the default setting (keep flexible) is selected. First of all you have to determine the ADS port that was assigned to the module that has just been activated. 1. Navigate to the module instance. 2. Select the Parameter Online tab. ð 0x8235 or decimal 33333 is assigned to the ADS port (this may be different in your sample). If more and more instances are created, each instance is allocated its own unique Ads Port. ð The counter is still at "0" because the ADS message to start the incrementation has not been sent. ð The server part is completed - continue with ADS client sends the ADS messages [} 253]. Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340296075.zip 15.3.2 Sample03: ADS client UI in C# This article describes the ADS client, which sends ADS messages to the previously described ADS server. The implementation of the ADS server depends neither on the language (C++ / C# / PLC / ...) nor on the Twin CAT version (Twin CAT 2 or Twin CAT 3). Download Here you can access the source code for this sample: https://github.com/Beckhoff/TC1300_Samples/tree/main/S03-ADSClient ü This code requires . NET Framework 1. Open the sln file contained in it with Visual Studio. 2. Create the sample on your local machine (right-click on the project and click on Build). 3. Start the program with a right-click on Project, Debug->Start new instance. Description This client performs two tasks: • Testing the ADS-server, which was described before. • Providing sample code for implementing a ADS-client Twin CAT 3 Version: 1.18.0 253

## Page 254

C++-samples Using the client Selecting a communication partner Enter both ADS parameters in order to specify your ADS communication partner: • Net ID: 127.0.0.1.1.1 (for ADS partners also connected to local ADS Message Router) Enter a different Net ID if you want to communicate via the network with an ADS partner connected to another ADS router. You must first establish an ADS route between your device and the remote device once. • Ads Port Enter the Ads Server Port of your communication partner. Do not confuse the ADS server port (which has explicitly implemented your own message handler) with the regular ADS port for the purpose of accessing symbols (this is provided automatically, without the need for user intervention). Find the assigned Ads Port [} 249], in this sample the Ads Port was 0x8235 (dec 33333). Create link with communication partner Click on Connect to call the method Tc Ads Client. Connect for the purpose of creating a link with the configured port. The Start / Read / Stop / Overwrite / Reset buttons are used to send ADS messages to the ADS server. The specific index Group / index Offset commands have already been designed in the ADS interface of the ADS server [} 249]. The result of clicking on the command buttons can also be seen in the module instance in the Parameters (online) tab. 254 Version: 1.18.0 Twin CAT 3

## Page 255

C++-samples C# program Here is the "Core" code of the ADS client – download for the GUI or ZIP file above. using System; using System. Collections. Generic; using System. Component Model; using System. Data; using System. Drawing; using System. Text; using System. Windows. Forms; using Twin CAT. Ads; namespace ads Client Visu { public partial class form : Form { public form() { Initialize Component(); } private void Form1_Load(object sender, Event Args e) { // create a new Tc Client instance _tc Client = new Tc Ads Client(); ads Read Stream = new Ads Stream(4); ads Write Stream = new Ads Stream(4); } /* * Connect the client to the local AMS router */ private void bt Connect_Click(object sender, Event Args e) Twin CAT 3 Version: 1.18.0 255

## Page 256

C++-samples { Ams Address server Address = null; try { server Address = new Ams Address(tb Net Id. Text, Int32. Parse(tb Port. Text)); } catch { Message Box. Show("Invalid AMS Net Id or Ams port"); return; } try { _tc Client. Connect(server Address. Net Id, server Address. Port); lb Output. Items. Add("Client port " + _tc Client. Client Port + " opened"); } catch { Message Box. Show("Could not connect client"); } } private void bt Start_Click(object sender, Event Args e) { try { _tc Client. Read Write(0x1, 0x1, ads Read Stream, ads Write Stream); byte[] data Buffer = ads Read Stream. To Array(); lb Output. Items. Add("Counter started value = " + Bit Converter. To Int32(data Buffer, 0)); } catch (Exception err) { Message Box. Show(err. Message); } } private void bt Read_Click(object sender, Event Args e) { try { _tc Client. Read Write(0x1, 0x2, ads Read Stream, ads Write Stream); byte[] data Buffer = ads Read Stream. To Array(); lb Output. Items. Add("Counter = " + Bit Converter. To Int32(data Buffer, 0)); } catch (Exception err) { Message Box. Show(err. Message); } } private void bt Stop_Click(object sender, Event Args e) { try { _tc Client. Read Write(0x2, 0x1, ads Read Stream, ads Write Stream); byte[] data Buffer = ads Read Stream. To Array(); lb Output. Items. Add("Counter stopped value = " + Bit Converter. To Int32(data Buffer, 0)); } catch (Exception err) { Message Box. Show(err. Message); } } private void bt Reset_Click(object sender, Event Args e) { try { _tc Client. Read Write(0x2, 0x2, ads Read Stream, ads Write Stream); byte[] data Buffer = ads Read Stream. To Array(); lb Output. Items. Add("Counter reset Value = " + Bit Converter. To Int32(data Buffer, 0)); } 256 Version: 1.18.0 Twin CAT 3

## Page 257

C++-samples catch (Exception err) { Message Box. Show(err. Message); } } } } Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340294411.zip 15.4 Sample05: C++ Co E access via ADS This article describes how to implement a Twin CAT 3 C++ modules which can access the Co E (CANopen over Ether CAT) register of a Ether CAT terminal. Download Here you can access the source code for this sample: https://github.com/Beckhoff/TC1300_Samples/tree/main/S05-Co EAccess 1. Open the zip file that it contains in Twin CAT 3 by clicking on Open Project …. 2. Select your target system. 3. Build the sample on your local machine (e.g. Build->Build Solution). 4. Note the actions listed on this page under Configuration. 5. Activate the configuration by clicking . ð The sample is ready for operation. Description This sample describes access to an Ether CAT Terminal, which reads the manufacturer ID and specifies the baud rate for serial communication. This sample describes the quick start for the purpose of creating a C++ module that increments a counter on each cycle and assigns the counter to the logical output Value in the data area. Configuration 1. Activate the Ether CAT address of the terminal concerned and assign it. Twin CAT 3 Version: 1.18.0 257

## Page 258

C++-samples 2. Activate inclusion of the ADS address in the advanced settings for the Ether CAT Terminal: 3. Assign the ADS address (including net Id and port) to the module input Ads Adress: 4. The module parameters are read out and displayed by the sample code during the course of the initialization: Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340297739.zip 15.5 Sample06: UI-C#-ADS client uploading the symbolic from module This article describes the implementation of an ADS client to 258 Version: 1.18.0 Twin CAT 3

## Page 259

C++-samples • connect to an ADS server that provides a process image (data area); the connection can be established locally or remotely via a network, • upload symbol information, • read / write data synchronously, • subscribe to symbols, in order to obtain values on change as callback. Download Here you can access the source code for this sample: https://github.com/Beckhoff/TC1300_Samples/tree/main/S06-Symbol Upload Client ü This code requires . NET Framework 3.5 or higher! 1. Open the sln file contained in it with Visual Studio. 2. Create the sample on your local machine (right-click on the project and click on "Build"). 3. Start the program with a right-click on Project, Debug->Start new instance. The client sample should be used with Sample 03 "C++ as ADS server". Open Sample 03 [} 249] before you begin with this client-side sample! Description The possibilities of the ADS are described on the basis of this sample. The details of the implementation are described in Form1.cs, which is included in the download. The connection via ADS with the target system is established in the btn Load_Click method, which is called on clicking on the Load Symbols button. From there you can explore the different GUI functions. Background information: For this ADS client it is irrelevant whether the ADS server is based on Twin CAT 2 or Twin CAT 3. It also doesn't matter if the server is a C++ module, a PLC module or an IO task without any logic. The ADS client UI On starting of the sample the user interface (UI) is displayed. Twin CAT 3 Version: 1.18.0 259

## Page 260

C++-samples Selecting a communication partner After starting the client, enter the two ADS parameters to determine your ADS communication partner. • Net ID: 127.0.0.1.1.1 (for ADS partner also linked with local ADS message router). Enter another Net ID, if you want to communicate with an ADS partner connected to another ADS router via the network. First you have to create an ADS route between your device and the remote device. • Ads Port Enter the Ads Port of your communication partner: 350 (in this sample). Do not confuse the ADS server port with the regular ADS port. Do not confuse the ADS server port (which was explicitly implemented in Sample 03 for providing your own message handler) with the regular ADS port for the purpose of access to symbols (this is provided automatically, without the need for user intervention): The regular ADS port is required to access symbols. You can find the Ads Port for the IO task of your instance or the module instance yourself (since the module is executed in the context of the IO task). Navigate to IO task Task1 and note the value of the port: 350. 260 Version: 1.18.0 Twin CAT 3

## Page 261

C++-samples Since the C++ module instance is executed in the context of Task1, the ADS port is also 350. Enabled symbols for access available via ADS It is possible to provide or not provide individual symbols or even complete data areas for access via ADS. Navigate to the Data Area tab of your instance and enable/disable the C/S column. In this sample all symbols are marked and therefore available for ADS access. After making the changes, click on Activate configuration. Twin CAT 3 Version: 1.18.0 261

## Page 262

C++-samples Load symbols Once the Net ID and the ADS port have been set up, click on the Load Symbols button to make a connection with the target system and load the symbols. All available symbols are then visible. You can then: • Write a new value: Select a symbol in the left-hand tree, e.g. Counter. Enter a new value in the Value edit field on the right-hand side and click Write using Write Symbol. The new value is written to the ADS server. After writing a new value with Write using Write Symbol, the C# application also receives a Callback with the new value. • Subscribe to receive a Callback when values change: select an icon in the left-hand tree, e.g. Counter. click on Watch Current Symbol. 262 Version: 1.18.0 Twin CAT 3

## Page 263

C++-samples Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340299403.zip 15.6 Sample07: Receiving ADS Notifications This article describes how to implement a Twin CAT 3 C++ module which receives ADS Notifications about data changes on other modules. Since all other ADS communication has to be implemented in a similar way, this sample is the general entry point to initialize ads communication from Twin CAT 3 C++ modules. Download Here you can access the source code for this sample: https://github.com/Beckhoff/TC1300_Samples/tree/main/S07-Ads Notifications 1. Using a Visual Studio with Twin CAT installed, open the project via Open Project .... 2. Configure signing for this project by switching on Twin CAT signing with a right-click on Project- >Properties->Tc Sign and configure your certificate and password if necessary. Further information on signing C++ projects can be found in the chapter Twin CAT [} 24]. 3. Select your target system. 4. Build the sample (e.g. Build->Build Solution). 5. Activate the configuration by clicking . ð The sample is ready for operation. Description This sample describes the reception of ADS notifications in a Twin CAT 3 C++ module. Twin CAT 3 Version: 1.18.0 263

## Page 264

C++-samples The solution contains 2 modules for this purpose. • A C++ module, which registers for querying ADS notifications of a variable. • For a simple understanding: A PLC program that provides a variable MAIN. Plc Var. If its value changes, an ADS notification is sent to the C++ module. • The C++ module utilizes the message recording options. For a better understanding of the code, simply start the sample and note the output / error log when you change the value Main. Plc Var of the PLC module. The address is prepared during the module transition PREOP->SAFEOP (Set Obj State PS). The Cycle Update method contains a simple state machine, which sends the required ADS command. Corresponding methods show the receipts. The inherited and overloaded method Ads Device Notification Ind is called when a notification is received. During shutdown, ADS messages are sent during transition for the purpose of logoff (Set Obj State OS), and the module waits for receipts of confirmation until a timeout occurs. Start of the module development Creating a Twin CAT 3 C++ module with the aid of the ADS port wizard. This sets up everything you need for establishing an ADS communication. Simply use and overwrite the required ADS methods of ADS.h, as shown in the sample. See also ADS Communication [} 194] Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340301067.zip 15.7 Sample08: provision of ADS-RPC This article describes the implementation of methods that can be called by ADS via the task. Download Here you can access the source code for this sample: https://github.com/Beckhoff/TC1300_Samples/tree/main/S08-ADSRPC 1. Using a Visual Studio with Twin CAT installed, open the project via Open Project .... 2. Configure signing for this project by switching on Twin CAT signing with a right-click on Project- >Properties->Tc Sign and configure your certificate and password if necessary. Further information on signing C++ projects can be found in the chapter Twin CAT [} 24]. 3. Select your target system. 4. Build the sample (e.g. Build->Build Solution). 5. Activate the configuration by clicking . ð The sample is ready for operation. Description The download contains 2 projects: • The Twin CAT project, which contains a C++ module. This offers some methods that can be called by ADS. • Also included is a Visual C++ project that calls the methods from the User mode as a client. Four methods with different signatures are provided and called. These are organized in two interfaces, so that the composition of the ADS symbol names of the methods becomes clear. 264 Version: 1.18.0 Twin CAT 3

## Page 265

C++-samples Understanding the sample The sample consists of the Twin CAT C++ module, which offers the RPC methods and a C++ sample program that calls them. Twin CAT C++ module The Twin CAT C++ project contains a module and an instance of the module with the name "foobar". RPC methods are normal methods that are described by interfaces in the TMC editor and are additionally enabled by an RPC enable checkbox. The options are described in more detail in the Description of the TMC Editor [} 90]. In this module two interfaces are described and implemented, as can be seen in the TMC Editor: The methods, four in all, have different signatures of call and return values. The ADS symbol name is formed according to the pattern: Modul Instance. Interface#Methodenname The Context Id, which defines the context for execution, is particularly important in the implementing module. As can be seen in the C++ code itself, the methods are generated by the code generator and implemented like normal methods of a Tc COM module. Twin CAT 3 Version: 1.18.0 265

## Page 266

C++-samples If the type information of the methods is to be available on the target system, the TMI file of the module can be transferred to the target system. The Twin CAT OPC UA Server offers the option to call these methods also by OPC UA – the TMI files are required on the target system for this. C++ sample client Directly after starting, the C++ client will fetch the handles and then call the methods any number of times; however a [RETURN] is expected between the procedures. Every other key leads to the enabling of the handle and the termination of the program. The outputs illustrate the calls: 266 Version: 1.18.0 Twin CAT 3

## Page 267

C++-samples Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340302731.zip 15.8 Sample10: module communication: Using data pointer This article describes the implementation of two Twin CAT 3 C++ modules, which communicate via a data pointer. Download Here you can access the source code for this sample: https://github.com/Beckhoff/TC1300_Samples/tree/main/S10-Mod2Mod Data Pointer 1. Using a Visual Studio with Twin CAT installed, open the project via Open Project .... 2. Configure signing for this project by switching on Twin CAT signing with a right-click on Project- >Properties->Tc Sign and configure your certificate and password if necessary. Further information on signing C++ projects can be found in the chapter Twin CAT [} 24]. 3. Select your target system. 4. Build the sample (e.g. Build->Build Solution). 5. Activate the configuration by clicking . ð The sample is ready for operation. Description This communication is based on a "split" data area: Provided by a module and accessible from another module via pointers. It is not possible that two different data pointers are linked with the same entry in an output or input data area; without this limitation there could be synchronization problems. For this reason a Module Data Provider module consolidates input and output in a standard data area, which is not subject to this restriction. All in all, this sample includes the following modules: • Module Data Provider provides a data area, which can be accessed by the other modules. The data area contains 4 bits (2 for input, 2 for output) and 2 integers (1 for input, 1 for output). • Module Data In Out provides "normal" input variables, which are written to the data area of the Module Data Provider, and output variables, which are read from the data area. This instance of the CModule Data In Out class serve as a simulation for real IO. Twin CAT 3 Version: 1.18.0 267

## Page 268

C++-samples • Module Data Access A accesses the data area of Module Data Provider and cyclically processes Bit1 / Bit Out1 and the integer. • Module Data Access B accesses the data area of Module Data Provider and cyclically processes Bit2 / Bit Out2 and the integer. The user of the sample triggers Module Data In Out by setting the variables Value In / Bit1 / Bit2: • When setting the input Bit1, the output Switch1 will be set accordingly. • When setting the input Bit2, the output Switch2 will be set accordingly. • When the input Value In is set, the output Value Out is incremented twice in each cycle. All modules are configured such that they have the same task context, which is necessary since access via pointers offers no synchronization mechanism. The order of execution corresponds to the order specified on the context configuration tab. This value is passed on as parameter Sort Order and stored in the smart pointer of the cyclic caller (m_sp Cyclic Caller), which also contains the object ID of the cyclic caller. Understanding the sample The module Module Data In Out has input and output variables. They are linked with the corresponding variables of the data provider. The module Module Data Provider provides an input and output data array and implements the ITc Io Cylic interface. The method Input Update copies data from the input variables to the Data In symbol of the standard data area Data, and the method Output Update copies data from the Data Out symbol to the output variables. The modules Module Data Access A and Module Data Access B contain pointers to data areas of the data provider via links. These pointers are initialized during the transition from SAFEOP to OP. Module Data Access A cyclically sets Bit Out1 according to Bit1. Module Data Access B accordingly, with Bit Out2 / Bit2. Both increment Value Out through multiplication of the internal counter with the value Value In. It is important that all modules are executed in the same context, since there is no synchronization mechanism via data pointers. The order of execution is defined by the Sort Order on the Context tab of the respective module. This is provided as parameter Sort Order in the Smart Pointer (m_Sp Cyclic Caller), which also includes the Object ID. Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340317195.zip 15.9 Sample11: Module communication: method call PLC module to C++ module This article describes the implementation: • A C++ module [} 269] that provides methods for controlling a state machine. Follow this step-by-step introduction to the implementation of a C++ module that provides an interface to the state machine. • Of a PLC module [} 283] for calling the function of the C++ module. The fact that no hard-coded link exists between the PLC and the C++ module is a great. Instead, the called C++ instance can be configured in the System Manager. Follow this step-by-step introduction with regard to the implementation of a PLC project that calls methods from a C++ module. Download Here you can access the source code for this sample: https://github.com/Beckhoff/TC1300_Samples/tree/main/S11-Mod2Mod Method 1. Using a Visual Studio with Twin CAT installed, open the project via Open Project .... 268 Version: 1.18.0 Twin CAT 3

## Page 269

C++-samples 2. Configure signing for this project by switching on Twin CAT signing with a right-click on Project- >Properties->Tc Sign and configure your certificate and password if necessary. Further information on signing C++ projects can be found in the chapter Twin CAT [} 24]. 3. Select your target system. 4. Build the sample (e.g. Build->Build Solution). 5. Activate the configuration by clicking . ð The sample is ready for operation. Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340320523.zip 15.9.1 Twin CAT 3 C++ module providing methods This article describes the creation of a Twin CAT 3 C++ module that provides an interface with several methods that can be called by a PLC and also by other C++ modules. The idea is to create a simple state machine in C++ that can be started and stopped from the outside by other modules, but which also allows the setting or reading of the particular state of the C++ state machine. Two further articles use the result from this C++ state machine. • Calling the function from the PLC logic [} 268] - i.e. affecting the C++ code from the PLC. • Calling the function from the C++ logic [} 295] - i.e. interaction between two C++ modules. This article describes: • Step 1: create a new Twin CAT 3 project [} 269]. • Step 2: create a new Twin CAT 3 C++ driver [} 270]. • Step 3: create a new Twin CAT 3 interface. • Step 4: add methods to the interface [} 273]. • Step 5: add a new interface to the module. • Step 6: start the Twin CAT TMC Code Generator to generate code for the module class description [} 278]. • Step 7: implement the member variables and the constructor. • Step 8: implement methods. • Step 9: implement cyclic update. • Step 10: compile code [} 281] • Step 11: create an instance of the C++ module. • Step 12: done. Check the results. Step 1: Creating a Twin CAT 3 project First of all, create a Twin CAT project as usual. Twin CAT 3 Version: 1.18.0 269

## Page 270

C++-samples Step 2: create a new Twin CAT 3 C++ driver 1. Right-click on C++ and Add New Item… 270 Version: 1.18.0 Twin CAT 3

## Page 271

C++-samples 2. Select the template Twin CAT Driver Project and enter a driver name, "State Machine Drv" in this sample. Click on Add to continue. 3. Select a template to be used for this new driver. In this sample "Twin CAT Module Class with Cyclic IO" is selected, since the internal counter of the state machine is available for assigning to the IO. 4. Click on Add to continue. 5. Specify a name for the new class in the C++ driver "State Machine Drv". The names of the module class and the header and source files are derived from the specified "Short Name". Twin CAT 3 Version: 1.18.0 271

## Page 272

C++-samples 6. Click on OK to continue. ð The wizard then creates a C++ project, which can be compiled error-free. Step 3: create a new Twin CAT 3 interface NOTICE Name conflict A name collision can occur if the driver is used in combination with a PLC module. Do not use any of the keywords that are reserved for the PLC as names. 272 Version: 1.18.0 Twin CAT 3

## Page 273

C++-samples 1. Start the TMC editor by double-clicking on State Machine Drv.tmc. 2. Select Data Types within the TMC editor. 3. Add a new interface by clicking on Add a new interface . ð A new entry IInterface1 is then listed. 4. Open IInterface1 by double-clicking in order to change the properties of the interface. 5. Enter a meaningful name - in this sample "IState Machine". ð The interface has been created. Step 4: add methods to the interface 1. Click on Edit Methods... to get a list of the methods of this interface: Click on the + button to create a new default method, Method1. Twin CAT 3 Version: 1.18.0 273

## Page 274

C++-samples 2. Replace the default name Method1 by a more meaningful name, in this sample "Start". 3. Add a second method and name it "Stop". 4. Add a third method and name it "Set State". 274 Version: 1.18.0 Twin CAT 3

## Page 275

C++-samples 5. Subsequently, you can add parameters by clicking on Add a new parameter or edit parameters of the Set State method. ð The new parameter, Parameter1, is generated by default as Normal Type INT. 6. Click on the name "Parameter1" and change the name in the edit box to "State". 7. After Start, Stop and Set State have been defined, define a further method. 8. Rename it "Get State". 9. Add a parameter and name it "p State" (which is conceived to become a pointer later on). 10. Change Normal Type to Is Pointer. Twin CAT 3 Version: 1.18.0 275

## Page 276

C++-samples ð You then obtain a list of all methods. You can change the order of the methods with the buttons. Step 5: add a new interface to the module 1. Select the module that is to be extended by the new interface - in this case select the destination Modules->CState Machine Module. 2. Extend the list of implemented interfaces by a new interface with Add a new interface to the module by clicking on the + button. 276 Version: 1.18.0 Twin CAT 3

## Page 277

C++-samples 3. All available interfaces are listed - select the new interface IState Machine and end with OK. ð The new interface IState Machine is part of the module description. Twin CAT 3 Version: 1.18.0 277

## Page 278

C++-samples Step 6: Start the Twin CAT TMC Code Generator 1. In order to generate the C/C++ code on the basis of this module, right-click in the C/C++ project and then select the Twin CAT TMC Code Generator. ð The module State Machine Module.cpp now contains the new interfaces CModule1: Start() CModule1: Stop() CModule1: Set State(SHORT State) CModule1: Get State(SHORT* p State). Step 7: Implementing the member variables and the constructor Add the member variables to the header file State Machine Module.h. 278 Version: 1.18.0 Twin CAT 3

## Page 279

C++-samples Step 8: Implementing methods Implement the code for the four methods in the State Machine Module.cpp: Twin CAT 3 Version: 1.18.0 279

## Page 280

C++-samples Step 9: Implementing cyclic updating The C++ module instance is cyclically called, even if the internal state machine is in Stop mode. • If the state machine is not to be executed, the m_b Run Flag signals that the code execution of the internal state machine is to be exited. • If the state is "1" the counter must be incremented. • If the state is "2" the counter must be decremented. • The resulting counter value is assigned to Value, which is a member variable of the logical output of the data area. This can be assigned to the physical IO level or to other data areas of other modules at a later time. . 280 Version: 1.18.0 Twin CAT 3

## Page 281

C++-samples Step 10: compilation of code 1. Following the implementation of all interfaces, compile the code by right-clicking on the state machine and selecting Build. 2. Repeat the compilation and optimize your code until the result looks like this: ð Twin CAT 3 Version: 1.18.0 281

## Page 282

C++-samples Step 11: creating an instance of the C++ module 1. Right-click on the C++ project and select Add New Item... to create a new module instance. 2. Select the module that is to be added as a new instance – in this case CState Machine Module. 3. Assign the instance to a task: 282 Version: 1.18.0 Twin CAT 3

## Page 283

C++-samples ð Step 12: finished - check the result 1. Navigate to the module listed in the solution tree and select the Interfaces tab on the right-hand side. ð The new interface IState Machine is listed. 15.9.2 Calling methods offered by another module via PLC This article describes how a PLC can call a method that is provided by another module; in this case: the previously defined C++ module. • Step 1: check the available interfaces. • Step 2: create a new PLC project. Twin CAT 3 Version: 1.18.0 283

## Page 284

C++-samples • Step 3: add a new FB state machine [} 285](which acts as the proxy that calls the C++ module methods). • Step 4: clean up the function block interface. • Step 5: add the FB methods "FB_init" and "exit". [} 289] • Step 6: implement the FB methods. • Step 7: call the FB state machine in the PLC. [} 293] • Step 8: compile the PLC code. • Step 9: link the PLC FB with the C++ instance. • Step 10: observe the execution of both modules, PLC and C++. Step 1: Check available interfaces Option 1: 1. Navigate to the C++ module instance. 2. Select the Interfaces tab. ð The IState Machine interface is in the list with its specific IID (Interface ID). Option 2: 1. Navigate to System. 2. Select the Interfaces tab. 284 Version: 1.18.0 Twin CAT 3

## Page 285

C++-samples ð The IState Machine interface is in the list with its specific IID (Interface ID). The lower section shows the stored code in different programming languages. Step 2: Creating a new PLC project A standard PLC project called "PLC-calling state machine" is created. 1. Right-click on the PLC node. 2. Select Standard PLC Project. 3. Adapt the name. ð The project has been successfully created. Step 3: add a function block (FB) (which serves as the proxy for calling the C++ module methods) 1. Right-click on POUs. Twin CAT 3 Version: 1.18.0 285

## Page 286

C++-samples 2. Select Add->POU.... 3. Define a new FB to be created, which will later act as a proxy for calling C++ classes: Enter the name of the new FB: "FB_State Machine". 286 Version: 1.18.0 Twin CAT 3

## Page 287

C++-samples 4. Select Function Block, then Implements and then click on the ... button. 5. Select the interface either via the Text Search tab or the Categories tab by deselecting Structured View. 6. Select IState Machine and click on OK. Twin CAT 3 Version: 1.18.0 287

## Page 288

C++-samples ð The IState Machine interface is then listed as the interface to be implemented. 7. Select Structured Text (ST) as Method implementation language. 8. Select Structured Text (ST) as implementation language. 9. End this dialog with Open. ð You have successfully added the FB. Step 4: Adjusting the function block interface As a result of creating an FB that implements the IState Machine interface, the wizard will create an FB with corresponding methods. The FB_State Machine makes 4 methods available: • Get State • Set State • Start • Stop 1. Delete Implements IState Machine. Since the function block should act as proxy, it does not implement the interface itself. Therefore, it can be deleted. 2. Delete the methods Tc Add Ref, Tc Query Interface and Tc Release. They are not required for a proxy function block. 288 Version: 1.18.0 Twin CAT 3

## Page 289

C++-samples ð The result is: Step 5: add FB methods FB_init (Constructor) and FB_exit (Destructor) 1. Right-click on FB_State Machine in the tree and select Add / Method… Twin CAT 3 Version: 1.18.0 289

## Page 290

C++-samples 2. Add the methods FB_exit and FB_init - both with Structured Text (ST) as the implementation language. They are available as predefined name. 3. Exit the dialog in each case by clicking on Open. ð In the end, all required methods are available: Step 6: implement FB methods Now all methods have to be filled with code. 290 Version: 1.18.0 Twin CAT 3

## Page 291

C++-samples NOTICE Missing attributes lead to unexpected behavior Attribute statements in brackets represent code to be added. More precise information on the attributes is given in the PLC documentation. 1. Implement the variable declarations of the FB_Statemachine. The FB itself does not require cyclically executable code. 2. Implement the variable declarations and the code area of the method FB_exit. 3. Implement the variable declarations and the code area of the method FB_init. Twin CAT 3 Version: 1.18.0 291

## Page 292

C++-samples 4. Implement the variable declaration and the code area of the method Get State (the generated pragmas can be deleted as they are not required for a proxy FB). 5. Implement the variable declaration and the code area of the method Set State (the generated pragmas can be deleted as they are not required for a proxy FB). 6. Implement the variable declaration and the code area of the method Start (the generated pragmas can be deleted as they are not required for a proxy FB). 7. Implement the variable declaration and the code area of the method Stop (the generated pragmas can be deleted as they are not required for a proxy FB). 292 Version: 1.18.0 Twin CAT 3

## Page 293

C++-samples ð The implementation of the FB_State Machine, which acts as the proxy for calling the C++ module instance, is completed. Step 7: Calling FB in PLC The FB_State Machine is now called in the POU MAIN. This simple sample acts as follows: • Cyclic incrementation of a PLC counter n Counter • If n Counter = 500, the C++ State Machine is started with the state "1" to increment its internal C++ counter. Then read the state of C++ using Get State(). • If n Counter = 1000, the C++ state machine is set to the state "2" in order to decrement its internal C++ counter. Then read the state of C++ using Get State(). • If n Counter = 1500, the C++ State Machine is stopped. The PLC n Counter is also set to "0", so that everything starts again from the beginning. Twin CAT 3 Version: 1.18.0 293

## Page 294

C++-samples Step 8: compile PLC code 1. Right-click on the PLC project and click on Build. ð The compilation result shows "1 succeeded - 0 failed". Step 9: link PLC FB with C++ instance The benefits of all previous steps now become apparent: The PLC FB FB_State Machine can be configured with regard to linking with every instance of the C++ module State Machine. This is a very flexible and powerful method of connecting PLC and C++ modules on the machine with each other. 1. Navigate to the instance of the PLC module in the left-hand tree and select the Symbol Initialization tab on the right-hand side. ð All instances of FB_State Machine are listed; in this sample we have only defined one FB instance in POU MAIN. 294 Version: 1.18.0 Twin CAT 3

## Page 295

C++-samples 2. Select the drop-down field Value and then the C++ module instance that is to be linked to the FB instance. ð PLC and C++ module are connected to each other. Step 10: observe the execution of the two modules, PLC and C++ Following the activation of the Twin CAT configuration and the downloading and starting of the PLC code, the execution of the two codes, PLC and C++, is simple to observe: 1. After the Login and Start of the PLC project, the editor is already in online mode (left-hand side – see following illustration). 2. In order to be able to access online variables of the C++ module, activate the C++ debugging [} 73] and follow the steps in the quick start [} 61] in order to start the debugging (right-hand side of the following illustration). 15.10 Sample11a: Module communication: Method call C++ module to C++ module This article describes how Twin CAT 3 C++ modules could communicate via method calls. The method protects the data with a critical section thus the access could be initiated from different contexts / tasks. Twin CAT 3 Version: 1.18.0 295

## Page 296

C++-samples Download Here you can access the source code for this sample: https://github.com/Beckhoff/TC1300_Samples/tree/main/S11a-Mod2Mod CS 1. Using a Visual Studio with Twin CAT installed, open the project via Open Project .... 2. Configure signing for this project by switching on Twin CAT signing with a right-click on Project- >Properties->Tc Sign and configure your certificate and password if necessary. Further information on signing C++ projects can be found in the chapter Twin CAT [} 24]. 3. Select your target system. 4. Build the sample (e.g. Build->Build Solution). 5. Activate the configuration by clicking . ð The sample is ready for operation. Description The project contains three modules: • The instance of the CModule Data Provider class hosts the data and protects against access via the Retrieve and Store methods through a Critical Section. • The instance of the module class CModule Data Read reads the data from the Data Provider by calling the Retrieve method. • The instance of the module class CModule Data Write writes the data from the Data Provider by calling the Store method. The read/write instances are configured for access to the Data Provider instance, which can be seen in the Interface Pointer menu on the instance configuration. The context (task), in which the instances are to be executed, can also be configured there. In this sample two tasks are used, Task Read and Task Write. The Data Write Counter Modul parameters of CModule Data Write and Data Read Counter Modulo (CModule Data Read) enable the moment to be determined, at which the module instances initiate the access. Critical Sections are described in the SDK in Tc Rt Interfaces.h and are therefore intended for the real-time context. Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340318859.zip 15.11 Sample12: module communication: Using IO mapping This article describes how two Twin CAT 3 C++ modules could communicate via the usual IO mapping of Twin CAT 3: Two instances are linked via IO mapping and access the variable value periodically. Download Here you can access the source code for this sample: https://github.com/Beckhoff/TC1300_Samples/tree/main/S12-Mod2Mod IOMapping 1. Using a Visual Studio with Twin CAT installed, open the project via Open Project .... 2. Configure signing for this project by switching on Twin CAT signing with a right-click on Project- >Properties->Tc Sign and configure your certificate and password if necessary. Further information on signing C++ projects can be found in the chapter Twin CAT [} 24]. 3. Select your target system. 4. Build the sample (e.g. Build->Build Solution). 5. Activate the configuration by clicking . 296 Version: 1.18.0 Twin CAT 3

## Page 297

C++-samples ð The sample is ready for operation. Description Both instances are realized by means of a module class Module In To Out: The class cyclically copies its input data area Value to its output data area Value. The Front instance acts as front end for the user. An input Value is transferred to the output Value via the method cycleupdate(). This output value of Front is assigned (linked) to the input "value" of the Back instance. The Back instance copies the input Value to its output Value, which can be monitored by the user (see the following quick start steps to start debugging: Debugging a Twin CAT 3 C++ project) Ultimately, the user can define the input value of the Front instance and observe the output value of Back. Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340322187.zip 15.12 Sample13: Module communication: Method call C++ module to PLC module This article describes how a Twin CAT C++ module calls a methods of a PLC function block via the Tc COM interface. Download You can obtain the source code for this sample here: https://github.com/Beckhoff/TC1300_Samples/tree/ main/S13-Cpp To PLC 1. Using a Visual Studio with Twin CAT installed, open the project via Open Project .... 2. Configure signing for this project by switching on Twin CAT signing with a right-click on Project- >Properties->Tc Sign and configure your certificate and password if necessary. Further information on signing C++ projects can be found in the chapter Twin CAT [} 24]. 3. Select your target system. 4. Build the sample (e.g. Build->Build Solution). 5. Activate the configuration by clicking . ð The sample is ready for operation. Description This sample provides for communication from a C++ module to a function block of a PLC by means of method call. To this end a Tc COM interface is defined that is offered by the PLC and used by the C++ module. The PLC page as a provider in the process corresponds to the corresponding project of the Tc COM Sample 01 [} 315], where an PLC is considered after PLC communication. Here a Caller is now provided in C++, which uses the same interface. The PLC page adopted by Tc COM Sample 01 [} 315]. The function block registered there as Tc COM module offers the object ID allocated to it as an output variable. It is the C++ module’s task to make the offered interface of this function block accessible. ü A C++ project with a Cycle IO module is assumed. Twin CAT 3 Version: 1.18.0 297

## Page 298

C++-samples 1. In the TMC editor, create an interface pointer of the type I_Calculation with the name Calculationn). Later access occurs via this. 2. The Data Area Inputs have already been created by the module wizard with the type Input-Destination. Here in the TMC editor you create an input of the type OTCID with the name oid Provider, via which the Object ID will be linked from the PLC later. 3. All other symbols are irrelevant for the sample and can be deleted. 298 Version: 1.18.0 Twin CAT 3

## Page 299

C++-samples ð The TMC-Code-Generator prepares the code accordingly. In the header of the module some variables are created in order to carry out the methods calls later. In the actual code of the module in Cycle Update() the interface pointer is set using the object ID transmitted from the PLC. It is important that this happens in the Cycle Update() and thus in real-time context, since the PLC must first provide the function block. When this has taken place once, the methods can be called. In addition, as can be seen above, the interface pointer is cleared when the program shuts down. This happens in the Set Obj State OS method. 4. Now build the C++ project. 5. Create an instance of the module. Twin CAT 3 Version: 1.18.0 299

## Page 300

C++-samples 6. Connect the input of the C++ module to the output of the PLC. ð The project can be started. When the PLC is running, the OID is made known through the mapping to the C++ instance. Once this has occurred, the method can be called. Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340323851.zip 15.13 Sample19: Synchronous File Access This article describes how to implement a Twin CAT 3 C++ module which accesses files on the hard disk within the startup of a module, thus within the real-time environment. Download You can obtain the source code for this sample here: https://github.com/Beckhoff/TC1300_Samples/tree/ main/S19-File IOSync 1. Using a Visual Studio with Twin CAT installed, open the project via Open Project .... 2. Configure signing for this project by switching on Twin CAT signing with a right-click on Project- >Properties->Tc Sign and configure your certificate and password if necessary. Further information on signing C++ projects can be found in the chapter Twin CAT [} 24]. 3. Select your target system. 4. Build the sample (e.g. Build->Build Solution). 5. Activate the configuration by clicking . ð The sample is ready for operation. All source code that is not automatically generated by the wizard is marked with the comment start flag "// sample code" and the comment end flag "//sample code end". This allows you to search for these strings in the files to get an idea of the details. Description This sample describes file access via the Twin CAT interface ITCFile Access. The access is synchronous and can be used for reading a configuration during startup of a module, for example. 300 Version: 1.18.0 Twin CAT 3

## Page 301

C++-samples The sample contains a C++ module Tc File Test Drv with an instance of this module Tc File Test Drv_Obj1. In this sample, the file access takes place during the transition PREOP to SAFEOP, i.e. in the Set Obj State PS() method. Helper methods encapsulate file handling. First, general file information and a directory list is printed to the log device of Twin CAT 3. Then, a file %TC_TARGETPATH%Default Config.xml (normally C:\Twin CAT\3.1\Target\Default Config.xml) is copied to %TC_TARGETPATH%Default Config.xml.bak. To access the log entries, see the Error List tab of the Twin CAT 3 output window. You can set the amount of information by changing the Trace Level Max variable in the Tc File Test Drv_obj1 instance in the Parameters (Init) tab. Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340325515.zip 15.14 Sample20: File IO-Write This article describes the implementation of Twin CAT 3 C++ modules, which write (process) values to a file. The writing of the file is triggered by a deterministic cycle - the execution of File IO is decoupled (asynchronous), i.e.: the deterministic cycle continues to run and is not hindered by writing to the file. Download You can obtain the source code for this sample here: https://github.com/Beckhoff/TC1300_Samples/tree/ main/S20-File IOWrite 1. Using a Visual Studio with Twin CAT installed, open the project via Open Project .... 2. Configure signing for this project by switching on Twin CAT signing with a right-click on Project- >Properties->Tc Sign and configure your certificate and password if necessary. Further information on signing C++ projects can be found in the chapter Twin CAT [} 24]. 3. Select your target system. 4. Build the sample (e.g. Build->Build Solution). 5. Activate the configuration by clicking . ð The sample is ready for operation. Description The sample includes an instance of Tc Async Writing Module, which writes data to the Async Test.txt file in BOOTPRJPATH directory (Windows: C:\Twin CAT\3.1\Boot; Twin CAT/BSD: /usr/local/etc/Twin CAT/3.1/ Boot). Tc Async Buffer Writing Module has two buffers (m_Buffer1, m_Buffer2), which are alternately filled with current data. The member variable m_p Buffer Fill points to the buffer that is currently to be filled. Once a buffer is filled, the member variable m_p Buffer Write is set such that it points to the full buffer. These data are written to a file with the aid of Tc Fsm File Writer. Note that the file has no human-readable content, such as ASCII characters; in this sample, but binary data are written to the file. Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340328843.zip 15.15 Sample20a: File IO-Cyclic Read / Write This article is a more comprehensive sample than S20 and S19. It demonstrates cyclic read and/or write access to files from a Twin CAT 3 C++ module. Twin CAT 3 Version: 1.18.0 301

## Page 302

C++-samples Download Here you can access the source code for this sample: https://github.com/Beckhoff/TC1300_Samples/tree/main/S20a-File IO-Cyclic Read Write 1. Using a Visual Studio with Twin CAT installed, open the project via Open Project .... 2. Configure signing for this project by switching on Twin CAT signing with a right-click on Project- >Properties->Tc Sign and configure your certificate and password if necessary. Further information on signing C++ projects can be found in the chapter Twin CAT [} 24]. 3. Select your target system. 4. Build the sample (e.g. Build->Build Solution). 5. Activate the configuration by clicking . ð The sample is ready for operation. Description The sample describes how to access files for reading and/or writing using the Cycle Update method, i.e. in a cyclic manner. This sample contains the following projects and module instances. • A static library (Tc Async File Io) offers the file access. The code for the file access can be shared, therefore this code is located in a static library that is used by the driver projects. • A driver (Tc Async Buffer Reading Drv) provides two instances: ◦ Reading Module: uses the static library to read the Async Test.txt file. ◦ Write Detect Module: detects write operations and initiates read operations. • A driver (Tc Async Buffer Writing Drv) provides one instance: ◦ Write Module: uses the static library to write the Async Test.txt file. When starting the sample, the writing module begins to write data to the file located in the boot project path (Windows: C:\Twin CAT\3.1\Boot\Async Test.txt; Twin CAT/BSD: /usr/local/etc/Twin CAT/3.1/Boot/ Async Test.txt). The input variable b Disable Writing can be used to prevent writing. The objects are connected to one another: once the writing is complete, the Writing Module triggers the Detect Module of Tc Async Buffer Reading Drv. As a result of this, the Reading Module initiates a reading procedure. Observe the n Bytes Written / n Bytes Read output variables of the Writing Module / Reading Module. Over and above that, protocol messages are generated at verbose level. As before, these can be configured with the help of the Trace Level Max parameter of the module. • A driver (Tc Async File Find Drv) provides one instance ◦ File Find Module: list the files of a directory with the help of the static library. Initiate the action with the help of the input variable b Execute. The File Path parameter contains the directory whose files are to be listed (Windows: c:\Twin CAT\3.1\Boot\*; Twin CAT/BSD: /usr/local/etc/Twin CAT/3.1/ Boot/*). Observe the sequence tracking (verbose protocol level) with regard to the list of files found. Understanding the sample The project Tc Async File IO contains various classes in a static library. This library is used by driver projects for reading and writing. Each class is intended for a file access operation such as Open / Read / Write / List / Close / .... Since execution takes place in a cyclic real-time context, each operation has a status, and the class encapsulates this state machine. 302 Version: 1.18.0 Twin CAT 3

## Page 303

C++-samples As an entry point for understanding the file access, begin with the classes Tc Fsm File Reader and Tc Fsm File Writer. If too many history tracking messages occur, which hamper understanding of the sample, you can disable modules! See also Sample S19 [} 300] Sample S20 [} 301] Sample S25 [} 307] Interface ITc File Access [} 168] / Interface ITc File Access Async [} 175] Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340327179.zip 15.16 Sample22: Automation Device Driver (ADD): Access DPRAM This article describes how to implement a Twin CAT 3 C++ driver which acts as a Twin CAT Automation Device Driver (ADD) accessing the DPRAM. Download Here you can access the source code for this sample: https://github.com/Beckhoff/TC1300_Samples/tree/main/S22-ADD NOTICE Configuration details Read the configurations details below prior to the activation. 1. Open the zip file that it contains in Twin CAT 3 by clicking on Open Project …. 2. Select your target system. 3. Build the sample on your local machine (e.g. Build->Build Solution). 4. Note the actions listed on this page under Configuration. 5. Activate the configuration by clicking . ð The sample is ready for operation. Description This sample is intended to switch the Link Detect bit of the network adapter (i.e. of an CX5010) cyclically on and off. The C++ module is connected to the NOV/DP-RAM device via the Pci Device Adi interface pointer of the C++ module. Configuration To make the sample work, the hardware addresses must be configured to match your own hardware. Check the PCI configuration: Twin CAT 3 Version: 1.18.0 303

## Page 304

C++-samples To check whether the communication with NOV/DPRAM is set up correctly, use the DPRAM (Online) view: Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340343307.zip 15.17 Sample23: Structured Exception Handling (SEH) This article describes the use of Structured Exception Handling (SEH) on the basis of five variants. Download Here you can access the source code for this sample: https://github.com/Beckhoff/TC1300_Samples/tree/main/S23-SEH 304 Version: 1.18.0 Twin CAT 3

## Page 305

C++-samples 1. Using a Visual Studio with Twin CAT installed, open the project via Open Project .... 2. Configure signing for this project by switching on Twin CAT signing with a right-click on Project- >Properties->Tc Sign and configure your certificate and password if necessary. Further information on signing C++ projects can be found in the chapter Twin CAT [} 24]. 3. Select your target system. 4. Build the sample (e.g. Build->Build Solution). 5. Activate the configuration by clicking . ð The sample is ready for operation. Description The sample contains five variants that demonstrate the use of SEH in Twin CAT C++: 1. Exception in the case of a NULL-pointer access 2. Exception in the case of a NULL-pointer access with a filter 3. Exception with Finally 4. A customer-specific structured exception 5. Exception with Continue block All of these variants can be selected via a drop-down box at the instance of the C++: After selecting a variant you can also write the value at runtime by right-clicking on the first column: All variants write trace messages to illustrate the behavior, so that messages appear in Twin CAT Engineering: Twin CAT 3 Version: 1.18.0 305

## Page 306

C++-samples Understanding the sample The selection in the drop-down box is an enumeration that is used in the Cycle Update() of the module for selecting a case (switch case). As a result the variants can be considered independently of one another here: 1. Exception in the case of a NULL-pointer access Here, a PBYTE is created as NULL and used afterwards, which leads to an exception. This is intercepted by the Tc Try{} block and an output generated. 2. Exception in the case of a NULL-pointer access with a filter This variant also accesses a NULL-pointer, but in Tc Except{} it uses a method, Filter Exception(), that is also defined in the module. Reactions take place to different exceptions within the method; in this case a message is merely output. 3. Exception with Finally A NULL-pointer access takes place once again here, but this time a Tc Finally{} block is executed in every case. 4. A customer-specific structured exception By means of Tc Raise Exception() an exception is generated that is intercepted and processed by the Filter Exception() method. Since this is an exception defined in the module, the Filter Exception() method additionally outputs a further (specific) message. 5. Exception with Continue block Here too, a NULL-pointer access takes place once again with Tc Except{}; however, this time the exception is forwarded after handling in the Filter Exception() method so that the further Tc Except{} also handles the exception. Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340344971.zip 15.18 Sample24: Semaphores This article describes the use of semaphores. Download Here you can access the source code for this sample: https://github.com/Beckhoff/TC1300_Samples/tree/main/S24-Semaphores 1. Open the zip file that it contains in Twin CAT 3 by clicking on Open Project …. 2. Select your target system. 3. Build the sample on your local machine (e.g. Build->Build Solution). 4. Note the actions listed on this page under Configuration. 5. Activate the configuration by clicking . ð The sample is ready for operation. 306 Version: 1.18.0 Twin CAT 3

## Page 307

C++-samples Description The sample contains a "Large Obj Pool", which contains two "Large Obj" for processing by the "Large Obj Processors". The "Large Obj Processors" are controlled by different tasks with different priorities that run on different CPU cores. In the info data area they count how often processing could be carried out ("Info- >Processed Obj Count") and how often no object was available for processing within the delay time ("Info- >Take Obj Failed Count"). Understanding the sample The Large Obj Pool is initialized in the PS transition by the Init Pool() method with two Large Obj (defined by the parameter "Obj Count"). The pool essentially offers two methods, which are used by the "Large Obj Processors": • Take Obj() returns a Large Obj if one is available. Based on a semaphore, the system waits until a timeout occurs to see if an object is made available. The objects themselves are stored in a map. Access to the map is protected by a Critical Section. • Return Obj() provides a processed object to the pool for further processing. In its Cycle Update() Large Obj Processor uses Take Obj() from the pool to obtain a Large Obj for processing. If this is successful, processing is simulated via the help function Consume Time() before the Large Obj is returned to the pool via Return Obj. Processing of all Large Obj must be complete before the system can be shut down. This is achieved by the Large Obj Pool informing the Twin CAT system via Tc Try Lock Op State() and Tc Release Op State() that an object is being processed. As long as the stored counter is not 0, the Tc COM object "Pool" is reset and only shut down later by the Op->Safe Op transition. Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10343761419.zip 15.19 Sample25: Static Library This article describes the implementation and use of a module of a static Twin CAT 3 C++ library. Download Here you can access the source code for this sample: https://github.com/Beckhoff/TC1300_Samples/tree/main/S25-Static Library 1. Using a Visual Studio with Twin CAT installed, open the project via Open Project .... 2. Configure signing for this project by switching on Twin CAT signing with a right-click on Project- >Properties->Tc Sign and configure your certificate and password if necessary. Further information on signing C++ projects can be found in the chapter Twin CAT [} 24]. 3. Select your target system. 4. Build the sample (e.g. Build->Build Solution). Twin CAT 3 Version: 1.18.0 307

## Page 308

C++-samples 5. Activate the configuration by clicking . ð The sample is ready for operation. Description The sample contains two projects – the Driver Using Static Lib project uses the static content of the Static Lib project. Static Lib: On the one hand, Static Lib offers the function Compute Something in the Static Function.h/.cpp. On the other hand an interface ISample Interface is defined (see TMCEditor) and implemented in the Multiplication Class. Driver Using Static Lib: In the Cycle Update method of the Module Using Static Lib, both the class and the function of Static Lib is used. Understanding the sample Follow the steps below to create and use a static library. Manual recompilation Note that Visual Studio does not automatically recompile the static library during driver development. Do that manually. ü During development of a C++ project use the Twin CAT Static Library Project template for creating a static library. ü For the following steps use the Edit dialog of Visual Studio, so that afterwards % (Addtitional Include Directories) or %(Additional Dependencies) is used. 1. In the driver add the directory of the static library to the compiler under Additional Include Directories. 308 Version: 1.18.0 Twin CAT 3

## Page 309

C++-samples 2. Add this as an additional dependency for the linker in the driver, which uses the static library. Open the project properties of the driver and add the static library: Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340346635.zip 15.20 Sample26: Order of execution in a task This article describes the determination of the task execution order if more than one module is assigned to a task. Download Here you can access the source code for this sample: https://github.com/Beckhoff/TC1300_Samples/tree/main/S26-Sort Order 1. Using a Visual Studio with Twin CAT installed, open the project via Open Project .... 2. Configure signing for this project by switching on Twin CAT signing with a right-click on Project- >Properties->Tc Sign and configure your certificate and password if necessary. Further information on signing C++ projects can be found in the chapter Twin CAT [} 24]. 3. Select your target system. 4. Build the sample (e.g. Build->Build Solution). 5. Activate the configuration by clicking . ð The sample is ready for operation. Description The sample contains the Sort Order module, which is instanced twice. The sort order determines the execution order, which can be configured via the Twin CAT Module Instance Configurator [} 133]. For example, the Cycle Update method tracks the object name and ID along with the sort order of this module. On the console window you can see the order of execution: In the sample, one instance is configured with Sort Order 150 and one with 170, while both instances are assigned to a task. Twin CAT 3 Version: 1.18.0 309

## Page 310

C++-samples Understanding the sample ü A Tc COM C++ module with cyclic IO. 1. The module requires a context-based parameter Sort order of task, which will automatically select PID_Ctx_Task Sort Order as name. Note that the parameter must be an alias (specification) of data type UDINT: 2. Start the TMC Code Generator in order to obtain the standard implementation. 3. Since the code is modified in the next step, disable the code generation for this parameter now. 4. Make sure you accept the changes before restarting the TMC Code Generator: Take a look at the CPP module (Sort Order Module.cpp in the sample). The instance of the smart pointer of the cyclic caller includes information data, including a field for the sorting order. The parameter value is stored in this field. /////////////////////////////////////////////////////////////////////////////// // Set parameters of CSort Order Module BEGIN_SETOBJPARA_MAP(CSort Order Module) SETOBJPARA_DATAAREA_MAP() ///<Auto Generated Content id="Set Object Parameter Map"> SETOBJPARA_VALUE(PID_Tc Trace Level, m_Trace Level Max) SETOBJPARA_ITFPTR(PID_Ctx_Task Oid, m_sp Cyclic Caller) ///</Auto Generated Content> SETOBJPARA_TYPE_CODE(PID_Ctx_Task Sort Order, ULONG, m_sp Cyclic Caller. Get Info()- >sort Order=*p) //ADDED //generated code: SETOBJPARA_VALUE(PID_Ctx_Task Sort Order, m_Task Sort Order Context1Parameter) END_SETOBJPARA_MAP() /////////////////////////////////////////////////////////////////////////////// // Get parameters of CSort Order Module BEGIN_GETOBJPARA_MAP(CSort Order Module) GETOBJPARA_DATAAREA_MAP() ///<Auto Generated Content id="Get Object Parameter Map"> GETOBJPARA_VALUE(PID_Tc Trace Level, m_Trace Level Max) GETOBJPARA_ITFPTR(PID_Ctx_Task Oid, m_sp Cyclic Caller) ///</Auto Generated Content> GETOBJPARA_TYPE_CODE(PID_Ctx_Task Sort Order, ULONG, *p=m_sp Cyclic Caller. Get Info()- >sort Order) //ADDED //generated code: GETOBJPARA_VALUE(PID_Ctx_Task Sort Order, m_Task Sort Order Context1Parameter) END_GETOBJPARA_MAP() 5. In this sample the object name, ID and sort order are tracked cyclically: 310 Version: 1.18.0 Twin CAT 3

## Page 311

C++-samples // TODO: Add your cyclic code here m_counter+=m_Inputs. Value; m_Outputs. Value=m_counter; m_Trace. Log(tl Always, FNAMEA "I am '%s' (0x%08x) w/ Sort Order %d ", this->Tc Get Object Name(), this->Tc Get Object Id() , m_sp Cyclic Caller. Get Info()->sort Order); //ADDED 6. The sorting order can also be transferred as the fourth parameter of the method ITc Cyclic Caller::Add Module(), which is used in CModule A::Add Module To Caller(). 7. Allocate a task with a long cycle interval (e.g. 1000 ms) to the instances of this module, in order to limit the tracking messages sent to the Twin CAT Engineering system. 8. Assign a different sorting order to each instance via the Twin CAT Module Instance Configurator [} 133]: Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340348299.zip 15.21 Sample30: Timing Measurement This article describes how to implement a Twin CAT 3 C++ module which contains time measurement functionalities. Download Here you can access the source code for this sample: https://github.com/Beckhoff/TC1300_Samples/tree/main/S30-Timing 1. Using a Visual Studio with Twin CAT installed, open the project via Open Project .... 2. Configure signing for this project by switching on Twin CAT signing with a right-click on Project- >Properties->Tc Sign and configure your certificate and password if necessary. Further information on signing C++ projects can be found in the chapter Twin CAT [} 24]. 3. Select your target system. 4. Build the sample (e.g. Build->Build Solution). 5. Activate the configuration by clicking . ð The sample is ready for operation. Description This sample exclusively deals with time measurement such as • Querying the task cycle time in nanoseconds • Querying the task priority • Querying the time when the task cycle starts at intervals of 100 nanoseconds since January 1, 1601 (UTC) • Querying the distributed clock time when the task cycle starts in nanoseconds since January 1, 2000 Twin CAT 3 Version: 1.18.0 311

## Page 312

C++-samples • Querying the time when the method is called at intervals of 100 nanoseconds since January 1, 1601 (UTC) See also ITc Task interface [} 188] Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340349963.zip 15.22 Sample31: Functionblock TON in Twin CAT3 C++ This article describes the implementation of a behavior in C++, which is comparable with a TON function block of PLC / IEC-61131-3. Source Here you can access the source code for this sample: https://github.com/Beckhoff/TC1300_Samples/tree/main/S31-CTON 1. Using a Visual Studio with Twin CAT installed, open the project via Open Project .... 2. Configure signing for this project by switching on Twin CAT signing with a right-click on Project- >Properties->Tc Sign and configure your certificate and password if necessary. Further information on signing C++ projects can be found in the chapter Twin CAT [} 24]. 3. Select your target system. 4. Build the sample (e.g. Build->Build Solution). 5. Activate the configuration by clicking . ð The sample is ready for operation. Description The behavior of this module is comparable with a module that was created with the Cyclic IO wizard. m_input. Value is added to m_Output. Value. As opposed to the Cyclic IO module, this module only adds m_input. Value to m_Output. Value if the defined time interval (1000 ms) has elapsed. This is achieved with the help of a CTON class, which is comparable with the TON function block of PLC / 61131. Understanding the sample The C++ class CTON (TON.h/.cpp) provides the behavior of a TON function block of PLC / 61131. The Update() method is comparable with the rump of the function block, which has to be called regularly. The Update() method contains two "in" parameters: • IN1: Starts the timer switch on a rising edge and resets the timer switch on a falling edge. • PT: Describes the time to wait before Q is set. And two "out" parameters: • Q: TRUE if PT exhibited a rising edge seconds after IN. • ET: Designates the elapsed time. Beyond that, ITc Task must be provided to query the time base. See also Sample30: Timing Measurement [} 311] 312 Version: 1.18.0 Twin CAT 3

## Page 313

C++-samples ITc Task interface [} 188] Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340351627.zip 15.23 Sample35: Access Ethernet This article describes the implementation of Twin CAT 3 C++ modules that communicate directly via an Ethernet card. The sample code queries a hardware address (MAC) from a communication partner by means of the cyclic transmission and reception of ARP packets. The sample illustrates the direct access to the Ethernet card. The TF6311 TCP/UDP RT function provides access to Ethernet cards on the basis of TCP and UDP, so that an implementation of a network stack is not necessary on the basis of this sample. Download Here you can access the source code for this sample: https://github.com/Beckhoff/TC1300_Samples/tree/main/S35-Access Ethernet 1. Open the zip file that it contains in Twin CAT 3 by clicking on Open Project …. 2. Select your target system. 3. Build the sample on your local machine (e.g. Build->Build Solution). 4. Note the actions listed on this page under Configuration. 5. Activate the configuration by clicking . ð The sample is ready for operation. Description The sample contains an instance of the Tc Ethernet Sample module, which sends and received ARP packets for the purpose of determining the remote hardware address (MAC). The Cycle Update method implements a rudimentary state machine for sending ARP packets and waiting for a response with a timeout. The sample uses two Ethernet components from Twin CAT: 1. An ITc Ethernet Adapter (instance name in the sample is m_sp Ethernet Adapter) represents an RT Ethernet adapter. It enables access to the adapter parameters such as hardware MAC address, link speed and link errors. It can be used to send Ethernet frames and enables a module instance to register itself as an Itc Io Eth Protocol via the register Protocol method. 2. The ITc IOo Eth Protocol is extended by the sampling module, which ensures that a notification takes place via the ITc Ethernet Adapter in case of Ethernet events. Configuration The downloaded Twin CAT project must be configured for execution in a network environment. Please carry out the following steps: ü This sample demands the use of the Twin CAT driver by the Ethernet card. Twin CAT 3 Version: 1.18.0 313

## Page 314

C++-samples 1. Start Tc Rte Install.exe either from the XAE via the menu Twin CAT->Show Realtime Ethernet compatible devices… or from the hard disk on the XAR systems. 2. You may have to install and activate the driver with the help of the buttons. 3. Twin CAT must know which Ethernet card is to be used. Open the project in XAE and click on Select I/ O / Devices / Device 1 (RT-Ethernet Adapter). 4. Click on the Adapter tab and select the adapter with Search. 5. Tc Ethernet Sample_Obj1 must be configured. Open the instance window and set the following values: Parameter (Init): Sender Ip Address (IP of the network adapter configured in step 2) Parameter (Init): Target Ip Address (IP of target host) Interface pointer: Ethernet Adapter must point to I/O / Devices / Device 1 (RT-Ethernet Adapter). Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340353291.zip 15.24 Sample37: Archive data The sample Tc COM Object Archive describes restoration and saving of an object state during initialization and deinitialization. Twin CAT supports retain data Twin CAT also supports retain data, in order to utilize the NOVRAM of a device to make data persistent. Download Here you can access the source code for this sample: https://github.com/Beckhoff/TC1300_Samples/tree/main/S37-Archive Data 1. Using a Visual Studio with Twin CAT installed, open the project via Open Project .... 2. Configure signing for this project by switching on Twin CAT signing with a right-click on Project- >Properties->Tc Sign and configure your certificate and password if necessary. Further information on signing C++ projects can be found in the chapter Twin CAT [} 24]. 3. Select your target system. 4. Build the sample (e.g. Build->Build Solution). 5. Activate the configuration by clicking . ð The sample is ready for operation. 314 Version: 1.18.0 Twin CAT 3

## Page 315

C++-samples Description The sample Tc COM object archive describes restoration and saving of an object state during initialization and deinitialization. The state of the sample class Cmodule Archive corresponds to the value of the counter CModule Archive::m_counter. During the transition from PREOP to SAFEOP, i.e. when calling the method CModule Archive::Set Obj State PS(), the object archive server (ITCom Obj Archive Server) is used to create an object archive for reading, which is accessed via the interface ITCom Archive Op. This interface provides overloads from operator>>() in order to read them in the archive. During the transition from SAFEOP to PREOP, i.e. when calling the method CModule Archive::Set Obj State SP(), the TCOM object archive server is used to create an object archive for writing, which is accessed via the interface ITCom Archive Op. This interface provides overloads from operator<<() in order to write them in the archive. The interface used here was not developed for the real-time context [} 47], therefore the interface can only be used in the non-real-time context. Documents about this 2 https://infosys.beckhoff.com/content/1033/TC3_C/Resources/10340367755.zip 15.25 Tc COM samples Modules can communicate between PLC and C++. The description therefore covers handling of C++ modules on the PLC side and handling of the PLC on the C++ side. The Tc COM samples for communication with the PLC are shown here. The Tc COM_Sample01 sample [} 315] shows how Tc COM communication can take place between two PLCs. In the process functionalities from one PLC are directly called up from the other PLC. The Tc COM_Sample02 sample [} 325] shows how a PLC application can use functionalities of an existing instance of a Twin CAT C++ class. Algorithms written in C++ (or MATLAB®) can thus be easily used in the PLC. Although in the event of the use of an existing Twin CAT C++ module the Twin CAT C++ license is required on the target system, a C++ development environment is not necessary on the target system or on the development computer. The Tc COM_Sample03 sample [} 329] shows how a PLC application uses functionalities of a Twin CAT C++ class by generating an instance of C++ class at the same time. In comparison to the previous sample this can offer increased flexibility. 15.25.1 Tc COM_Sample01_Plc To Plc This sample describes a Tc COM communication between two PLCs. Functionalities provided by a function block in the first PLC (also called "provider" in the sample), are called from the second PLC (also called "caller" in the sample). To this end it is not necessary for the function block or its program code to be copied. Instead the program works directly with the object instance in the first PLC. Both PLCs must be in a Twin CAT runtime. In this connection a function block offers its methods system-wide via a globally defined interface and represents itself a Tc COM object. As is the case with every Tc COM object, such a function block is also listed at runtime in the Tc COM Objects node. Twin CAT 3 Version: 1.18.0 315

## Page 316

C++-samples The procedure is explained in the following sub-chapters: • Creating an FB in the first PLC that provides its functionality globally [} 316] • Creating an FB in the second PLC that, as a simple proxy, also offers this functionality there [} 320] • Execution of the sample project [} 323] Downloading the sample: https://infosys.beckhoff.com/content/1033/TC3_C/Resources/2343046667.zip Race Conditions in the case of Multi-Tasking (Multi-Threading) use The function block that provides its functionality globally is instantiated in the first PLC. It can be used there like any function block. In addition, if it is used from a different PLC (or, for example, from a C++ module), make sure that the methods offered are thread-safe, as the various calls could take place simultaneously from different task contexts or mutually interrupt one another, depending on the system configuration. In this case the methods must not access member variables of the function block or global variables of the first PLC. If this should be absolutely necessary, prevent simultaneous access. Observe the function Test And Set() from the Tc2_System library. System requirements Twin CAT version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64, ARM Tc3_Module 15.25.1.1 Creating an FB in the first PLC which provides its functionality globally 1. Create a PLC and a new function block (FB) (in this case: FB_Calculation). Derive the function block from the Tc Base Module Registered class so that an instance of the function block is available not only in the same PLC but also in a second one. As an alternative, you can modify an FB in an existing PLC. 316 Version: 1.18.0 Twin CAT 3

## Page 317

C++-samples 2. The function block must provide its functionality through methods. These are defined in a global interface whose type is known system-wide and regardless of the programming language. To create a global interface, open the context menu in the “Interface” tab of System Properties and select “New”. ð The TMC Editor opens to help create a global interface. 3. Enter the name (in this case: I_Calculation) and append the desired methods. The interface is automatically derived from ITc Unknown to comply with the Twin CAT Tc COM module concept. Twin CAT 3 Version: 1.18.0 317

## Page 318

C++-samples 4. Enter the names of the methods (in this case: Addition() and Subtraction()) and select HRESULT as return data type. This return type is mandatory if this type of Tc COM communication is to be implemented. 5. Finally, specify the method parameters and close the TMC Editor. 6. Now implement the I_Calculation interface in the FB_Calculation function block and append the “c+ +_compatible” attribute. 318 Version: 1.18.0 Twin CAT 3

## Page 319

C++-samples 7. Choose the “Implement interfaces...” option in the context menu of the function block in order to obtain the methods belonging to this interface. 8. Delete the two methods Tc Add Ref() and Tc Release() because the existing implementation of the base class is to be used. Twin CAT 3 Version: 1.18.0 319

## Page 320

C++-samples 9. Create the FB_reinit() method for the FB_Calculation function block and call the basic implementation. This ensures that the FB_reinit() method of the base class will run during the online change. This is imperative. 10. Implement the Tc Query Interface() method of the Interface ITc Unknown [} 191]. This method enables other Twin CAT components to obtain an interface pointer to an instance of this function block, allowing them to perform method calls. Calling Tc Query Interface is successful if the function block or its base class provides the interface requested by means of iid (Interface ID). In this case, the interface pointer that was handed over is allocated an address to the function block with its type changed and the reference counter is also incremented using Tc Add Ref(). 11. Add the corresponding code to the Addition() and Subtraction() methods to provide the functionality: n Res := n In1 + n In2 and n Res := n In1 - n In2 12. Add one or more instances of this function block to the MAIN program block or to a global variable list. ð The implementation in the first PLC is complete. ð After compiling the PLC, the object ID of the Tc COM object representing the FB_Calculation instance is available as an outlet in the process image. 15.25.1.2 Creating an FB which likewise offers this functionality there as a simple proxy in the second PLC, 1. Create a PLC and append a new function block there. 320 Version: 1.18.0 Twin CAT 3

## Page 321

C++-samples ð This proxy function block should provide the functionality which was programmed in the first PLC. It does this via an interface pointer of the type of the global interface I_Calculation. 2. In the declaration part of the function block declare as an output an interface pointer to the global interface which later provides the functionality outward. 3. In addition create the object ID and the interface ID as local member variables. While the interface ID is already available via a global list, the object ID is assigned via a link in the process image. Twin CAT 3 Version: 1.18.0 321

## Page 322

C++-samples 4. Implement the PLC proxy function block. First add the Get Interface Pointer() method to the function block. The interface pointer is fetched to the specified interface of the specified Tc COM object with the help of the FW_Obj Mgr_Get Object Instance() function. This will only be executed if the object ID is valid and the interface pointer has not already been allocated. The object itself increments a reference counter. 5. It is imperative to release the used reference again. To this end call the FW_Safe Release() function in the FB_exit destructor of the function block. ð This completes the implementation of the Proxy function block. 6. Instantiate the Proxy function block FB_Calculation Proxy in the application and call its method Get Interface Pointer() to get a valid interface pointer. An instance of the proxy block is declared in the application to call the methods provided via the 322 Version: 1.18.0 Twin CAT 3

## Page 323

C++-samples interface. The calls themselves take all place over the interface pointer defined as output of the function block. As is typical for pointers a prior null check must be made. Then the methods can be called directly, also via Intellisense. ð The sample is ready for testing. Order irrelevant The sequence in which the two PLCs start later is irrelevant in this implementation. 15.25.1.3 Execution of the sample project 1. Select the destination system and compile the project. 2. Enable the Twin CAT configuration and execute a log-in and start both PLCs. ð In the online view of the PLC application “Provider” the generated object ID of the C++ object can be seen in the PLC function block FB_Calculation. The project node “Tc COM Objects” keeps the generated object with its object ID and the selected name in its list. Twin CAT 3 Version: 1.18.0 323

## Page 324

C++-samples ð In the online view of the PLC application “Caller” the Proxy function block has been allocated the same object ID via the process image. The interface pointer has a valid value and the methods are executed. 324 Version: 1.18.0 Twin CAT 3

## Page 325

C++-samples 15.25.2 Tc COM_Sample02_Plc To Cpp This sample describes a Tc COM communication between PLC and C++. In this connection a PLC application uses functionalities of an existing instance of a Twin CAT C++ class. In this way own algorithms written in C++ can be used easily in the PLC. Although in the event of the use of an existing Twin CAT C++ module the Twin CAT C++ license is required on the target system, a C++ development environment is not necessary on the target system or on the development computer. An already built C++ module provides one or more classes whose interfaces are deposited in the TMC description file and thus are known in the PLC. The procedure is explained in the following sub-chapters: 1. Instantiating a Twin CAT C++ class as a Twin CAT Tc COM Object [} 325] 2. Creating an FB in the PLC, which as a simple wrapper offers the functionality of the C++ object [} 326] 3. Execution of the sample project [} 328] Download the sample: https://infosys.beckhoff.com/content/1033/TC3_C/Resources/2343048971.zip System requirements Twin CAT version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64 Tc3_Module 15.25.2.1 Instantiating a Twin CAT++ class as a Twin CAT Tc COM Object The binary Twin CAT C++ project must be available on the engineering system so that it can be transferred to the target system together with the PLC project during activation. Twin CAT offers a deployment mechanism for the distribution between engineering systems, which is described at Versioned C++ projects [} 52]. (This sample includes in the download the corresponding TMX, because Twin CAT places them automatically in the archive, if the Class Factory is used.) 1. Open a Twin CAT project or create a new project. 2. Add an instance of Class CIncrement Module in the solution under the Tc COM Objects node. Creation of the C++ modules In the documentation for Twin CAT C++ [} 12] there is a detailed explanation on how C++ modules for Twin CAT are created. Twin CAT 3 Version: 1.18.0 325

## Page 326

C++-samples 15.25.2.2 Creating an FB in the PLC that, as a simple proxy, offers the functionality of the C++ object 1. Create a PLC and append a new function block there. This Proxy function block should provide the functionality that was programmed in C++. It is able to do this via an interface pointer that was defined from the C++ class and is known in the PLC due to the TMC description file. 2. In the declaration part of the function block declare as an output an interface pointer to the interface which later provides the functionality outward. 3. Create the object ID and the interface ID as local member variables. While the interface ID is already available via a global list, the object ID is allocated via the Twin CAT symbol initialization. The Tc Init Symbol attribute ensures that the variable appears in a list for external symbol initialization. The object ID of the created C++ object should be allocated. 326 Version: 1.18.0 Twin CAT 3

## Page 327

C++-samples ð The object ID is displayed upon selection of the object under the Tc COM Objects node. Provided the Tc Init Symbol attribute was used, the list of symbol initializations is located in the node of the PLC instance in the Symbol Initialization tab. 4. Here, assign an existing object ID to the symbol name of the variable by drop-down. This value is assigned when the PLC is downloaded so it can be defined prior to the PLC run-time. New symbol initializations or changes are accordingly entered with a new download of the PLC. As an alternative, the passing of the object ID could also be implemented by means of process image linking as implemented in the first sample (Tc COM_Sample01_Plc To Plc [} 315]). 5. Implement the PLC Proxy function block. First the FB_init constructor method is added to the function block. For the case that it is no longer an Online Change but rather the initialization of the function block, the interface pointer to the specified Twin CAT 3 Version: 1.18.0 327

## Page 328

C++-samples interface of the specified Tc COM object is obtained with the help of the function FW_Obj Mgr_Get Object Instance(). In this connection the object itself increments a reference counter. 6. It is imperative to release the used reference again. To this end call the FW_Safe Release() function in the FB_exit destructor of the function block. ð This completes the implementation of the Proxy function block. 7. Declare an instance of the Proxy function block to call the methods provided via the interface in the application. The calls themselves take all place over the interface pointer defined as output of the function block. As is typical for pointers a prior null check must be made. Then the methods can be called directly, also via Intellisense. ð The sample is ready for testing. 15.25.2.3 Execution of the sample project 1. Select the target system and compile the project. 2. Enable the Twin CAT configuration, then log in and start the PLC. 328 Version: 1.18.0 Twin CAT 3

## Page 329

C++-samples 3. This C++ Tc COM module requires Windows Test Mode. Activate this to use the module and thus the example. 4. When activating the Twin CAT configuration for the first time, the test certificate must be accepted: ð In the online view of the PLC application, the assigned object ID of the C++ object is indicated in the PLC Proxy function block. The interface pointer has a valid value and the method will be executed. 15.25.3 Tc COM_Sample03_Plc Creates Cpp Just like Sample02, this sample describes a Tc COM communication between PLC and C++. To this end a PLC application uses functionalities of a Twin CAT C++ class. The required instances of this C++ class will be created by the PLC itself in this sample. In this way own algorithms written in C++ can be used easily in the PLC. Although in the event of the use of an existing Twin CAT C++ driver the Twin CAT C++ license is required on the destination system, a C++ development environment is not necessary on the destination system or on the development computer. An already built C++ driver provides one or more classes whose interfaces are deposited in the TMC description file and thus are known in the PLC. The procedure is explained in the following sub-chapters: Twin CAT 3 Version: 1.18.0 329

## Page 330

C++-samples 1. Provision of a Twin CAT C++ driver and its classes [} 330] 2. Creating an FB in the PLC that creates the C++ object and offers its functionality [} 331] 3. Execution of the sample project [} 333] Downloading the sample: https://infosys.beckhoff.com/content/1033/TC3_C/Resources/2343051531.zip System requirements Twin CAT version Hardware Libraries to be integrated Twin CAT 3.1, Build 4020 x86, x64 Tc3_Module 15.25.3.1 Provision of the binary C++ project (TMX) and its classes The binary Twin CAT C++ project must be available on the engineering system so that it can be transferred to the target system together with the PLC project during activation. Twin CAT offers a deployment mechanism for distribution between engineering systems, which is described at Versioned C++ Projects [} 52]. (This sample includes in the download the corresponding TMX, because Twin CAT places them automatically in the archive, if the Class Factory is used.) Open a Twin CAT project or create a new project. 1. Select the required C++ driver in the Solution under the Tc COM Objects node in the Class Factories tab. The checkbox can also be set automatically by Twin CAT if you implement this accordingly (as in the sample here). ð This ensures that the driver is transferred and loaded on the target system when Twin CAT is started. Creation of the binary C++ project The documentation for Twin CAT C++ [} 12] explains in detail how to create the TMX. For Sample03 it should be noted that Twin CAT C++ modules whose classes are to be dynamically instantiated must be defined as "Twin CAT Module Class for RT Context". The C++ wizard offers a special template for this purpose. Furthermore, this sample uses a Twin CAT C++ class that does without Tc COM initialization data and without Tc COM parameters. 330 Version: 1.18.0 Twin CAT 3

## Page 331

C++-samples 15.25.3.2 Creating an FB in the PLC that creates the C++ object and offers its functionality 1. Create a PLC and append a new function block there. This Proxy function block should provide the functionality that was programmed in C++. It manages this via an interface pointer that was defined by C++ and is known in the PLC due to the TMC description file. 2. In the declaration part of the function block declare as an output an interface pointer to the interface (IIncrement) which later provides the functionality outward. 3. Create a library ID, class ID, and the interface ID as member variables, as shown in the previous step. While the interface ID is already available via a global list, the library ID and the class ID, provided they are not yet supposed to be known, are determined by other means. One possible way to do this is to create an instance temporarily and take the information from the dialog before it can be deleted again: Twin CAT 3 Version: 1.18.0 331

## Page 332

C++-samples 4. Add the FB_init constructor method to the PLC Proxy function block. For the case, that it is not an online change but rather the initialization of the function block, a new Tc COM object (Class instance of the specified class) is created and the interface pointer to the specified interface is obtained. First, the versioned class ID is calculated from the library ID and the class ID using the F_Get Class Id Versioned() method. Then the used FW_Obj Mgr_Create And Init Instance() function is also given the name and the target state of the Tc COM object. These two parameters are declared here as input parameters of the FB_init method, whereby they are to be specified in the instantiation of the Proxy function block. The Twin CAT C++ class to be instantiated does without Tc COM initialization data and without Tc COM parameters. With this function call the object itself counts up a reference counter. 5. It is imperative to release the used reference again and to delete the object, provided it is no longer being used. To this end call the FW_Obj Mgr_Delete Instance() function in the FB_exit destructor of the function block. ð This completes the implementation of the Proxy function block. 6. Declare an instance of the Proxy function block to call the methods provided via the interface in the application. The calls themselves take all place over the interface pointer defined as output of the function block. As is typical for pointers a prior null check must be made. Then the methods can be called directly, also via Intellisense. ð The sample is ready for testing. 332 Version: 1.18.0 Twin CAT 3

## Page 333

C++-samples 15.25.3.3 Execution of the sample project 1. Select the target system and compile the project. 2. Enable the Twin CAT configuration, then log in and start the PLC. 3. This C++ Tc COM module requires Windows Test Mode. Activate this to use the module and thus the example. 4. When activating the Twin CAT configuration for the first time, the test certificate must be accepted: ð In the online view of the PLC application, the desired Tc COM object name is indicated in the PLC Proxy function block. The project node Tc COM objects contains the generated object with the generated ID and the desired name in its list. The interface pointer has a valid value and the method will be executed. Twin CAT 3 Version: 1.18.0 333

## Page 334

Appendix 16 Appendix • The ADS Return Codes [} 334] are important across Twin CAT 3, particularly if ADS communication [} 194] itself is implemented. • The Retain data [} 338] (in NOVRAM memory) can be used in a similar way from the PLC and also C+ +. • In addition to the Tc COM Module [} 38] concept, the Twin CAT 3 type system is an important basis for understanding. • The following pages originate from the documentation for the Automation Interface. When using the Automation Interface please refer to the dedicated documentation. ◦ Creating and handling C++ projects and modules [} 341] ◦ Creating and handling Tc COM modules [} 344] 16.1 ADS Return Codes Grouping of error codes: Global error codes: 0x0000 [} 334]... (0x9811_0000 ...) Router error codes: 0x500 [} 335]... (0x9811_0500 ...) General ADS errors: 0x700 [} 335]... (0x9811_0700 ...) RTime error codes: 0x1000 [} 337]... (0x9811_1000 ...) Global error codes 334 Version: 1.18.0 Twin CAT 3

## Page 335

Appendix Hex Dec HRESULT Name Description 0x0 0 0x98110000 ERR_NOERROR No error. 0x1 1 0x98110001 ERR_INTERNAL Internal error. 0x2 2 0x98110002 ERR_NORTIME No real time. 0x3 3 0x98110003 ERR_ALLOCLOCKEDMEM Allocation locked – memory error. 0x4 4 0x98110004 ERR_INSERTMAILBOX Mailbox full – the ADS message could not be sent. Reducing the number of ADS messages per cycle will help. 0x5 5 0x98110005 ERR_WRONGRECEIVEHMSG Wrong HMSG. 0x6 6 0x98110006 ERR_TARGETPORTNOTFOUND Target port not found – ADS server is not started, not reachable or not installed. 0x7 7 0x98110007 ERR_TARGETMACHINENOTFOUND Target computer not found – AMS route was not found. 0x8 8 0x98110008 ERR_UNKNOWNCMDID Unknown command ID. 0x9 9 0x98110009 ERR_BADTASKID Invalid task ID. 0x A 10 0x9811000A ERR_NOIO No IO. 0x B 11 0x9811000B ERR_UNKNOWNAMSCMD Unknown AMS command. 0x C 12 0x9811000C ERR_WIN32ERROR Win32 error. 0x D 13 0x9811000D ERR_PORTNOTCONNECTED Port not connected. 0x E 14 0x9811000E ERR_INVALIDAMSLENGTH Invalid AMS length. 0x F 15 0x9811000F ERR_INVALIDAMSNETID Invalid AMS Net ID. 0x10 16 0x98110010 ERR_LOWINSTLEVEL Installation level is too low –Twin CAT 2 license error. 0x11 17 0x98110011 ERR_NODEBUGINTAVAILABLE No debugging available. 0x12 18 0x98110012 ERR_PORTDISABLED Port disabled – Twin CAT system service not started. 0x13 19 0x98110013 ERR_PORTALREADYCONNECTED Port already connected. 0x14 20 0x98110014 ERR_AMSSYNC_W32ERROR AMS Sync Win32 error. 0x15 21 0x98110015 ERR_AMSSYNC_TIMEOUT AMS Sync Timeout. 0x16 22 0x98110016 ERR_AMSSYNC_AMSERROR AMS Sync error. 0x17 23 0x98110017 ERR_AMSSYNC_NOINDEXINMAP No index map for AMS Sync available. 0x18 24 0x98110018 ERR_INVALIDAMSPORT Invalid AMS port. 0x19 25 0x98110019 ERR_NOMEMORY No memory. 0x1A 26 0x9811001A ERR_TCPSEND TCP send error. 0x1B 27 0x9811001B ERR_HOSTUNREACHABLE Host unreachable. 0x1C 28 0x9811001C ERR_INVALIDAMSFRAGMENT Invalid AMS fragment. 0x1D 29 0x9811001D ERR_TLSSEND TLS send error – secure ADS connection failed. 0x1E 30 0x9811001E ERR_ACCESSDENIED Access denied – secure ADS access denied. Router error codes Hex Dec HRESULT Name Description 0x500 1280 0x98110500 ROUTERERR_NOLOCKEDMEMORY Locked memory cannot be allocated. 0x501 1281 0x98110501 ROUTERERR_RESIZEMEMORY The router memory size could not be changed. 0x502 1282 0x98110502 ROUTERERR_MAILBOXFULL The mailbox has reached the maximum number of possible messages. 0x503 1283 0x98110503 ROUTERERR_DEBUGBOXFULL The Debug mailbox has reached the maximum number of possible messages. 0x504 1284 0x98110504 ROUTERERR_UNKNOWNPORTTYPE The port type is unknown. 0x505 1285 0x98110505 ROUTERERR_NOTINITIALIZED The router is not initialized. 0x506 1286 0x98110506 ROUTERERR_PORTALREADYINUSE The port number is already assigned. 0x507 1287 0x98110507 ROUTERERR_NOTREGISTERED The port is not registered. 0x508 1288 0x98110508 ROUTERERR_NOMOREQUEUES The maximum number of ports has been reached. 0x509 1289 0x98110509 ROUTERERR_INVALIDPORT The port is invalid. 0x50A 1290 0x9811050A ROUTERERR_NOTACTIVATED The router is not active. 0x50B 1291 0x9811050B ROUTERERR_FRAGMENTBOXFULL The mailbox has reached the maximum number for fragmented messages. 0x50C 1292 0x9811050C ROUTERERR_FRAGMENTTIMEOUT A fragment timeout has occurred. 0x50D 1293 0x9811050D ROUTERERR_TOBEREMOVED The port is removed. General ADS error codes Twin CAT 3 Version: 1.18.0 335

## Page 336

Appendix Hex Dec HRESULT Name Description 0x700 1792 0x98110700 ADSERR_DEVICE_ERROR General device error. 0x701 1793 0x98110701 ADSERR_DEVICE_SRVNOTSUPP Service is not supported by the server. 0x702 1794 0x98110702 ADSERR_DEVICE_INVALIDGRP Invalid index group. 0x703 1795 0x98110703 ADSERR_DEVICE_INVALIDOFFSET Invalid index offset. 0x704 1796 0x98110704 ADSERR_DEVICE_INVALIDACCESS Reading or writing not permitted. Several causes are possible. For example, an incorrect password was entered when creating routes. 0x705 1797 0x98110705 ADSERR_DEVICE_INVALIDSIZE Parameter size not correct. 0x706 1798 0x98110706 ADSERR_DEVICE_INVALIDDATA Invalid data values. 0x707 1799 0x98110707 ADSERR_DEVICE_NOTREADY Device is not ready to operate. 0x708 1800 0x98110708 ADSERR_DEVICE_BUSY Device is busy. 0x709 1801 0x98110709 ADSERR_DEVICE_INVALIDCONTEXT Invalid operating system context. This can result from use of ADS blocks in different tasks. It may be possible to resolve this through multitasking synchronization in the PLC. 0x70A 1802 0x9811070A ADSERR_DEVICE_NOMEMORY Insufficient memory. 0x70B 1803 0x9811070B ADSERR_DEVICE_INVALIDPARM Invalid parameter values. 0x70C 1804 0x9811070C ADSERR_DEVICE_NOTFOUND Not found (files, ...). 0x70D 1805 0x9811070D ADSERR_DEVICE_SYNTAX Syntax error in file or command. 0x70E 1806 0x9811070E ADSERR_DEVICE_INCOMPATIBLE Objects do not match. 0x70F 1807 0x9811070F ADSERR_DEVICE_EXISTS Object already exists. 0x710 1808 0x98110710 ADSERR_DEVICE_SYMBOLNOTFOUND Symbol not found. 0x711 1809 0x98110711 ADSERR_DEVICE_SYMBOLVERSIONINVALID Invalid symbol version. This can occur due to an online change. Create a new handle. 0x712 1810 0x98110712 ADSERR_DEVICE_INVALIDSTATE Device (server) is in invalid state. 0x713 1811 0x98110713 ADSERR_DEVICE_TRANSMODENOTSUPP Ads Trans Mode not supported. 0x714 1812 0x98110714 ADSERR_DEVICE_NOTIFYHNDINVALID Notification handle is invalid. 0x715 1813 0x98110715 ADSERR_DEVICE_CLIENTUNKNOWN Notification client not registered. 0x716 1814 0x98110716 ADSERR_DEVICE_NOMOREHDLS No further handle available. 0x717 1815 0x98110717 ADSERR_DEVICE_INVALIDWATCHSIZE Notification size too large. 0x718 1816 0x98110718 ADSERR_DEVICE_NOTINIT Device not initialized. 0x719 1817 0x98110719 ADSERR_DEVICE_TIMEOUT Device has a timeout. 0x71A 1818 0x9811071A ADSERR_DEVICE_NOINTERFACE Interface query failed. 0x71B 1819 0x9811071B ADSERR_DEVICE_INVALIDINTERFACE Wrong interface requested. 0x71C 1820 0x9811071C ADSERR_DEVICE_INVALIDCLSID Class ID is invalid. 0x71D 1821 0x9811071D ADSERR_DEVICE_INVALIDOBJID Object ID is invalid. 0x71E 1822 0x9811071E ADSERR_DEVICE_PENDING Request pending. 0x71F 1823 0x9811071F ADSERR_DEVICE_ABORTED Request is aborted. 0x720 1824 0x98110720 ADSERR_DEVICE_WARNING Signal warning. 0x721 1825 0x98110721 ADSERR_DEVICE_INVALIDARRAYIDX Invalid array index. 0x722 1826 0x98110722 ADSERR_DEVICE_SYMBOLNOTACTIVE Symbol not active. 0x723 1827 0x98110723 ADSERR_DEVICE_ACCESSDENIED Access denied. Several causes are possible. For example, a unidirectional ADS route is used in the opposite direction. 0x724 1828 0x98110724 ADSERR_DEVICE_LICENSENOTFOUND Missing license. 0x725 1829 0x98110725 ADSERR_DEVICE_LICENSEEXPIRED License expired. 0x726 1830 0x98110726 ADSERR_DEVICE_LICENSEEXCEEDED License exceeded. 0x727 1831 0x98110727 ADSERR_DEVICE_LICENSEINVALID Invalid license. 0x728 1832 0x98110728 ADSERR_DEVICE_LICENSESYSTEMID License problem: System ID is invalid. 0x729 1833 0x98110729 ADSERR_DEVICE_LICENSENOTIMELIMIT License not limited in time. 0x72A 1834 0x9811072A ADSERR_DEVICE_LICENSEFUTUREISSUE Licensing problem: time in the future. 0x72B 1835 0x9811072B ADSERR_DEVICE_LICENSETIMETOLONG License period too long. 0x72C 1836 0x9811072C ADSERR_DEVICE_EXCEPTION Exception at system startup. 0x72D 1837 0x9811072D ADSERR_DEVICE_LICENSEDUPLICATED License file read twice. 0x72E 1838 0x9811072E ADSERR_DEVICE_SIGNATUREINVALID Invalid signature. 0x72F 1839 0x9811072F ADSERR_DEVICE_CERTIFICATEINVALID Invalid certificate. 0x730 1840 0x98110730 ADSERR_DEVICE_LICENSEOEMNOTFOUND Public key not known from OEM. 0x731 1841 0x98110731 ADSERR_DEVICE_LICENSERESTRICTED License not valid for this system ID. 336 Version: 1.18.0 Twin CAT 3

## Page 337

Appendix Hex Dec HRESULT Name Description 0x732 1842 0x98110732 ADSERR_DEVICE_LICENSEDEMODENIED Demo license prohibited. 0x733 1843 0x98110733 ADSERR_DEVICE_INVALIDFNCID Invalid function ID. 0x734 1844 0x98110734 ADSERR_DEVICE_OUTOFRANGE Outside the valid range. 0x735 1845 0x98110735 ADSERR_DEVICE_INVALIDALIGNMENT Invalid alignment. 0x736 1846 0x98110736 ADSERR_DEVICE_LICENSEPLATFORM Invalid platform level. 0x737 1847 0x98110737 ADSERR_DEVICE_FORWARD_PL Context – forward to passive level. 0x738 1848 0x98110738 ADSERR_DEVICE_FORWARD_DL Context – forward to dispatch level. 0x739 1849 0x98110739 ADSERR_DEVICE_FORWARD_RT Context – forward to real-time. 0x740 1856 0x98110740 ADSERR_CLIENT_ERROR Client error. 0x741 1857 0x98110741 ADSERR_CLIENT_INVALIDPARM Service contains an invalid parameter. 0x742 1858 0x98110742 ADSERR_CLIENT_LISTEMPTY Polling list is empty. 0x743 1859 0x98110743 ADSERR_CLIENT_VARUSED Var connection already in use. 0x744 1860 0x98110744 ADSERR_CLIENT_DUPLINVOKEID The called ID is already in use. 0x745 1861 0x98110745 ADSERR_CLIENT_SYNCTIMEOUT Timeout has occurred – the remote terminal is not responding in the specified ADS timeout. The route setting of the remote terminal may be configured incorrectly. 0x746 1862 0x98110746 ADSERR_CLIENT_W32ERROR Error in Win32 subsystem. 0x747 1863 0x98110747 ADSERR_CLIENT_TIMEOUTINVALID Invalid client timeout value. 0x748 1864 0x98110748 ADSERR_CLIENT_PORTNOTOPEN Port not open. 0x749 1865 0x98110749 ADSERR_CLIENT_NOAMSADDR No AMS address. 0x750 1872 0x98110750 ADSERR_CLIENT_SYNCINTERNAL Internal error in Ads sync. 0x751 1873 0x98110751 ADSERR_CLIENT_ADDHASH Hash table overflow. 0x752 1874 0x98110752 ADSERR_CLIENT_REMOVEHASH Key not found in the table. 0x753 1875 0x98110753 ADSERR_CLIENT_NOMORESYM No symbols in the cache. 0x754 1876 0x98110754 ADSERR_CLIENT_SYNCRESINVALID Invalid response received. 0x755 1877 0x98110755 ADSERR_CLIENT_SYNCPORTLOCKED Sync Port is locked. 0x756 1878 0x98110756 ADSERR_CLIENT_REQUESTCANCELLED The request was canceled. RTime error codes Hex Dec HRESULT Name Description 0x1000 4096 0x98111000 RTERR_INTERNAL Internal error in the real-time system. 0x1001 4097 0x98111001 RTERR_BADTIMERPERIODS Timer value is not valid. 0x1002 4098 0x98111002 RTERR_INVALIDTASKPTR Task pointer has the invalid value 0 (zero). 0x1003 4099 0x98111003 RTERR_INVALIDSTACKPTR Stack pointer has the invalid value 0 (zero). 0x1004 4100 0x98111004 RTERR_PRIOEXISTS The request task priority is already assigned. 0x1005 4101 0x98111005 RTERR_NOMORETCB No free TCB (Task Control Block) available. The maximum number of TCBs is 64. 0x1006 4102 0x98111006 RTERR_NOMORESEMAS No free semaphores available. The maximum number of semaphores is 64. 0x1007 4103 0x98111007 RTERR_NOMOREQUEUES No free space available in the queue. The maximum number of positions in the queue is 64. 0x100D 4109 0x9811100D RTERR_EXTIRQALREADYDEF An external synchronization interrupt is already applied. 0x100E 4110 0x9811100E RTERR_EXTIRQNOTDEF No external sync interrupt applied. 0x100F 4111 0x9811100F RTERR_EXTIRQINSTALLFAILED Application of the external synchronization interrupt has failed. 0x1010 4112 0x98111010 RTERR_IRQLNOTLESSOREQUAL Call of a service function in the wrong context 0x1017 4119 0x98111017 RTERR_VMXNOTSUPPORTED Intel® VT-x extension is not supported. 0x1018 4120 0x98111018 RTERR_VMXDISABLED Intel® VT-x extension is not enabled in the BIOS. 0x1019 4121 0x98111019 RTERR_VMXCONTROLSMISSING Missing function in Intel® VT-x extension. 0x101A 4122 0x9811101A RTERR_VMXENABLEFAILS Activation of Intel® VT-x fails. Specific positive HRESULT Return Codes: Twin CAT 3 Version: 1.18.0 337

## Page 338

Appendix HRESULT Name Description 0x0000_0000 S_OK No error. 0x0000_0001 S_FALSE No error. Example: successful processing, but with a negative or incomplete result. 0x0000_0203 S_PENDING No error. Example: successful processing, but no result is available yet. 0x0000_0256 S_WATCHDOG_TIMEOUT No error. Example: successful processing, but a timeout occurred. TCP Winsock error codes Hex Dec Name Description 0x274C 10060 WSAETIMEDOUT A connection timeout has occurred - error while establishing the connection, because the remote terminal did not respond properly after a certain period of time, or the established connection could not be maintained because the connected host did not respond. 0x274D 10061 WSAECONNREFUSED Connection refused - no connection could be established because the target computer has explicitly rejected it. This error usually results from an attempt to connect to a service that is inactive on the external host, that is, a service for which no server application is running. 0x2751 10065 WSAEHOSTUNREACH No route to host - a socket operation referred to an unavailable host. More Winsock error codes: Win32 error codes 16.2 Retain data This section describes the option to make data available even after an ordered or spontaneous system restart. The NOV-RAM of a device is used for this purpose. The EL6080 cannot be used for these retain data, because the corresponding data must first be transferred, which leads to corresponding runtimes. The following section describes the retain handler, which stores data and makes them available again, and the application of the different Twin CAT 3 programming languages. Configuring a retain device 1. The retain data are stored and made available by a retain handler, which is part of the NOV-DP-RAM device in the IO section of the Twin CAT solution. Create a NOV-RAM DP Device in the IO area of the Solution. 2. Create one or more Retain Handler below this device. Storage location: NOVRAM 338 Version: 1.18.0 Twin CAT 3

## Page 339

Appendix 3. Configure the NOV-DP RAM device. In the Generic NOV-DP-RAM Device tab, use Search... to define the area to be used. 4. An additional retain directory for the symbols is created in the Twin CAT boot directory. Using the retain handler with a PLC project In a PLC project the variables are either created in a VAR RETAIN area or identified with the attribute Tc Retain. PROGRAM MAIN VAR RETAIN l: UINT; k: UINT; END_VAR VAR {attribute 'Tc Retain':='1'} m: UINT; x: UINT; END_VAR Corresponding symbols are created after a "Build". The assignment to the retain handler of the NOV-DP-RAM device is done in column Retain Hdl. If self-defined data types (DUTs) are used as retain, the data types must be available in the Twin CAT type system. You can either use the option Convert to Global Type or you can create structures directly as STRUCT RETAIN . However, the Retain Handler then handles all occurrences of the structure. Retain data cannot be used for POUs (function blocks) as a whole. However, individual elements of a POU can be used. Twin CAT 3 Version: 1.18.0 339

## Page 340

Appendix Using the retain handler with a C++ module In a C++ module a data area of type Retain Source is created, which contains the corresponding symbols. At the instances of the C++ module, a retain handler of the NOV-DP-RAM device to be used for this data area is defined in column Retain Hdl. Conclusions When a retain handler is selected as target in the respective project, the symbols under retain handler and a mapping are created automatically after a "Build". 340 Version: 1.18.0 Twin CAT 3

## Page 341

Appendix 16.3 Creating and handling C++ projects and modules This chapter explains in-depth how to create, access and handle Twin CAT C++ projects. The following list shows all chapters in this article: • General information about C++ projects • Creating new C++ projects • Creating new module within a C++ project • Opening existing C++ projects • Creating module instances • Calling TMC Code Generator • Calling Publish Modules command • Setting C++ Project Properties • Building project General information about C++ projects C++ projects are specified by their so-called project template, which are used by the “Twin CAT C++ Project Wizard”. Inside a project multiple modules could be defined by module templates, which are used by the “Twin CAT Class Wizard”. Twin CAT-defined templates are documented in the Section C++ / Wizards [} 87]. The customer could define own templates, which is documented at the corresponding sub-section if C++ Section / Wizards [} 137]. Create C++ projects To create a new C++ project using the Automation Interface, you must navigate to the C++ node and then execute the Create Child() method with the appropriate template file as a parameter. Code snippet (C#): ITc Sm Tree Item cpp = system Manager. Lookup Tree Item("TIXC"); ITc Sm Tree Item cpp Project = cpp. Create Child("New Cpp Project", 0, "", path To Template File); Code snippet (Power Shell): $cpp = $system Manager. Lookup Tree Item("TIXC") $new Project = $cpp. Create Child("New Cpp Project", 0, "", $path To Template File) To instantiate a driver project, use "Tc Versioned Driver Wizard" as path To Template File. Twin CAT 3 Version: 1.18.0 341

## Page 342

Appendix Creating new module within a C++ project Within a C++ project usually a Twin CAT Module Wizard is used to let the wizard create a module by a template. Code snippet (C#): ITc Sm Tree Item cpp Module = cpp Project. Create Child("New Module", 1, "", path To Template File); Code snippet (Power Shell): $cpp Module = $cpp Project. Create Child("New Module", 0, "", $path To Template File); As example for instantiating a Cyclic IO module project please use "Tc Module Cyclic Caller Wizard " as path To Template File. Open existing C++ projects To open an existing C++ project using Automation Interface, you must navigate to the C++ node and then execute the Create Child() method with the path of the corresponding C++ project file as a parameter. You can use three different values as Sub Type: • 0: Copy project to Solution directory • 1: Move project to the Solution directory • 2: Use the original project location (specify "" as Name Of Project parameter) Basically, these values represent the functionalities (Yes, No, Cancel) of the following Message Box in Twin CAT XAE: Instead of the template file, you must use the path to the C++ project (or its vcxproj file) that must be added. Alternatively, you can also use a C++ project archive (tczip file). Code snippet (C#): ITc Sm Tree Item cpp = system Manager. Lookup Tree Item("TIXC"); ITc Sm Tree Item new Project = cpp. Create Child("Name Of Project", 1, "", path To Project Or Tczip File); Code snippet (Power Shell): $cpp = $system Manager. Lookup Tree Item("TIXC") $new Project = $cpp. Create Child("Name Of Project", 1, "", $path To Project Or Tczip File) Please note that C++ projects cannot be renamed, so the original project name must be specified. (cf. Renaming Twin CAT C++ projects [} 223]) Creating module instances Tc COM Modules could be created at the System -> Tc COM Modules node. Please see documentation there [} 344]. The same procedure could also be applied to the C++ project node to add Tc COM instances at that place ($new Project at the code on top of this page.). 342 Version: 1.18.0 Twin CAT 3

## Page 343

Appendix Calling the TMC Code Generator The TMC Code Generator can be called to generate the C++ code according to the changes in the TMC file or the C++ project. Code snippet (C#): string start Tmc Code Generator = @"<?xml version=""1.0"" encoding=""UTF-16""?> <Tree Item> <Cpp Project Def> <Methods> <Start Tmc Code Generator> <Active>true</Active> </Start Tmc Code Generator> </Methods> </Cpp Project Def> </Tree Item>"; cpp Project. Consume Xml(start Tmc Code Generator); Code snippet (Power Shell): $start Tmc Code Generator = @"<?xml version=""1.0"" encoding=""UTF-16""?> <Tree Item> <Cpp Project Def> <Methods> <Start Tmc Code Generator> <Active>true</Active> </Start Tmc Code Generator> </Methods> </Cpp Project Def> </Tree Item>" $cpp Project. Consume Xml($start Tmc Code Generator) Calling the Publish Modules command The publication covers the development of the project for all platforms. The compiled module is made available for export as described in the section Module handling for C++. Code snippet (C#): string publish Modules = @"<?xml version=""1.0"" encoding=""UTF-16""?> <Tree Item> <Cpp Project Def> <Methods> <Publish Modules> <Active>true</Active> </Publish Modules> </Methods> </Cpp Project Def> </Tree Item>"; cpp Project. Consume Xml(publish Modules); Code snippet (Power Shell): $publish Modules = @"<?xml version=""1.0"" encoding=""UTF-16""?> <Tree Item> <Cpp Project Def> <Methods> <Publish Modules> <Active>true</Active> </Publish Modules> </Methods> </Cpp Project Def> </Tree Item>" $cpp Project. Consume Xml($publish Modules) Setting C++ project properties C++ projects offer various options for the build and deployment process. These can be set via the Automation Interface. Code snippet (C#): string proj Props = @"<?xml version=""1.0"" encoding=""UTF-16""?> <Tree Item> <Cpp Project Def> <Boot Project Encryption>Target</Boot Project Encryption> Twin CAT 3 Version: 1.18.0 343

## Page 344

Appendix <Target Archive Settings> <Save Project Sources>false</Save Project Sources> </Target Archive Settings> <File Archive Settings> <Save Project Sources>false</Save Project Sources> </File Archive Settings> </Cpp Project Def> </Tree Item>"; cpp Project. Consume Xml(proj Props); Code snippet (Power Shell): $proj Props = @"<?xml version=""1.0"" encoding=""UTF-16""?> <Tree Item> <Cpp Project Def> <Boot Project Encryption>Target</Boot Project Encryption> <Target Archive Settings> <Save Project Sources>false</Save Project Sources> </Target Archive Settings> <File Archive Settings> <Save Project Sources>false</Save Project Sources> </File Archive Settings> </Cpp Project Def> </Tree Item>" $cpp Project. Consume Xml($proj Props) The values "None" and "Target" are valid for the Boot Project Encryption. Both other settings are "false" and "true" values. Set up project To build the project or solution, you can use the corresponding classes and methods of the Visual Studio API. 16.4 Creating and handling Tc COM modules This chapter explains how to add existing Tc COM modules to a Twin CAT configuration and parameterize them. The following topics will be briefly covered in this chapter: • Acquiring a reference to “Tc COM Objects” node • Adding existing Tc COM modules • Iterating through added Tc COM modules • Setting Create Symbol flag for parameters • Setting Create Symbol flag for Data Areas • Setting Context (Tasks) • Linking variables Acquiring a reference to “Tc COM Objects” node In a Twin CAT configuration, the “Tc COM Objects” node is located under “SYSTEM^Tc COM Objects”. Therefore you can acquire a reference to this node by using the method ITc Sys Manager::Lookup Tree Item() in the following way: Code Snippet (C#): ITc Sm Tree Item tc Com Objects = system Manager. Lookup Tree Item("TIRC^Tc COM Objects"); Code Snippet (Powershell): $tc Com Objects = $system Manager. Lookup Tree Item("TIRC^Tc COM Objects") The code above assumes that there is already a system Manager objects present in your AI code. Adding existing Tc COM modules To add existing Tc COM modules to your Twin CAT configuration, these modules need to be detectable by Twin CAT. This can be achieved by either of the following ways: • Copying Tc COM modules to folder %TWINCAT3. XDIR”\Custom Config\Modules\ 344 Version: 1.18.0 Twin CAT 3

## Page 345

Appendix • Editing %TWINCAT3. XDIR”\Config\Io\Tc Module Folders.xml to add a path to a folder of your choice and place the modules within that folder Both ways will be sufficient to make the Tc COM modules detectable by Twin CAT. A Tc COM module is being identified by its GUID or name: • This GUID can be used to add a Tc COM module to a Twin CAT configuration via the ITc Sm Tree Item::Create Child() method. The GUID can be determined in Twin CAT XAE via the properties page of a Tc COM module. Alternatively, you can also determine the GUID via the TMC file of the Tc COM module. <Tc Module Class> <Modules> <Module GUID="{8f5fdcff-ee4b-4ee5-80b1-25eb23bd1b45}"> ... </Module> </Modules> </Tc Module Class> Let’s assume that we already own a Tc COM module that is registered in and detectable by Twin CAT. We now would like to add this Tc COM module, which has the GUID {8F5FDCFF- EE4B-4EE5-80B1-25EB23BD1B45} to our Twin CAT configuration. This can be done by the following way: Code Snippet (C#): Dictionary<string,Guid> tcom Module Table = new Dictionary<string,Guid>(); tcom Module Table. Add("Temp Contr",Guid. Parse("{8f5fdcff-ee4b-4ee5-80b1-25eb23bd1b45}")); ITc Sm Tree Item temp Controller = tc Com Objects. Create Child("Test", 0, "", tcom Module Table["Temp Contr"]); Code Snippet (Powershell): $tcom Module Table = @{} $tcom Module Table. Add("Temp Contr", "{8f5fdcff-ee4b-4ee5-80b1-25eb23bd1b45}") $temp Controller = $tc Com Objects. Create Child("Test", 0, "", $tcom Module Table["Temp Contr"]) Please note that the v Info parameter of the method Itc Sm Tree Item::Create Child() contains the GUID of the Tc COM module which is used to identify the module in the list of all registered Tc COM modules in that system. • This name can be used to add a Tc COM module to a Twin CAT configuration via the ITc Sm Tree Item::Create Child() method. The name can be determined in Twin CAT XAE via the TMC Editor. Twin CAT 3 Version: 1.18.0 345

## Page 346

Appendix • • This can be done by the following way: Code Snippet (C#): ITc Sm Tree Item temp Controller = tc Com Objects. Create Child("Test", 1, "", "New Module"); Code Snippet (Powershell): $temp Controller = $tc Com Objects. Create Child("Test", 0, "", "New Module") Iterating through added Tc COM modules To iterate through all added Tc COM module instances, you may use the ITc Module Manager2 interface. The following code snippet demonstrates how to use this interface. Code Snippet (C#): ITc Sys Manager3 sys Manager3 = sys Manager as ITc Sys Manager3; ITc Module Manager3 module Manager = sys Manager3. Get Module Manager() as ITc Module Manager3; foreach (ITc Module Instance2 module Instance in module Manager) { string module Type = module Instance. Module Type Name; string instance Name = module Instance. Module Instance Name; Guid class Id = module Instance. Class ID; uint obj Id = module Instance.oid; uint parent Obj Id = module Instance. Parent OID; } Code Snippet (Powershell): $module Manager = $system Manager. Get Module Manager() For Each( $module Instance in $module Manager ) { $module Type = $module Instance. Module Type Name $instance Name = $module Instance. Module Instance Name $class Id = $module Instance. Class ID $obj Id = $module Instance.oid $parent Obj Id = $module Instance. Parent OID } Please note that every module object can also be interpreted as an ITc Sm Tree Item, therefore the following type cast would be valid: Code Snippet (C#): ITc Sm Tree Item tree Item = module Instance As ITc Sm Tree Item; Please note: Powershell uses dynamic data types by default. Setting Create Symbol flag for parameters The Create Symbol (CS) flag for parameters of a Tc COM module can be set via its XML description. The following code snippet demonstrates how to activate the CS flag for the Parameter “Call By”. Code Snippet (C#): 346 Version: 1.18.0 Twin CAT 3

## Page 347

Appendix bool activate CS = true; // First step: Read all Parameters of Tc COM module instance string temp Controller Xml = temp Controller. Produce Xml(); Xml Document temp Controller Doc = new Xml Document(); temp Controller Doc. Load Xml(temp Controller Xml); Xml Node source Parameters = temp Controller Doc. Select Single Node("Tree Item/Tc Module Instance/Module/ Parameters"); // Second step: Build target XML (for later Consume Xml()) Xml Document target Doc = new Xml Document(); Xml Element tree Item Element = target Doc. Create Element("Tree Item"); Xml Element module Instance Element = target Doc. Create Element("Tc Module Instance"); Xml Element module Element = target Doc. Create Element("Module"); Xml Element parameters Element = (Xml Element) target Doc. Import Node(source Parameters, true); module Element. Append Child(parameters Element); module Instance Element. Append Child(module Element); tree Item Element. Append Child(module Instance Element); target Doc. Append Child(tree Item Element); // Third step: Look for specific parameter (in this case "Call By") and read its Create Symbol attribute Xml Node dest Module = target Doc. Select Single Node("Tree Item/Tc Module Instance/Module"); Xml Node call By Parameter = dest Parameters. Select Single Node("Parameters/Parameter[Name='Call By']"); Xml Attribute create Symbol = call By Parameter. Attributes["Create Symbol"]; create Symbol. Value = "true"; // Fifth step: Write prepared XML to configuration via Consume Xml() string target Xml = target Doc. Outer Xml; temp Controller. Consume Xml(target Xml); Code Snippet (Powershell): $temp Controller Xml = [Xml]$temp Controller. Produce Xml() $source Parameters = $temp Controller Xml. Tree Item. Tc Module Instance. Module. Parameters [System. XML. Xml Document] $target Doc = New-Object System. XML. Xml Document [System. XML. Xml Element] $tree Item Element = $target Doc. Create Element("Tree Item") [System. XML. Xml Element] $module Instance Element = $target Doc. Create Element("Tc Module Instance") [System. XML. Xml Element] $module Element = $target Doc. Create Element("Module") [System. XML. Xml Element] $parameters Element = $target Doc. Import Node($source Parameters, $true) $module Element. Append Child($parameters Element) $module Instance Element. Append Child($module Element) $tree Item Element. Append Child($module Instance Element) $target Doc. Append Child($tree Item Element) $dest Module = $target Doc. Tree Item. Tc Module Instance. Module $call By Parameter = $destmodule. Select Single Node("Parameters/Parameter[Name='Call By']") $call By Parameter. Create Symbol = "true" $target Xml = $target Doc. Outer Xml $temp Controller. Consume Xml($target Xml) Setting Create Symbol flag for Data Areas The Create Symbol (CS) flag for Data Areas of a Tc COM module can be set via its XML description. The following code snippet demonstrates how to activate the CS flag for the Data Area “Input”. Please note that the procedure is pretty much the same as for parameters. Code Snippet (C#): bool activate CS = true; // First step: Read all Data Areas of a Tc COM module instance string temp Controller Xml = temp Controller. Produce Xml(); Xml Document temp Controller Doc = new Xml Document(); temp Controller Doc. Load Xml(temp Controller Xml); Xml Node source Data Areas = temp Controller Doc. Select Single Node("Tree Item/Tc Module Instance/Module/ Data Areas"); // Second step: Build target XML (for later Consume Xml()) Xml Document target Doc = new Xml Document(); Xml Element tree Item = target Doc. Create Element("Tree Item"); Xml Element module Instance = target Doc. Create Element("Tc Module Instance"); Xml Element module = target Doc. Create Element("Module"); Xml Element data Areas = (Xml Element) target Doc. Import Node(source Data Areas, true); module. Append Child(data Areas); module Instance. Append Child(module); Twin CAT 3 Version: 1.18.0 347

## Page 348

Appendix tree Item. Append Child(module Instance); target Doc. Append Child(tree Item); // Third step: Look for specific Data Area (in this case "Input") and read its Create Symbol attribute Xml Element data Area = (Xml Element)target Doc. Select Single Node("Tree Item/Tc Module Instance/Module/ Data Areas/Data Area[Context Id='0' and Name='Input']"); Xml Node data Area No = data Area. Select Single Node("Area No"); Xml Attribute create Symbol = data Area No Node. Attributes["Create Symbols"]; // Fourth step: Set Create Symbol attribute to true if it exists. If not, create attribute and set its value if (create Symbol != null) string old Value = create Symbol. Value; else { create Symbol = target Doc. Create Attribute("Create Symbols"); data Area No. Attributes. Append(create Symbol); } create Symbol. Value = Xml Convert. To String(activate CS); // Fifth step: Write prepared XML to configuration via Consume Xml() string target Xml = target Doc. Outer Xml; temp Controller. Consume Xml(target Xml); Code Snippet (Powershell): $temp Controller Xml = [Xml]$temp Controller. Produce Xml() $source Data Areas = $temp Controller Xml. Tree Item. Tc Module Instance. Module. Data Areas [System. XML. Xml Document] $target Doc = New-Object System. XML. Xml Document [System. XML. Xml Element] $tree Item = $target Doc. Create Element("Tree Item") [System. XML. Xml Element] $module Instance = $target Doc. Create Element("Tc Module Instance") [System. XML. Xml Element] $module = $target Doc. Create Element("Module") [System. XML. Xml Element] $data Areas = $target Doc. Import Node($source Data Areas, $true) $module. Append Child($data Areas) $module Instance. Append Child($module) $tree Item. Append Child($module Instance) $target Doc. Append Child($tree Item) $dest Module = $target Doc. Tree Item. Tc Module Instance. Module [System. XML. Xml Element] $data Area = $dest Module. Select Single Node("Data Areas/Data Area[Context Id='0' and Name='Input']") $data Area No = $data Area. Select Single Node("Area No") $data Area No. Create Symbols = "true" // Fifth step: Write prepared XML to configuration via Consume Xml() $target Xml = $target Doc. Outer Xml $temp Controller. Consume Xml($target Xml) Setting Context (Tasks) Every Tc COM module instance needs to be run in a specific context (task). This can be done via the ITc Module Instance2::Set Module Context() method. This method awaits two parameters: Context Id and Task Object Id. Both are equivalent to the corresponding parameters in Twin CAT XAE: 348 Version: 1.18.0 Twin CAT 3

## Page 349

Appendix Please note that the Task Object Id is shown in hex in Twin CAT XAE. Code Snippet (C#): ITc Module Instance2 temp Controller Mi = (ITc Module Instance2) temp Controller; temp Controller Mi. Set Module Context(0, 33619984); You can determine the Task Object Id via the XML description of the corresponding task, for example: Code Snippet (C#): ITc Sm Tree Item some Task = system Manager. Lookup Tree Item("TIRT^Some Task"); string some Task Xml = some Task. Produce Xml(); Xml Document some Task Doc = new Xml Document(); some Task Doc. Load Xml(some Task Xml); Xml Node task Object Id Node = some Task Doc. Select Single Node("Tree Item/Object Id"); string task Object Id Str = task Object Id. Inner Text; uint task Object Id = uint. Parse(task Object Id Str, Number Styles. Hex Number); Linking variables Linking variables of a Tc COM module instance to PLC/IO or other Tc COM modules can be done by using regular Automation Interface mechanisms, e.g. ITc Sys Manager::Link Variables(). 16.5 Third-party components This software contains third-party components. Please refer to the license file provided in the following folder for further information: C:\Program Files(x86)\Beckhoff\Legal Twin CAT-XAE-Cpp Platform Wizard C:\Program Files(x86)\Beckhoff\Legal Twin CAT-XAE-Public SDK Twin CAT 3 Version: 1.18.0 349

## Page 350

Trademark statements Beckhoff®, ATRO®, Ether CAT®, Ether CAT G®, Ether CAT G10®, Ether CAT P®, MX-System®, Safety over Ether CAT®, TC/BSD®, Twin CAT®, Twin CAT/BSD®, Twin SAFE®, XFC®, XPlanar® and XTS® are registered and licensed trademarks of Beckhoff Automation Gmb H. Third-party trademark statements DSP System Toolbox, Embedded Coder, MATLAB, MATLAB Coder, MATLAB Compiler, Math Works, Predictive Maintenance Toolbox, Simscape, Simscape™ Multibody™, Simulink, Simulink Coder, Stateflow and Thing Speak are registered trademarks of The Math Works, Inc. Intel, the Intel logo, Intel Core, Xeon, Intel Atom, Celeron and Pentium are trademarks of Intel Corporation or its subsidiaries. Microsoft, Microsoft Azure, Microsoft Edge, Power Shell, Visual Studio, Windows and Xbox are trademarks of the Microsoft group of companies.

## Page 351

More Information: www.beckhoff.com/te1000 Beckhoff Automation Gmb H & Co. KG Hülshorstweg 20 33415 Verl Germany Phone: +49 5246 9630 info@beckhoff.com www.beckhoff.com
