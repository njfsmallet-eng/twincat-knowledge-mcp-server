---
title: "Automation_Interface_EN"
product: "Automation"
category: "Communication"
tags: ["AUTOMATION", "INTERFACE"]
language: "EN"
document_type: "Manual"
version: "1.5"
source_pdf: "https://download.beckhoff.com/download/Document/automation/twincat3/Automation_Interface_EN.pdf"
release_date: "2022-08-31"
---
Manual | EN Automation Interface Twin CAT 3 2022-08-31 | Version: 1.5

## Page 3

Table of Contents Table of Contents 1 Foreword.................................................................................................................................................... 7 1.1 Notes on the documentation............................................................................................................. 7 1.2 Safety instructions............................................................................................................................. 8 1.3 Notes on information security............................................................................................................ 9 2 Overview.................................................................................................................................................. 10 2.1 Product description......................................................................................................................... 10 2.2 Version overview............................................................................................................................. 12 2.3 Frequently Asked Questions........................................................................................................... 15 3 Installation............................................................................................................................................... 17 3.1 System requirements...................................................................................................................... 17 3.2 Installation....................................................................................................................................... 17 4 Configuration........................................................................................................................................... 20 4.1 Quickstart........................................................................................................................................ 20 4.2 Basics.............................................................................................................................................. 20 4.2.1 Accessing Twin CAT configuration................................................................................... 20 4.2.2 Browsing Twin CAT configuration..................................................................................... 23 4.2.3 Custom Tree Item Parameters.......................................................................................... 25 4.2.4 Twin CAT Project Template.............................................................................................. 26 4.2.5 Implementing a COM Message Filter............................................................................... 26 4.2.6 Handling different Visual Studio versions......................................................................... 30 4.2.7 Silent Mode...................................................................................................................... 31 4.3 Best practice................................................................................................................................... 31 4.3.1 Visual Studio.................................................................................................................... 31 4.3.2 Licensing.......................................................................................................................... 38 4.3.3 System............................................................................................................................. 40 4.3.4 ADS.................................................................................................................................. 53 4.3.5 PLC.................................................................................................................................. 56 4.3.6 I/O.................................................................................................................................... 70 4.3.7 Tc COM............................................................................................................................. 95 4.3.8 C++................................................................................................................................ 100 4.3.9 Measurement................................................................................................................. 103 4.3.10 Motion............................................................................................................................ 111 4.3.11 Safety............................................................................................................................. 113 5 API.......................................................................................................................................................... 115 5.1 Reference...................................................................................................................................... 115 5.2 ITc Sys Manager............................................................................................................................. 116 5.2.1 ITc Sys Manager.............................................................................................................. 116 5.2.2 ITc Sys Manager::New Configuration............................................................................... 118 5.2.3 ITc Sys Manager::Open Configuration.............................................................................. 118 5.2.4 ITc Sys Manager::Save Configuration.............................................................................. 119 5.2.5 ITc Sys Manager::Activate Configuration.......................................................................... 119 5.2.6 ITc Sys Manager::Is Twin CATStarted............................................................................... 119 5.2.7 ITc Sys Manager::Start Restart Twin CAT.......................................................................... 119 Automation Interface Version: 1.5 3

## Page 4

Table of Contents 5.2.8 ITc Sys Manager::Link Variables...................................................................................... 120 5.2.9 ITc Sys Manager::Unlink Variables................................................................................... 120 5.2.10 ITc Sys Manager2::Get Target Net Id................................................................................. 121 5.2.11 ITc Sys Manager2::Set Target Net Id.................................................................................. 121 5.2.12 ITc Sys Manager2::Get Last Error Messages..................................................................... 121 5.2.13 ITc Sys Manager::Lookup Tree Item.................................................................................. 122 5.2.14 ITc Sys Manager3::Lookup Tree Item By Id......................................................................... 123 5.2.15 ITc Sys Manager3::Produce Mapping Info......................................................................... 123 5.2.16 ITc Sys Manager3::Consume Mapping Info....................................................................... 124 5.3 ITc Sm Tree Item.............................................................................................................................. 124 5.3.1 ITc Sm Tree Item.............................................................................................................. 124 5.3.2 ITc Sm Tree Item Item Types............................................................................................ 126 5.3.3 Tree item sub types........................................................................................................ 130 5.3.4 ITc Sm Tree Item::Produce Xml......................................................................................... 158 5.3.5 ITc Sm Tree Item::Consume Xml....................................................................................... 159 5.3.6 ITc Sm Tree Item::Create Child......................................................................................... 160 5.3.7 ITc Sm Tree Item::Delete Child.......................................................................................... 162 5.3.8 ITc Sm Tree Item::Import Child.......................................................................................... 163 5.3.9 ITc Sm Tree Item::Export Child.......................................................................................... 163 5.3.10 ITc Sm Tree Item::Lookup Child........................................................................................ 163 5.3.11 ITc Sm Tree Item::Get Last Xml Error.................................................................................. 164 5.4 ITc Plc Project................................................................................................................................. 164 5.4.1 ITc Plc Project.................................................................................................................. 164 5.4.2 ITc Plc Project::Generate Boot Project.............................................................................. 165 5.5 ITc Plc Pou...................................................................................................................................... 165 5.5.1 ITc Plc Pou....................................................................................................................... 165 5.5.2 IECLanguage Types....................................................................................................... 166 5.6 ITc Plc Declaration.......................................................................................................................... 166 5.7 ITc Plc Implementation.................................................................................................................... 167 5.8 ITc Plc IECProject........................................................................................................................... 168 5.8.1 ITc Plc IECProject............................................................................................................ 168 5.8.2 Plc Import Options............................................................................................................ 169 5.8.3 ITc Plc IECProject::Plc Open Export.................................................................................. 170 5.8.4 ITc Plc IECProject::Plc Open Import.................................................................................. 170 5.8.5 ITc Plc IECProject::Save As Library................................................................................... 171 5.9 ITc Plc Library Manager................................................................................................................... 171 5.9.1 ITc Plc Library Manager.................................................................................................... 171 5.9.2 ITc Plc Library Manager::Add Library................................................................................. 173 5.9.3 ITc Plc Library Manager::Add Placeholder......................................................................... 173 5.9.4 ITc Plc Library Manager::Insert Repository........................................................................ 174 5.9.5 ITc Plc Library Manager::Install Library.............................................................................. 174 5.9.6 ITc Plc Library Manager::Move Repository........................................................................ 174 5.9.7 ITc Plc Library Manager::Remove Reference.................................................................... 174 5.9.8 ITc Plc Library Manager::Remove Repository................................................................... 175 5.9.9 ITc Plc Library Manager::Scan Libraries............................................................................ 175 5.9.10 ITc Plc Library Manager::Set Effective Resolution.............................................................. 176 4 Version: 1.5 Automation Interface

## Page 5

Table of Contents 5.9.11 ITc Plc Library Manager::Uninstall Library......................................................................... 176 5.10 ITc Plc References.......................................................................................................................... 177 5.11 ITc Plc Library................................................................................................................................. 177 5.12 ITc Plc Libraries.............................................................................................................................. 178 5.12.1 ITc Plc Libraries............................................................................................................... 178 5.12.2 ITc Plc Libraries::get_Item............................................................................................... 178 5.13 ITc Plc Lib Ref.................................................................................................................................. 178 5.14 ITc Plc Placeholder Ref.................................................................................................................... 179 5.15 ITc Plc Lib Repository...................................................................................................................... 179 5.16 ITc Plc Lib Repositories................................................................................................................... 180 5.16.1 ITc Plc Lib Repositories.................................................................................................... 180 5.16.2 ITc Plc Lib Repositories::get_Item.................................................................................... 180 5.17 ITc Plc Task Reference.................................................................................................................... 181 6 Samples................................................................................................................................................. 182 6.1 Sample downloads........................................................................................................................ 182 6.2 Scripting Container........................................................................................................................ 182 6.2.1 Scripting Container......................................................................................................... 182 6.2.2 Projects.......................................................................................................................... 183 6.3 Code Generation Demo.................................................................................................................. 186 6.4 Visual Studio Plugin - Plc Version Info............................................................................................ 188 7 Appendix................................................................................................................................................ 190 7.1 Miscallaneous error codes............................................................................................................ 190 Automation Interface Version: 1.5 5

## Page 6

Table of Contents 6 Version: 1.5 Automation Interface

## Page 7

Foreword 1 Foreword 1.1 Notes on the documentation This description is only intended for the use of trained specialists in control and automation engineering who are familiar with applicable national standards. It is essential that the documentation and the following notes and explanations are followed when installing and commissioning the components. It is the duty of the technical personnel to use the documentation published at the respective time of each installation and commissioning. The responsible staff must ensure that the application or use of the products described satisfy all the requirements for safety, including all the relevant laws, regulations, guidelines and standards. Disclaimer The documentation has been prepared with care. The products described are, however, constantly under development. We reserve the right to revise and change the documentation at any time and without prior announcement. No claims for the modification of products that have already been supplied may be made on the basis of the data, diagrams and descriptions in this documentation. Trademarks Beckhoff®, Twin CAT®, Twin CAT/BSD®, TC/BSD®, Ether CAT®, Ether CAT G®, Ether CAT G10®, Ether CAT P®, Safety over Ether CAT®, Twin SAFE®, XFC®, XTS® and XPlanar® are registered trademarks of and licensed by Beckhoff Automation Gmb H. Other designations used in this publication may be trademarks whose use by third parties for their own purposes could violate the rights of the owners. Patent Pending The Ether CAT Technology is covered, including but not limited to the following patent applications and patents: EP1590927, EP1789857, EP1456722, EP2137893, DE102015105702 with corresponding applications or registrations in various other countries. Ether CAT® is a registered trademark and patented technology, licensed by Beckhoff Automation Gmb H, Germany Copyright © Beckhoff Automation Gmb H & Co. KG, Germany. The reproduction, distribution and utilization of this document as well as the communication of its contents to others without express authorization are prohibited. Offenders will be held liable for the payment of damages. All rights reserved in the event of the grant of a patent, utility model or design. Automation Interface Version: 1.5 7

## Page 8

Foreword 1.2 Safety instructions Safety regulations Please note the following safety instructions and explanations! Product-specific safety instructions can be found on following pages or in the areas mounting, wiring, commissioning etc. Exclusion of liability All the components are supplied in particular hardware and software configurations appropriate for the application. Modifications to hardware or software configurations other than those described in the documentation are not permitted, and nullify the liability of Beckhoff Automation Gmb H & Co. KG. Personnel qualification This description is only intended for trained specialists in control, automation and drive engineering who are familiar with the applicable national standards. Description of symbols In this documentation the following symbols are used with an accompanying safety instruction or note. The safety instructions must be read carefully and followed without fail! DANGER Serious risk of injury! Failure to follow the safety instructions associated with this symbol directly endangers the life and health of persons. WARNING Risk of injury! Failure to follow the safety instructions associated with this symbol endangers the life and health of per- sons. CAUTION Personal injuries! Failure to follow the safety instructions associated with this symbol can lead to injuries to persons. NOTE Damage to the environment or devices Failure to follow the instructions associated with this symbol can lead to damage to the environment or equipment. Tip or pointer This symbol indicates information that contributes to better understanding. 8 Version: 1.5 Automation Interface

## Page 9

Foreword 1.3 Notes on information security The products of Beckhoff Automation Gmb H & Co. KG (Beckhoff), insofar as they can be accessed online, are equipped with security functions that support the secure operation of plants, systems, machines and networks. Despite the security functions, the creation, implementation and constant updating of a holistic security concept for the operation are necessary to protect the respective plant, system, machine and networks against cyber threats. The products sold by Beckhoff are only part of the overall security concept. The customer is responsible for preventing unauthorized access by third parties to its equipment, systems, machines and networks. The latter should be connected to the corporate network or the Internet only if appropriate protective measures have been set up. In addition, the recommendations from Beckhoff regarding appropriate protective measures should be observed. Further information regarding information security and industrial security can be found in our https://www.beckhoff.com/secguide. Beckhoff products and solutions undergo continuous further development. This also applies to security functions. In light of this continuous further development, Beckhoff expressly recommends that the products are kept up to date at all times and that updates are installed for the products once they have been made available. Using outdated or unsupported product versions can increase the risk of cyber threats. To stay informed about information security for Beckhoff products, subscribe to the RSS feed at https:// www.beckhoff.com/secinfo. Automation Interface Version: 1.5 9

## Page 10

Overview 2 Overview 2.1 Product description The Twin CAT Automation Interface enables the automatic creation and manipulation of Twin CAT XAE configurations via programming/scripting code. The automation of a Twin CAT configuration is available through so-called automation interfaces which can be accessed from all COM-capable programming languages (e.g. C++ or . NET) and also from dynamic script languages - e.g. Windows Power Shell, Iron Python or even legacy VBscript. These automation interfaces are bound to the Visual Studio Automation Model and extend Visual Studio with Twin CAT3 features. Twin CAT Automation Interface enables an efficient engineering process by giving customers the possibility to automate the configuration of a full Twin CAT solution. Traditionally, a machine configuration had to be manually adapted to each new project or had even to be created from scratch, which could not only involve a tremendous amount of engineering time and therefore costs but is also error-prone because of human mistakes. 10 Version: 1.5 Automation Interface

## Page 11

Overview With Twin CAT Automation Interface, the process of adapting Twin CAT configurations to a new environment or even create new Twin CAT configurations from scratch can be automated according to the customers needs. Readers should continue with the following topics: Basics Topic Description Creating/Loading Twin CAT XAE configurations [} 20] Describes how to create or open a Twin CAT configuration Navigating Twin CAT XAE [} 23] Describes how to navigate through a Twin CAT configuration Custom tree item parameters [} 25] Describes how to access custom parameters of an item. This is important to access configuration parameters of a Twin CAT tree item. Implementing a COM message filter [} 26] Describes how to implement an own COM message filter to circumvent rejected COM calls Automation Interface Version: 1.5 11

## Page 12

Overview Best practice Topic Description Creating and handling PLC projects [} 56] Describes how to handle PLC projects Creating and handling PLC POUs [} 64] Describes how to handle PLC objects/code Creating and handling PLC Libraries [} 60] Describes how to handle PLC libraries, repositories and placeholder Creating and handling MOTION projects [} 111] Describes how to create Twin CAT Motion projects (NC-Task, Axes, ...) Creating and handling Ether CAT devices [} 70] Describes how to create Ether CAT devices and connect them to an Ether CAT topology Creating and handling Twin CAT Measurement [} 103] Describes how to handle Twin CAT Measurement projects. Creating and handling Tc COM modules [} 95] Describes how to handle Tc COM modules. Using templates Describes the process of template generation and template usage. Creating and handling network variables [} 76] Describes how to create network variables (publisher/ subscriber variables) Creating and handling Tasks [} 43] Describes how to create Tasks and link them with other objects (PLC-Projects, ...) From offline to online configurations [} 50] Some IO devices need physical address information before the configuration can be activated. This article explains how to retrieve and set this information. Accessing the Error List window of Visual Studio The Error List can be very helpful for debugging and diagnostic purposes [} 37] Accessing window tabs in Visual Studio [} 36] Describes how to get access to Visual Studio windows. Handling different versions of Visual Studio [} 30] Describes how different Versions of Visual Studio can be used for Automation Interface Attaching to running Visual Studio instances [} 35] Demonstrates how you can attach to existing (already running) Visual Studio instances to use Automation Interface Setting Twin CAT target platform [} 34] Describes how to set the Twin CAT target platform for compilation. Additionally, this documentation also includes a full API reference [} 115] of all interfaces. The How to and Sample [} 182] sections offer a free composition of script code fragments, configuration steps and demo projects. They also contain an unsorted and growing list of "real-world" samples. Also see about this 2 Using Templates [} 44] 2.2 Version overview The following table gives an overview about the available features of the Automation Interface related to Twin CAT 2.11, Twin CAT 3.0, Twin CAT 3.1 and a look-out to future Twin CAT versions which may be subject to change. 12 Version: 1.5 Automation Interface

## Page 13

Overview Feature Twin CAT 2.11 Twin CAT 3.0 Twin CAT 3.1 Future versions General settings Importing configuration templates Twin CAT System Service handling (Run-/Config- mode) Load/Save/Create/ Activate configurations Support for remote Twin CAT targets Configuring tasks with process image Configuring tasks - - without process image Multicore support - for tasks Handling of - - - Twin CAT licenses Route management Adding/Removing ADS routes Broadcast Search I/O Scanning for online devices Adding/removing devices, boxes and terminals Parameterization of devices, boxes and terminals Ether CAT topologies Network variables PLC Mapping of variables, e.g. with I/Os or axes Adding/removing PLC projects Adding/removing - - PLC POUs, DUTs, GVLs Automation Interface Version: 1.5 13

## Page 14

Overview Feature Twin CAT 2.11 Twin CAT 3.0 Twin CAT 3.1 Future versions Getting/setting PLC - - code of POUs, DUTs, GVLs Adding/removing - - PLC libraries Adding/removing - - PLC placeholders Adding/removing - - PLC repositories Adding/removing - - PLC libaries to repositories Saving PLC - - projects as a PLC library Compiler and error - - output handling PLCopen XML - - import/export Programing - - language: 2 2 Structured Text (ST) Programing - - language: 1 1 Sequential function chart (SFC) C++ Adding/Removing - - - C++ project templates Compiler and error - - - output handling Motion Adding/Removing - - NC-Tasks Adding/Removing - - axes Parameterization of - - axes settings 3 3 Mapping of - - variables, e.g. with PLC Tc COM modules Adding/Removing - - Tc COM modules Parameterization of - - Tc COM modules Measurement 14 Version: 1.5 Automation Interface

## Page 15

Overview Feature Twin CAT 2.11 Twin CAT 3.0 Twin CAT 3.1 Future versions Adding/Removing - - Twin CAT Measurement projects Adding/Removing - - charts Adding/Removing - - axes Adding/Removing - - channels Parameterization of - - charts, axes and channels Starting/Stopping - - records Notes 1 possibility to implement via PLCopen XML 2 possibility to implement source code either in clear- text or PLCopen XML 3 with limitations. Some settings are stored in a binary format and cannot be edited. 2.3 Frequently Asked Questions • What is Twin CAT Automation Interface? Twin CAT Automation Interface is an interface to access the configuration of Twin CAT from an external application. This enables customers to automate the configuration of Twin CAT. • Can I create an offline Twin CAT configuration (without any attached devices)? Yes. You can create the Twin CAT configuration offline by manually attaching (without "Scan Devices) all devices and then providing online values, e.g. addresses, later after all devices have been attached. Please see our samples [} 182] page for more information. There is also an How-To sample [} 93] which shows you how to provide addressing information for pre-configured I/O devices. • Which programming and scripting languages are supported? Every programming or scripting language that supports the COM object model is supported. Please see our system requirements [} 17] page for more information. • Which Twin CAT features are accessible via Automation Interface? Please see our version overview [} 12] page for more information about which Twin CAT features are accessible via Automation Interface. • What if I don't find an appropriate programming method or property for a specific setting? If you don't find an appropriate Automation Interface method or property for a specific setting, you may use the Import/Export feature of Twin CAT to read/write this setting. Please refer to our article about custom tree item parameters [} 25] for more information. • Can I automate the configuration of Twin CAT PLC? Yes. This feature will be available with Twin CAT 3.1. Please refer to our version overview [} 12] page for more information. • Can I execute Automation Interface code on Twin CAT XAR (Runtime-only) computers? Automation Interface Version: 1.5 15

## Page 16

Overview No. To execute Automation Interface code, Twin CAT XAE (Engineering) is needed, because Automation Interface directly accesses the Visual Studio COM object to communicate with the Twin CAT configuration. However, you can use a Twin CAT XAE computer to remotely connect to a Twin CAT runtime and configure it. • When should I use ADS and when Automation Interface? This is a question which cannot be answered easily because it heavily depends on what you would like to achieve. Twin CAT Automation Interface has been designed primarily to help customers to automate the configuration of Twin CAT. If you want to cyclically read/write values to IOs or PLC variables, our ADS APIs are probably better suited. • Do I need to modify my Automation Interface code if I switch languages in Twin CAT XAE, e.g. from English to German? All Twin CAT XAE items that are language dependent (Devices, Boxes, Axes, Channels, ...) can either be accessed via the currently set XAE language or via their english name. For example, if the XAE language is changed from English to German, the term "Channel" will be displayed in XAE as "Kanal" but is still available under the name "Channel" via Automation Interface. To be fully compatible, we recommend to build your Automation Interface code based on english terminology. Please note: This feature comes with Twin CAT 3.x only! Systems based on Twin CAT 2.x are not language independent! • I'm a machine builder and use a Twin CAT configuration template for all machine types and only enable/disable certain I/Os. Can I also do that with Automation Interface? Yes. There is an How-To sample [} 94] which shows you exactly how to do that. • Can I also create ADS routes or execute a Broadcast Search? Yes. Please see our samples [} 182] and How-To pages for more information. 16 Version: 1.5 Automation Interface

## Page 17

Installation 3 Installation 3.1 System requirements The following chapter lists all hardware and software requirements for the Twin CAT Automation Interface and gives some recommendations for programming and scripting languages. Hardware and Software Twin CAT Automation Interface will be automatically installed by Twin CAT setup. Therefore it needs the same hardware and software system requirements as Twin CAT System Manager / Twin CAT 3 XAE (Engineering). When using the Automation Interface to configure a remote Twin CAT device, it is important that the remote version of Twin CAT equals or is higher than on the engineering computer. Please note that you can execute Automation Interface scripts on 32-bit and 64-bit platforms, however you need to make sure that your program/script has been compiled for and runs in 32-bit mode. Recommended programming languages The following programming languages are recommended to use with Twin CAT Automation Interface: • . NET languages, such as C# or Visual Basic . NET Please note: Although C++ implementations will also work, we highly recommend using one of the languages above because of their easy and straight-forward programming concepts regarding COM. Most of the sample code in this documentation is based on C#. Recommended scripting languages Although every scripting language with COM support may be used to access Twin CAT Automation Interface, we recommend to use the Windows Powershell as it provides the best level of integration between Operating System and application. Please note that at least Twin CAT 3.1 Build 4020.0 is required to use dynamic languages like the Windows Powershell. 3.2 Installation All files needed for the Twin CAT Automation Interface will be installed automatically during Twin CAT setup. As mentioned in the introduction, the Automation Interface communicates with Twin CAT via COM. All needed COM objects are configured automatically so that COM-capable programming and scripting languages can access these objects. Automation Interface Version: 1.5 17

## Page 18

Installation Using the Automation Interface within a . NET application (C#, VB. NET, ...) To access the Automation interface from a . NET application, you need to add a reference to the corresponding COM object Beckhoff Twin CAT XAE Base (depending on your Twin CAT version, see table below) within the Visual Studio project. After the reference has been added, you can access the COM object via the namespace TCat Sys Manager Lib . Please proceed with the article Accessing Twin CAT configuration [} 20] which explains all further steps in more detail. Using the Automation Interface within scripting languages Twin CAT Automation Interface can also be used with COM-capable scripting languages, for example Windows Power Shell or Iron Python. As scripting languages are being interpreted at runtime and not compiled, they always have access to all currently registered COM objects in the operating system. Therefore a reference is not needed. Please proceed with the article Accessing Twin CAT configuration [} 20] which explains all further steps in more detail. Type library versions During the Twin CAT product lifecycle, the type library mentioned above may be delivered in different versions because of added functionalities and/or big Twin CAT versions steps. The table below gives an overview about all different type library versions. 18 Version: 1.5 Automation Interface

## Page 19

Installation Type library name Type library version Twin CAT version Beckhoff TCat Sys Manager 1.1 1.1 Twin CAT 2.11 Type Library Beckhoff Twin CAT XAE Base 2.0 2.0 Twin CAT 3.0 Type Library Beckhoff Twin CAT XAE Base 2.1 2.1 Twin CAT 3.1 Type Library Beckhoff Twin CAT XAE Base 3.1 3.1 Twin CAT 3.1 Build 4020.0 and Type Library above Automation Interface Version: 1.5 19

## Page 20

Configuration 4 Configuration 4.1 Quickstart Because the Twin CAT Automation Interface provides a lot of possibility, it might sometimes be hard to understand where to start. This quickstart provides a step-by-step introduction into the Twin CAT Automation Interface and the different articles in this documentation. We recommend to read the following in-depth articles: Step Article Content 1 Visual Studio Prog IDs [} 30] Describes how different Visual Studio versions can be accessed via the Visual Studio API 2 Accessing Twin CAT configuration [} 20] Describes how to use the Automation Interface in order to create a new Twin CAT project. It also covers the co-existence of Visual Studio API and Twin CAT Automation Interface and how they correlate with each other. 3 Navigating Twin CAT configuration [} 23] Describes how to navigate through an opened Twin CAT configuration by using different Automation Interface functionalities. 4 The necessity of a COM Message Filter Describes why every Automation Interface application should implement a custom COM Message Filter. [} 26] 5 Silent Mode [} 31] Describes how to turn the Automation Interface “silent” After these basic articles, the Best Practice [} 31] articles may be consulted for different topics like PLC or I/ O access via the Automation Interface. 4.2 Basics 4.2.1 Accessing Twin CAT configuration This chapter describes how to create and access a Twin CAT XAE configuration project via Automation interface. The objective of this creation process is to get access to a Twin CAT XAE project (formerly known as a Twin CAT System Manager configuration). The new Twin CAT XAE project is more sophisticated than the Twin CAT System Manager configuration known from Twin CAT2, which implies a slight concept change of project / configuration handling. Twin CAT 3 supports an extra hierarchical level combining several configurations into a Visual Studio solution container. This can for example be used to organize the configurations of distributed resources into a solution or for packaging HMI projects together with the system configuration. The solution is able to bind together all types of Visual Studio and/or Twin CAT XAE projects. When using the Twin CAT XAE Automation inferface, this means an extra level of possiblities. Basic information Twin CAT 3 has been fully integrated into Visual Studio to provide users with a standardized and most flexible editor to create and manage Twin CAT projects. To create and/or access a Twin CAT configuration, the combined use of Visual Studio and Twin CAT Automation Interface is possible. For example: If you want to create a new Twin CAT configuration via Automation Interface, you first need to call methods of the Visual Studio API to create a Visual Studio solution container and then add a Twin CAT project by using methods of the Twin CAT Automation Interface. This scenario will be covered in some code snippets below. 20 Version: 1.5 Automation Interface

## Page 21

Configuration In addition, the Visual Studio API (so-called Visual Studio DTE ) provide developers with many more features, e.g. accessing the error output window. [} 37] For more information about Visual Studio DTE please see the Microsoft MSDN website. Please note: • When creating a new Twin CAT project within a Visual Studio solution, you need to specify a path to the Twin CAT project template [} 26]. Please adapt this path in the code snippets below according to your environment. • The following code snippets use dynamic linking for the Visual Studio DTE objects, which means that the actual type of the object will be determined during the application runtime. In case you do not want to use dynamic linking but instead specify the data type in advance, you need to include the namespace Env DTE. DTE to your project. Creating Twin CAT Projects via templates Please note that you need to add a reference to the COM object Tcat Sys Manager Lib and Env DTE. DTE (Microsoft Developement) in order to be able to use the Twin CAT Automation Interface and the Visual Studio API. The Prog ID that is used in the Get Type From Prod ID() method depends on the Visual Studio version that should be used. Please have a look at this [} 30] documentation article for more information about the different Prog IDs. Code Snippet (C#): Type t = System. Type. Get Type From Prog ID("Visual Studio. DTE.10.0"); Env DTE. DTE dte = System. Activator. Create Instance(t); dte. Suppress UI = false; dte. Main Window. Visible = true; if (Directory. Exists(@"C:\Temp\Solution Folder")) Directory. Delete(@"C:\Temp\Solution Folder", true); Directory. Create Directory(@"C:\Temp\Solution Folder"); Directory. Create Directory(@"C:\Temp\Solution Folder\My Solution1"); dynamic solution = dte. Solution; solution. Create(@"C:\Temp\Solution Folder", "My Solution1"); solution. Save As(@"C:\Temp\Solution Folder\My Solution1\My Solution1.sln"); string template = @"C:\Twin CAT\3.1\Components\Base\Prj Template\Twin CAT Project.tsproj"; //path to project template dynamic project = solution. Add From Template(template, @"C:\Temp\Solution Folder\My Solution1", "My Project"); ITc Sys Manager sys Manager = project. Object; sys Manager. Activate Configuration(); sys Manager. Start Restart Twin CAT(); project. Save(); solution. Save As(@"C:\Temp\Solution Folder\My Solution1\My Solution1.sln"); Code Snippet (Powershell): Automation Interface Version: 1.5 21

## Page 22

Configuration You can copy and paste the following code snippet into a textfile and save it as "some Name.ps1". After that you can execute it directly via Windows Power Shell. $target Dir = "C:\tmp\Test Solution" $target Name = "Test Solution.tsp" $template = "C:\Twin CAT\3.1\Components\Base\Prj Template\Twin CAT Project.tsproj" $dte = new-object -com Visual Studio. DTE.10.0 $dte. Suppress UI = $false $dte. Main Window. Visible = $true if(test-path $target Dir -pathtype container) { Remove-Item $target Dir -Recurse -Force } New-Item $target Dir –type directory $sln = $dte. Solution $project = $sln. Add From Template($template,$target Dir,$target Name) $system Manager = $project. Object $target Net Id = $system Manager. Get Target Net Id() write-host $target Net Id $system Manager. Activate Configuration() $system Manager. Start Restart Twin CAT() $project. Save() $solution Path = $target Dir + "\" + $target Name $sln. Save As($solution Path) Code Snippet (C++): Within appropriate Header file (e.g the stdafx.h): //the following #import imports Env DTE based on its LIBID. #import"libid:80cc9f66-e7d8-4ddd-85b6-d9e6cd0e93e2" version("10.0") lcid("0") raw_interfaces_only named_guids // Imports die "Beckhoff TCat Sys Manager 1.1 Type Library" #import"libid:3C49D6C3-93DC-11D0-B162-00A0248C244B" version("1.1") lcid("0") Because a known issue within Visual Studio 2010 (SP1), the generated proxy code will not be included into the C++ project. Please use the workaround described in #import Known Issue import Known Issue. #include using namespace std using namespace TCat Sys Manager Lib; using namespace Env DTE; int _tmain(int argc, _TCHAR* argv[]) { Co Initialize(NULL); // COM initialisieren cout << "Creating Visual STudio. DTE.10.0 ..."; // creating a new instance of Visual Studio CCom Ptr<_DTE> m_p DTE; HRESULT hr = m_p DTE. Co Create Instance(L"Visual Studio. DTE.10.0", 0, CLSCTX_ALL); if (FAILED(hr)) { cout << " FAILED"; return 1; } cout << " created." << endl; // retrieves the Env DTE. Solution-Objekt CCom Ptr<_Solution> p Solution; m_p DTE->get_Solution(&p Solution); CCom BSTR str Solution Folder(_T("C:\\Solution Folder")); // Solution-main directory (has to exist) CCom BSTR str Solution Name(_T("My Solution1")); CCom BSTR str Template Path(_T("C:\\Twin CAT\\3.1\\Components\\Base\\Prj Template\\Twin CAT Project.tsproj")); CCom BSTR str Solution Path; // Solution-Pfad (doesn’t exist!) str Solution Path=str Solution Folder; str Solution Path. Append(_T("\\")); str Solution Path. Append(str Solution Name); str Solution Path. Append(_T(".sln")); // create the solution hr = p Solution->Create(str Solution Folder,str Solution Name); 22 Version: 1.5 Automation Interface

## Page 23

Configuration CCom BSTR str Project Path(str Solution Folder); // project path str Project Path. Append(_T("\\")); str Project Path. Append(str Solution Name); CCom BSTR str Project Name = "My Project"; // project name // create projekt from a template CCom Ptr p Project; hr = p Solution- >Add From Template(str Template Path,str Project Path,str Project Name,VARIANT_FALSE,&p Project); // Wenn z. B. Projekt bereits besteht >> error if (FAILED(hr)) { cout << " Project creation FAILED"; return 1; } cout << "Project created" << endl; // define project automation class (here the Coclass Tc Sys Manager) CCom Ptr p Dispatch; hr = p Project->get_Object(&p Dispatch); // retrieve ITc Sys Manager interface CCom Ptr p System Manager; hr = p Dispatch. Query Interface(&p System Manager); // operate with System Manager interface CCom BSTR net Id; net Id = (p System Manager->Get Target Net Id()). Get BSTR(); cout << "Target Net Id: " << net Id << endl; hr = p System Manager->Activate Configuration(); hr = p System Manager->Start Restart Twin CAT(); // save project and solution hr = p Project->Save(CCom BSTR()); hr = p Solution->Save As(str Solution Path); cout << "Succeeded"; return 0; } import Known Issue: CCom Ptr<_DTE> m_p DTE; CLSID clsid; CLSIDFrom Prog ID(L"Visual Studio. DTE.10.0",&clsid); CCom Ptr punk; HRESULT hr = Get Active Object(clsid,NULL,&punk); // retrieve actual instance of Visual Studio . NET m_p DTE = punk; Please note: ITc Sys Manager::New Configuration [} 118], ITc Sys Manager::Open Configuraiton [} 118] and ITc Sys Manager::Save Configuration [} 119] will create error messages in this case, because the project handling is delegated to the Visual Studio IDE (the Solution and Project instances realized by the DTE object). 4.2.2 Browsing Twin CAT configuration In a separate article, we have already shown you how to access Twin CAT [} 20] via the Visual Studio Automation Model. This reference to Twin CAT is being represented by an object of type ITc Sys Manager [} 116]. From this point on we would like to discuss now how you can navigate through the Twin CAT configuration. General information It is important to understand that all information in Twin CAT is ordered in a tree-like structure. In Automation Interface, every tree node, and therefore every element of a Twin CAT configuration, is represented by the interface ITc Sm Tree Item [} 124]. Navigating the Twin CAT data model can be done in different ways, depending on the sort of information that should be retrieved. • Lookup-Methods are searching for specific tree items via specified search criterias, e.g. the path to a tree item • Iterators or browsing functions iterate over a set of retrieved tree items Automation Interface Version: 1.5 23

## Page 24

Configuration Both methods are now being discussed in the following article. Lookup Methods The Lookup methods are always working on the whole data model (unfiltered). • ITc Sys Manager::Lookup Tree Item [} 122] determines a tree item with the specified absolute path name. • ITc Sys Manager3::Lookup Tree Item By Id [} 123] determines a tree item with the specified item type and item Id. • ITc Sm Tree Item::Lookup Child [} 163] determines a tree item within a subtree specifed by a relative path name. Each tree item in Twin CAT can be identified by its unique pathname. The pathname of a tree item is based on the hierarchical order of its parent item (its name) and its own name, separated by circumflex accents ('^'). To shorten the pathnames and to avoid language dependencies, the top level tree items have special abbreviations which are listed in ITc Sys Manager::Lookup Tree Item [} 122]. Iterators At the moment, three different types of iteration functions are supported: • Browsing all tree items (unfiltered) • Browsing main tree items • Browsing variables / symbols only Browsing all tree items (unfiltered) To browse all tree items in an unfiltered way, the property ITc Sm Tree Item [} 124]:New Enum may be used. _New Enum iterates over all subnodes of the currently referenced ITc Sm Tree Item [} 124]. This (COM-) property is used by many Programming and Script languages that support the COM Enumerator model (e.g. . NET languages, VB6 or script languages) by a 'foreach' statement. For non-supporting languages like C++ the foreach loop must be implemented manually by using the IEnum Variant-interface. We recommend to use this way to iterate through child nodes. Sample (C#): ITc Sm Tree Item parent = sys Man. Lookup Tree Item("TIID^Device1^EK1100"); foreach(ITc Sm Tree Item child in parent) { Console. Write Line(child. Name); } 24 Version: 1.5 Automation Interface

## Page 25

Configuration Sample (C++): ... #import "C:\Twin CAT3\Components\Base\TCat Sys Manager.tlb" // imports the System Manager / XAE Base type library // uses automatically created auto-pointer (see MSDN documentation of #import command) ... void CSys Man Dialog::Iterate Collection(TCat Sys Manager Lib::ITc Sm Tree Item Ptr parent Ptr) { IEnum VARIANTPtr sp Enum = parent Ptr->_New Enum; ULONG n Returned = 0; VARIANT variant[1] = {0}; HRESULT hr = E_UNEXPECTED; do { hr = sp Enum->Next(1, &variant[0], &n Returned); if(FAILED(hr)) break; for(ULONG i = 0; i < n Returned; ++i) { IDispatch Ptr dispatch Ptr; IDispatch* p Dispatch; TCat Sys Manager Lib::ITc Sm Tree Item Ptr child Ptr; HRESULT hr; if(variant[0].vt == VT_DISPATCH) { TCat Sys Manager Lib::ITc Sm Tree Item* p Child = 0; dispatch Ptr. Attach((variant[0].pdisp Val)); hr = dispatch Ptr. Query Interface(__uuidof(TCat Sys Manager Lib::ITc Sm Tree Item), reinterpret_cast(&p Child)); child Ptr. Attach(p Child); _bstr_t str Name = p Child->Get Name(); } } } while(hr != S_FALSE); // S_FALSE zeigt Ende der Sammlung an } Sample (Power Shell): $system Item = $system Manager. Lookup Tree Item("TIRC") foreach($child in $system Item) { write-host$child. Name } Browsing Main Tree Items (Filtered) For browsing only the main childs of the current tree item use the ITc Sm Tree Item::Child Count [} 124] and ITc Sm Tree Item:Child(n) [} 116] pair of properties. These methods only work on the direct childs (non- recursive). Browsing Variables / Symbols only To Browse the Variables / Symbols use the ITc Sm Tree Item::Var Count(x) [} 124] , ITc Sm Tree Item::Var(x,n) [} 124] pair of properties. A selection of the variable type (input variables or output variables) can be done by parameter. 4.2.3 Custom Tree Item Parameters The ITc Sm Tree Item [} 124] interface is supported by every Twin CAT tree item and has a very generic character. To support the specification of all the devices, boxes and terminals, together with many other different types of tree items, all custom parameters of a tree item are accessible via the XML representation of the tree item. This XML-String can be accessed by the method ITc Sm Tree Item::Produce Xml [} 158] and its counterpart ITc Sm Tree Item::Consume Xml [} 159]. This function pair has the same functionality as the "Export XML Description ..." and "Import XML Description ..." commands from the main menu of the Twin CAT IDE (see snapshot below). Automation Interface Version: 1.5 25

## Page 26

Configuration Fig. 1: Tc Sys Man_Automation Xml Parameters With this Import/Export functionset, many parts of a script or automation code can be tested and tailored conveniently, before it is developed within the coding language - simply by the process of exporting tree item data, changing its content and re-importing it. Best practice is to export the XML content first, change its content, importing it within the IDE and then, if everything goes successfully, package it into the programming/script code for handling it via the methods Produce Xml and Consume Xml. 4.2.4 Twin CAT Project Template When creating a new Twin CAT solution, you need to specify the path to the Twin CAT Project template - see also our article about Accessing Twin CAT XAE configuration [} 20]. Basics Twin CAT version Path to Twin CAT project template* Twin CAT 3.0 C: \Twin CAT\3.0\Components\Base\Prj Template\Twin C AT Project.tsp Twin CAT 3.1 C: \Twin CAT\3.1\Components\Base\Prj Template\Twin C AT Project.tsproj * Please note: The paths mentioned above are based on the default Twin CAT installation directory and may be different if you installed Twin CAT in another folder. 4.2.5 Implementing a COM Message Filter Message filtering is a mechanism that allows server applications to decide if and when an incoming method call can be safely executed on one of their objects. COM generally does not know the reentrancy requirements of your application and consequently does not filter messages by default. Even though message filtering is not as significant as it was with 16-bit applications because the message queue size is now actually unlimited, you should still implement message filtering as a way to resolve blockages. COM will call your implementation of the IMessage Filter interface to find out if an application (a COM server) is blocking so that you can respond and handle the situation. For example, when accessing Twin CAT XAE via COM, the Visual Studio instance will reject further COM calls while still executing a previous COM call. As a 26 Version: 1.5 Automation Interface

## Page 27

Configuration result, the client application will issue an RPC_E_CALL_REJECTED error and, without further intervention, will not repeat the call. By writing a user-defined message filter, the programmer has the ability to retry the COM call when the client application receives notification of a denied COM call from the COM server. The following screenshot shows a typical error output by the Visual Studio COM server when an instance is still busy executing a previous COM call. To avoid this situation and implement a message filter that responds to this rejected COM call, the application engineer must implement the IMessage Filter interface. This interface consists of three methods: • Handle Incoming Call(): Provides a single entry point for incoming calls • Message Pending(): Indicates that a message has been received while COM is waiting for a remote call to be answered. • Retry Rejected Call(): Provides the ability to respond to a rejected COM call. Note that message filters can only be applied to STA threads and that only one filter can be applied to each thread. Multithreaded apartments, e.g. console applications, cannot have message filters. These applications must run in an STA thread to apply message filtering. See the appendix of this documentation for more information on COM threading. The following code snippet shows a sample of how the IMessage Filter interface can be used in C#. Note that this code is also used in many samples in our Samples [} 182] section, and is also available as a separate sample download. [Com Import(), Guid("00000016-0000-0000-C000-000000000046"), Interface Type Attribute(Com Interface Type. Interface Is IUnknown)] interface IOle Message Filter { [Preserve Sig] int Handle In Coming Call(int dw Call Type, Int Ptr h Task Caller, int dw Tick Count, Int Ptr lp Interface Info); [Preserve Sig] int Retry Rejected Call(Int Ptr h Task Callee, int dw Tick Count, int dw Reject Type); [Preserve Sig] int Message Pending(Int Ptr h Task Callee, int dw Tick Count, int dw Pending Type); } The following class implements this interface and adds two more methods: Register() and Revoke(). public class Message Filter : IOle Message Filter { public static void Register() { IOle Message Filter new Filter = new Message Filter(); IOle Message Filter old Filter = null; int test = Co Register Message Filter(new Filter, out old Filter); if (test != 0) { Automation Interface Version: 1.5 27

## Page 28

Configuration Console. Write Line(string. Format("Co Register Message Filter failed with error : {0}", test)); } } public static void Revoke() { IOle Message Filter old Filter = null; int test = Co Register Message Filter(null, out old Filter); } int IOle Message Filter. Handle In Coming Call(int dw Call Type, System. Int Ptr h Task Caller, int dw Tick Count, System. Int Ptr lp Interface Info) { //returns the flag SERVERCALL_ISHANDLED. return 0; } int IOle Message Filter. Retry Rejected Call(System. Int Ptr h Task Callee, int dw Tick Count, int dw Reject Type) { // Thread call was refused, try again. if (dw Reject Type == 2) // flag = SERVERCALL_RETRYLATER. { // retry thread call at once, if return value >=0 & // <100. return 99; } return -1; } int IOle Message Filter. Message Pending(System. Int Ptr h Task Callee, int dw Tick Count, int dw Pending Type) { //return flag PENDINGMSG_WAITDEFPROCESS. return 2; } // implement IOle Message Filter interface. [Dll Import("Ole32.dll")] private static extern int Co Register Message Filter(IOle Message Filter new Filter, out IOle Message Filter old Filter); An application engineer now only needs to call the Register() and Revoke() methods from another class to initialize and discard the Message Filter. The result is that rejected COM calls are repeated as specified in the Retry Rejected Call() method. The following code snippet shows how to call these methods in a console application written in C#. As mentioned above, console applications run in an MTA thread by default. For this reason, the Main() method must be configured to run in an STA apartment so that the message filter can be applied. [STAThread] static void Main(string[] args) { Message Filter. Register(); /* ============================================================= * place COM calls for the Automation Interface here * ... * ... * ============================================================= */ Message Filter. Revoke(); } If you try to apply a message filter to an application running in the MTA apartment, the following error is issued when trying to execute the Co Register Message Filter() method during runtime: 28 Version: 1.5 Automation Interface

## Page 29

Configuration For more information about the different COM threading models, see the MSDN article Understanding and Using COM Threading models. For more detailed information about the IMessage Filter interface, see the MSDN documentation regarding IMessage Filter. The following code snippet shows how to implement a COM Message Filter for Windows Powershell by including it as a . NET type (C#) in Power Shell. Code snippet (Powershell): Add Message Filter Class('') # Call function [Env Dte Utils. Message Filter]::Register() # Call static Register Filter Method $dte = New-Object -COMObject Tc Xae Shell. DTE.15.0 $dte. Suppress UI = $false $dte. Main Window. Visible = $true $solution = $dte. Solution # do stuff $dte. Quit() [Env DTEUtils. Message Filter]::Revoke() function Add Message Filter Class { $source = @‘ namespace Env Dte Utils { using System; using System. Runtime. Interop Services; public class Message Filter : IOle Message Filter { public static void Register() { IOle Message Filter new Filter = new Message Filter(); IOle Message Filter old Filter = null; Co Register Message Filter(new Filter, out old Filter); } public static void Revoke() { IOle Message Filter old Filter = null; Co Register Message Filter(null, out old Filter); } int IOle Message Filter. Handle In Coming Call(int dw Call Type, System. Int Ptr h Task Caller, int dw Tick Count, System. Int Ptr lp Interface Info) { return 0; } int IOle Message Filter. Retry Rejected Call(System. Int Ptr h Task Callee, int dw Tick Count, int dw Reject Type) { if (dw Reject Type == 2) { return 99; } return -1; } Automation Interface Version: 1.5 29

## Page 30

Configuration int IOle Message Filter. Message Pending(System. Int Ptr h Task Callee, int dw Tick Count, int dw Pending Type) { return 2; } [Dll Import("Ole32.dll")] private static extern int Co Register Message Filter(IOle Message Filter new Filter, out IOle Message Filter old Filter); } [Com Import(), Guid("00000016-0000-0000-C000-000000000046"), Interface Type Attribute(Com Interface Type. Interface Is IUnknown)] interface IOle Message Filter { [Preserve Sig] int Handle In Coming Call(int dw Call Type, Int Ptr h Task Caller, int dw Tick Count, Int Ptr lp Interface Info); [Preserve Sig] int Retry Rejected Call(Int Ptr h Task Callee, int dw Tick Count, int dw Reject Type); [Preserve Sig] int Message Pending(Int Ptr h Task Callee, int dw Tick Count, int dw Pending Type); } } ‘@ Add-Type -Type Definition $source } 4.2.6 Handling different Visual Studio versions This article explains how to use the Twin CAT Automation Interface with different versions of Visual Studio, e.g. Visual Studio 2010 and 2012, in case you have installed two or more versions in parallel. It consists of the following topics: • Visual Studio Program ID • Specify Visual Studio version in Automation Interface code Visual Studio Program ID As you have already seen in our basic articles, you need to create a Visual Studio DTE object before implementing Automation Interface code because of the Twin CAT 3 integration into the Visual Studio environment. If you have installed more than one Visual Studio version on your Engineering PC and would like to choose which version should be used along with the Automation Interface code, you need to determine the so-called Program ID (Prog ID) of the corresponding Visual Studio version. The Prog ID is located in the Windows Registry under HKEY_CLASSES_ROOT and has the following format: Visual Studio. DTE. X. Y. The following table shows the Prog IDs for the currently supported versions of Visual Studio: Version Prog ID Visual Studio 2010 Visual Studio. DTE.10.0 Visual Studio 2012 Visual Studio. DTE.11.0 Visual Studio 2013 Visual Studio. DTE.12.0 Visual Studio 2015 Visual Studio. DTE.14.0 Visual Studio 2017 Visual Studio. DTE.15.0 Twin CAT XAE Shell Tc Xae Shell. DTE.15.0 Specify Visual Studio version in Automation Interface code To specify the Visual Studio version in Automation Interface code, you need to use the Prog ID as a paremeter of the Get Type Drom Prog ID() method during the creation process of the DTE object. Code Snippet (C#): Type t = System. Type. Get Type From Prog ID("Visual Studio. DTE.15.0"); Env DTE. DTE dte = (Env DTE. DTE)System. Activator. Create Instance(t); 30 Version: 1.5 Automation Interface

## Page 31

Configuration Code Snippet (Powershell): $dte = new-object-com Visual Studio. DTE.15.0 4.2.7 Silent Mode Sometimes an Automation Interface script or program should operate silently, which means without any message boxes or other visible interruptions. Although the Visual Studio DTE command “dte. Visible = true/ false” may seem sufficient in most use cases, the Twin CAT Automation Interface introduces a new Silent Mode switch, which is available since Twin CAT 3.1 Build 4020.0 and above. This new switch can be activated as follows. Code snippet (C#): var settings = dte. Get Object("Tc Automation Settings"); settings. Silent Mode = true; Code snippet (Powershell): $settings = $dte. Get Object("Tc Automation Settings") $settings. Silent Mode = $true This will suppress message box dialogs during usage of the Twin CAT Automation Interface. 4.3 Best practice 4.3.1 Visual Studio 4.3.1.1 Select projects for build process The Visual Studio API provides all mechanisms required to select projects for a Solution Configuration. The necessary methods are part of the Solution Build2 class of the Env DTE namespace. The following example demonstrates how to use the method Build Project() from that class. Code Snippet (Powershell): $sln = $dte. Solution $prj = $dte. Projects. Item(1) #Sys Man Project $sys Man Project Name = $prj. Full Name $plc Prj Project Name = Path To Plc Proj File $sln. Solution Build. Build Project("Release|Twin CAT RT (x64)",$sys Man Project Name,$true) $sln. Solution Build. Build Project("Release|Twin CAT RT (x64)",$plc Prj Project Name,$true) The placeholder “path To Plc Proj File” represents the full path to a *.plcproj file which represents a Twin CAT 3 PLC project. 4.3.1.2 Accessing Team Foundation Server source control This chapter provides an overview about how to access a Microsoft Team Foundation Server (TFS) programmatically by using the corresponding DLLs that are supplied by Visual Studio. This documentation has been written for your convenience and to make first steps easier when trying to combine Twin CAT Automation Interface code with TFS DLLs. For a more detailed documentation about the TFS API, we highly recommend to visit the corresponding MSDN articles. This documentation covers the following topics: • Connecting to a TFS Server • Connecting to Team Projects • Working with workspaces • Creating working folders Automation Interface Version: 1.5 31

## Page 32

Configuration • Get latest version of an item • Getting a list of pending changes • Checking In and Checking Out • Undo an operation The following TFS API DLLs are being used within this documentation: • Microsoft. Team Foundation. Client • Microsoft. Team Foundation. Version Control. Client Connecting to a TFS Server The Microsoft TFS API lets you connect your application containing Twin CAT Automation Interface code to your development repository on a remote server. The connection requires a string describing the address, the port and the collection of your remote server e.g. http://your-tfs:8080/tfs/Default Collection. Before you connect, define an instance of Uri class and Tfs Configuration Server class. Assign the remote server link to the configuration server: Code Snippet (C#): string tfs Server Url = "http://your-server:8080/tfs/Default Collection"; Uri configuration Server Uri = new Uri(tfs Server Url); Tfs Team Project Collection team Projects = Tfs Team Project Collection Factory. Get Team Project Collection(configuration Server Uri); Version Control Server ver Control Server = team Projects. Get Service<Version Control Server>(); Connecting to Team Projects You can get a list of team projects or a specific team project on the server by executing the following code snippets: Code Snippet (C#): // Get all Team projects Team Project[] all Projects = ver Control Server. Get All Team Projects(true); // Get specific Team Project Team Project project = ver Control Server. Try Get Team Project("Team Project Name"); Working with workspaces Team foundation deals with workspaces which comprises mappings to working folders. These mappings link server-side folders to local folders on your hard-drive. It additionally also stores the name of the owner and the name of your computer as a part of the workspace name. A workspace is a must before performing any version control task because it stores information about files, versions and list of pending changes. To begin with TFS Client API offers a Workspace class which stores the information mentioned above and offers extensive suit of methods to interact with the files and folders. Suppose you wish to create a workspace for a folder named, folder Name, then create a string containing the computer name and the folder: Code Snippet (C#): // Specify workspace name for later use String workspace Name = String. Format("{0}-{1}", Environment. Machine Name, "Test_TFSAPI"); // Create new workspace Workspace new Workspace = ver Control Server. Create Workspace(workspace Name, ver Control Server. Authorized User); A mapping can now exist between the server-side folder and your local folder specified by folder Name under workspace. To get an existing or delete a workspace, simply execute the following methods: Code Snippet (C#): // Delete workspace bool workspace Deleted = ver Control Server. Delete Workspace(workspace Name, ver Control Server. Authorized User); 32 Version: 1.5 Automation Interface

## Page 33

Configuration // Get existing workspace Workspace existing Workspace = ver Control Server. Get Workspace(workspace Name, ver Control Server. Authorized User); Creating working folders To connect to a specified project folder, you need a path to the project relative to the root. For instance, if the project is stored on: your-server\Development\Tc Sample Project X, then the relative path to that folder is $\Development\Tc Sample Project X. To match this folder to the projects on the server, you can iterate over a set of all registered projects on the server. A registered project is the root of project collections found underneath. Code Snippet (C#): // Create mapping between server and local folder string server Folder = String. Format("$/{0}", team Project. Name + "/Folder/Sub Folder"); string local Folder = Path. Combine(@"C:\tfs", workspace Name); Working Folder working Folder = new Working Folder(server Folder, local Folder); existing Workspace. Create Mapping(working Folder); Get latest version of an item As mentioned earlier Workspace class offers a rich set of methods to execute the TFS commands from within the code. But before illustrating, here is an example of creating a link to an item in the working folder. To create a relative path: Code Snippet (C#): String existing Item Path = "$/Developement/Tc Sample Project/Examples/Samples00/Test Plc/POUs/ MAIN. Tc POU"; Or an absolute path: String existing Item Path = C:/tfs/Developement/Tc Sample Project/Examples/Test Plc/POUs/MAIN. Tc POU"; To get the latest version of the item in the example, add following line of code: Code Snippet (C#): String existing Item Path = "$/Team Project Name/Folder/Sub Folder"; Get Request item Request = new Get Request(new Item Spec(existing Item Path, Recursion Type. Full), Version Spec. Latest); existing Workspace. Get(item Request, Get Options. Get All); Here the Recursion Type. Full executes the request on all the items under the item node but you can select it depending on your application’s requirement and existing item hierarchy. For more information please refer to the API documentation on MSDN. Getting a list of pending changes You can also get a list of pending changes made to the item or a collection of items with following line of code: Code Snippet (C#): Pending Change[] pending Changes = existing Workspace. Get Pending Changes(existing Item Path, Recursion Type. Full); For collection of items, consider the overloaded variance with Item[] as argument. Checking-In and Checking-Out You can check out an item or a collection of items for editing: Code Snippet (C#): int checkout Result = existing Workspace. Pend Edit(existing Item Path, Recursion Type. Full); To check-in the collection of pending changes to an item by: Code Snippet (C#): Automation Interface Version: 1.5 33

## Page 34

Configuration int checkin Result = workspace. Check In(pending Changes, usercomment); Undo an operation To Undo an operation, simply execute: Code Snippet (C#): int undo Result = existing Workspace. Undo(existing Item Path, Recursion Type. Full); 4.3.1.3 Setting Twin CAT target platform This article describes how to set the Twin CAT target platform via Automation Interface code. The target platform determines for which target the Twin CAT configuration should be compiled, e.g. Twin CAT x86 or Twin CAT x64, and is usually set from within a Twin CAT XAE toolbar in Visual Studio. The following code snippet assumes that you already have a DTE instance that links to a Twin CAT configuration. It checks for the currently set target platform and re-sets it to another platform. Code Snippet (C#): ITc Sys Manager system Manager = pro. Object; ITc Sys Manager7 sys Man Platform = (ITc Sys Manager7) system Manager; ITc Config Manager config Manager = (ITc Config Manager) sys Man Platform. Configuration Manager; if (config Manager. Active Target Platform == "Twin CAT RT (x86)") config Manager. Active Target Platform = "Twin CAT RT (x64)"; else config Manager. Active Target Platform = "Twin CAT RT (x86)"; Code Snippet (Powershell): $config Manager = $system Manager. Configuration Manager if ($config Manager. Active Target Platform -eq "Twin CAT RT (x86)"){ $config Manager. Active Target Platform = "Twin CAT RT (x64)"} else {$config Manager. Active Target Platform = "Twin CAT RT (x86)"} NOTE Changing target hardware platform or remote target with Twin CAT configuration This article describes how to change the target hardware platform. If you want to change the actual remote target to which the Twin CAT configuration should be written, please use the ITc Sys Manager::Set Target- Net Id() method. The following code snippet demonstrates how to acquire access to the Visual Studio Configuration Manager and enable or disable single Twin CAT sub projects (PLC, C++, …) for the build process. The snippet assumes that the currently opened Twin CAT project is named “Twin CAT Project1” and that it includes a PLC project “Untitled1”. It then disables the PLC project for the build process. Code Snippet (C#): Env DTE. Solution Contexts solution Contexts = solution. Solution Build. Active Configuration. Solution Contexts; foreach (Env DTE. Solution Context solution Context in solution Contexts) { switch(solution Context. Project Name) { case "Twin CAT Project13\\Untitled1\\Untitled1.plcproj": solution Context. Should Build = false; break; } } Code Snippet (Powershell): $solution Contexts = $sln. Solution Build. Active Configuration. Solution Contexts foreach ($solution Context in $solution Contexts) { if($solution Context. Project Name -eq "Test Solution\\Untitled1\\Untitled1.plcproj") { 34 Version: 1.5 Automation Interface

## Page 35

Configuration $solution Context. Should Build = $false } } 4.3.1.4 Attaching to an existing Visual Studio instance The following code snippets demonstrate how to attach to an existing (already running) instance of Visual Studio. The snippets have been written in C#. The sample consists of three different methods that depend on each other. Of course, you may change this accordingly so that it better fits your application environment. The following table explains each method in more detail. Method Description get Running Object Table() Queries the Running Object Table (ROT) for a snapshot of all running processes in the table. Returns all found processes in a Hashtable, which are then used by get Ide Instances() for further filtering for DTE instances. get Ide Instances() Searches for DTE instances in the ROT snapshot and returns a Hashtable with all found instances. This Hashtable may then be used by the method attach To Existing Dte() to select single DTE instances. You may change the query for candidate Name according to a more specific Visual Studio prog Id [} 30] , e.g. "Visual Studio. DTE.11.0" to query for Visual Studio 2012 instances. attach To Existing Dte() Uses the get Ide Instances() method to select a DTE instance based on its solution path and, when found, attaches a new DTE object to this instance. get Running Object Table() public static Hashtable Get Running Object Table() { Hashtable result = new Hashtable(); int num Fetched; UCOMIRunning Object Table running Object Table; UCOMIEnum Moniker moniker Enumerator; UCOMIMoniker[] monikers = new UCOMIMoniker[1]; Get Running Object Table(0, out running Object Table); running Object Table. Enum Running(out moniker Enumerator); moniker Enumerator. Reset(); while (moniker Enumerator. Next(1, monikers, out num Fetched) == 0) { UCOMIBind Ctx ctx; Create Bind Ctx(0, out ctx); string running Object Name; monikers[0]. Get Display Name(ctx, null, out running Object Name); object running Object Val; running Object Table. Get Object(monikers[0], out running Object Val); result[running Object Name] = running Object Val; } return result; } Please note that you need to explicitely reference the Create Bind Ctx() method as a Dll Import from the ole32.dll, e.g.: [Dll Import("ole32.dll")] private static extern int Create Bind Ctx(uint reserved, out IBind Ctx ppbc); get Ide Instances() public static Hashtable Get IDEInstances(bool open Solutions Only, string prog Id) { Hashtable running IDEInstances = new Hashtable(); Hashtable running Objects = Get Running Object Table(); Automation Interface Version: 1.5 35

## Page 36

Configuration IDictionary Enumerator rot Enumerator = running Objects. Get Enumerator(); while (rot Enumerator. Move Next()) { string candidate Name = (string)rot Enumerator. Key; if (!candidate Name. Starts With("!" + prog Id)) continue; Env DTE. DTE ide = rot Enumerator. Value as Env DTE. DTE; if (ide == null) continue; if (open Solutions Only) { try { string solution File = ide. Solution. Full Name; if (solution File != String. Empty) running IDEInstances[candidate Name] = ide; } catch { } } else running IDEInstances[candidate Name] = ide; } return running IDEInstances; } attach To Existing Dte() public Env DTE. DTE attach To Existing Dte(string solution Path) { Env DTE. DTE dte = null; Hashtable dte Instances = Get IDEInstances(false, prog Id); IDictionary Enumerator hashtable Enumerator = dte Instances. Get Enumerator(); while (hashtable Enumerator. Move Next()) { Env DTE. DTE dte Temp = hashtable Enumerator. Value as Env DTE. DTE; if (dte Temp. Solution. Full Name == solution Path) { Console. Write Line("Found solution in list of all open DTE objects. " + dte Temp. Name); dte = dte Temp; } } return dte; } 4.3.1.5 Accessing window tabs in Visual Studio The Visual Studio Automation Interface provides methods and properties to access active windows in Visual Studio. The following chapter demonstrates some sample code. However, we also suggest to investigate the webpages of the Microsoft Developer Network (MSDN) for more detailed information about the Visual Studio object model. This chapter provides sample code for the following tasks: • Accessing active windows • Closing active windows • Opening windows from Twin CAT PLC configuration Accessing active windows The DTE interface provides a property called "Active Window", which returns the currently active window in Visual Studio as an object of type Env DTE. Window. Code Snippet (C#): Env DTE. Window active Win = dte. Active Window; Code Snippet (Powershell): $active Win = $dte. Active Window 36 Version: 1.5 Automation Interface

## Page 37

Configuration Closing active windows Depending on the customers application, it may be necessary to close all active windows in Visual Studio before proceeding with the Twin CAT configuration via Automation Interface. The following code snippet closes all active windows but the "Solution Explorer". Code Snippet (C#): try { while (!dte. Active Window. Caption. Contains("Solution Explorer")) dte. Active Window. Close(); } catch (Invalid Operation Exception ex) { // use DTE. Quit() to close main window } Opening windows from Twin CAT PLC configuration It is also possible to open windows from Twin CAT PLC, e.g. a visualization. The following code snippet opens an existing Twin CAT visualization from PLC project "Untitled1" and makes it the currently active window. Code Snippet (C#): string file Name = @"C:\Twin CAT Project1\Twin CAT Project1\Untitled1\VISUs\Visu. Tc VIS"; dte. Item Operations. Open File(file Name); Code Snippet (Powershell): $file Name = @"C:\Twin CAT Project1\Twin CAT Project1\Untitled1\VISUs\Visu. Tc VIS" dte. Item Operations. Open File($file Name) 4.3.1.6 Accessing the Error List window of Visual Studio This chapter describes how to get access to the Visual Studio Error List window. Because Twin CAT 3 integrates itself into the Visual Studio shell, reading the content of this window can be essential for debugging and diagnostic purposes. To read the content of this window, you need to access the Visual Studio COM interface. Because this COM interface is also needed to access Twin CAT XAE (e.g. as described in our article Accessing Twin CAT configuration [} 20]), you don't need to add any additional references to your program code. The following documentation describes how to access the Error List window, which can be very helpful, for example if you want to compile a PLC project and want to check the compile process for any error messages. The Error List window displays status messages for various features in the Visual Studio (and therefore Twin CAT) development environment. These features for example include build errors that occur when a project is compiled or licensing issues. Reading the content of this window can be essential, e.g. to check if any errors occured while compiling a PLC project. The following code snippet shows how to read the content of this window using a C# application. Code Snippet (C#): Error Items errors = dte. Tool Windows. Error List. Error Items; for (int i = 1; i < errors. Count; i++) { Error Item item = errors. Item(i); } Automation Interface Version: 1.5 37

## Page 38

Configuration Please note that the property “Tool Windows” is available in namespace Env DTE80. DTE2. Code Snippet (Powershell): $errors = $dte. Tool Windows. Error List. Error Items for ($i=1; $i –lt $errors. Count; $i++) { $item = $errors. Item($i); } As you can see, the property Error Items returns a collection of all items in the Error List, where each item is of type Error Item. You can iterate through this collection for example by making use of its Count property. Each Error Item object has the following properties, which are identical to the columns in the Error List window (compare to screenshot above): Property Description Description Describes the error message. File Name Filename where the error occured. Line Line in which the error occured. Column Column in which the error occured. Project Project in which the error occured. Please note that the last four properties are not always used or don't make sense in every situation. For example, when looking at the screenshot above, the error message "No license found" is not bound to a specific file, line or column because it is a general Twin CAT error message. 4.3.2 Licensing 4.3.2.1 Configuration of licensing hardware The following article describes how to configure licensing hardware (e.g. an EL6070 terminal). Essentially, this concerns the selection and configuration of the device in the Twin CAT licensing dialogs. As a requirement for the following steps, the corresponding licensing hardware must be present in the I/O part of the Twin CAT configuration, e.g. in the case of an EL6070: Finding all existing licensing devices A check for all existing licensing hardware can be performed by exporting the XML description to the "License" node of the Twin CAT configuration. Code snippet (C#): Itc Sm Tree Item license = system Manager. Lookup Tree Item("TIRC^License"); string xml Description = license. Produce Xml(); Code snippet (Powershell): 38 Version: 1.5 Automation Interface

## Page 39

Configuration $license = $system Manager. Lookup Tree Item("TIRC^License"); $xml Description = $license. Produce Xml(); The XML description lists the available licensing hardware, for example: <Tree Item> <Item Name>License</Item Name> <Path Name>TIRC^License</Path Name> <Item Type>59</Item Type> <License Def> <Available License Devices> <License Device> <Name>Term 2 (EL6070)</Name> <Path Name>TIID^Device 1 (Ether CAT)^Term 1 (EK1100)^Term 2 (EL6070)</Path Name> <Type Name>EL6070 1Ch. Licensing-Terminal</Type Name> <Object ID>50462722</Object ID> </License Device> </Available License Devices> <Commands> <Activate Response File/> </Commands> </License Def> </Tree Item> Selecting a licensing device To add licensing hardware to the Twin CAT license configuration, either the device name or its Object ID can be used. The former is well-suited if the device name is known, e.g. if the I/O device was generated in advance. The latter can be determined from the XML description above. Code snippet (C#): Itc Sm Tree Item el6070dev1 = license. Create Child("Name Of Device", 0, null, "Term 2 (EL6070)"); // Device Name Itc Sm Tree Item el6070dev2 = license. Create Child("Name Of Device", 0, null, "50462722"); // Object ID Code snippet (Powershell): $el6070dev1 = $license. Create Child("Name Of Device", 0, $null, "Term 2 (EL6070)"); // Device Name $el6070dev2 = $license. Create Child("Name Of Device", 0, $null, "50462722"); // Object ID System requirements Required Twin CAT version Twin CAT v3.1.4022.4 4.3.2.2 Activating license response files The following article describes how license response files can be loaded via the Twin CAT Automation Interface. This function is provided via the XML description of the "License" node. <Tree Item> <Item Name>License</Item Name> <Path Name>TIRC^License</Path Name> <Item Type>59</Item Type> <License Def> <Commands> <Activate Response File> <Path>...</Path> <Oem Guid>...</Oem Guid> </Activate Response File> </Commands> </License Def> </Tree Item> The <Path> to the license response file can be specified in the XML area <Activate Response File>. This XML document can then be loaded via a Consume Xml() to the "License" node in order to activate the license response file. The parameter <Oem Guid> is only required in special cases and can be given any value, e.g. 0. Code snippet (C#): Automation Interface Version: 1.5 39

## Page 40

Configuration Itc Sm Tree Item license = system Manager. Lookup Tree Item("TIRC^License"); license. Consume Xml(xml Description From Above); System requirements Required Twin CAT version Twin CAT v3.1.4022.4 4.3.3 System 4.3.3.1 Opening and activating existing configurations To activate a previously created configuration, an instance of the Twin CAT XAE has to be created, the configuration has to be loaded and activated. Procedure The Prog Id "Visual Studio. DTE.10.0" is used to create an instance of Visual Studio. Via Visual Studios DTE object a full control of Visual Studio is possible. The Procedure to create the ITc Sys Manager [} 116] interface (the 'sys Man' instance here) is described in the chapter Accessing Twin CAT Configurations. [} 20] Sample (CSharp): Please note, that, for this sample, you need to add both a reference to "Microsoft Developer Environment 10.0" and "Beckhoff Twin CAT XAE Base" to your project. using System; using System. Collections. Generic; using System. Linq; using System. Text; using Env DTE100; using System. IO; using TCat Sys Manager Lib; namespace Activate Previous Configuration { class Program { static void Main(string[] args) { Type t = System. Type. Get Type From Prog ID("Visual Studio. DTE.10.0"); Env DTE. DTE dte = (Env DTE. DTE)System. Activator. Create Instance(t); dte. Suppress UI = false; dte. Main Window. Visible = true; Env DTE. Solution sol = dte. Solution; sol. Open(@"C:\Temp\Solution Folder\My Solution1\My Solution1.sln"); Env DTE. Project pro = sol. Projects. Item(1); ITc Sys Manager sys Man = pro. Object; sys Man. Activate Configuration(); sys Man. Start Restart Twin CAT(); } } } Sample (Power Shell): $prj Dir = "C:\tmp\Test Solution\" $prj Name = "Test Solution.sln" $prj Path = $prj Dir += $prj Name $dte = new-object -com Visual Studio. DTE.10.0 $dte. Suppress UI = $false $dte. Main Window | %{$_.gettype(). Invoke Member("Visible","Set Property",$null,$_,$true)} $sln = $dte. Solution $sln. Open($prj Path) 40 Version: 1.5 Automation Interface

## Page 41

Configuration $project = $sln. Projects. Item(1) $system Manager = $project. Object $system Manager. Activate Configuration() $system Manager. Start Restart Twin CAT() Sample (VBScript): dim dte,sln,proj,sys Man set dte = Create Object("Visual Studio. DTE.10.0") set sln = dte. Solution call sln. Open("C:\Solution Folder\My Solution1.sln") set proj = sln. Projects(1) set sys Man = proj. Object call sys Man. Activate Configuration call sys Man. Start Restart Twin CAT 4.3.3.2 Opening existing projects from a Twin CAT Target This documentation article describes how to open existing Twin CAT projects from a connected Twin CAT Target. The Target needs to be available, which means that ADS routes have to be present in order to be able to retrieve the project from the Target. The following code snippet demonstrates how to retrieve the Twin CAT project from a connected Target Runtime. Code snippet (C#): dte. Execute Command("File. Open Project From Target", "CX-123456 C:\\Project Dir Project Name"); Code snippet (Powershell): $dte. Execute Command("File. Open Project From Target", "CX-123456 C:\\Project Dir Project Name"); The method Execute Command() from the Visual Studio API allows to trigger the Twin CAT command (File. Open Project From Target) to open the project from a connected Twin CAT Target. The three parameters are to be included in the second parameter of the Execute Command() method. These three parameters are: Route name to Target, local project directory (where the project files should be stored), local project name. All three parameters are to be separated with a space from each other. 4.3.3.3 Creating and handling variable mappings A very common scenario in which the Twin CAT Automation Interface is being used, is to automatically create variable mappings, e.g. between PLC input/output variables and their corresponding I/O counterparts. The Automation Interface provides several methods that simplify the task to create, delete or save variable mappings. The following documentation article briefly describes these methods and gives examples on how to use them. The following topics are covered: • General information • Link variables • Unlink variables • Get/Set all variable mappings • Delete all variable mappings General information Variable mappings may occur between different input/output tree items in a Twin CAT project, for example: • Between PLC input/output variables and I/O (and vice versa) • Between PLC input/output variables and NC (and vice versa) • Between PLC input/output variables and Tc COM objects (and vice versa) • … Automation Interface Version: 1.5 41

## Page 42

Configuration The information in this article describes Automation Interface mechanisms which may be used for all of these use cases. Link variables From an Automation Interface point-of-view, variable mappings are always being performed between two tree items, e.g. between a PLC input/output variable and its corresponding I/O counterpart. To link two tree items, the Automation Interface provides the method ITc Sys Manager::Link Variables() which links a given source tree item with a given destination tree item. Code snippet (C#): string source = "TIPC^Plc Proj^Plc Proj Instance^Plc Task Inputs^b In"; string destination = "TIID^Ether CAT^EK1100^EL1004^Channel 1^Input"; system Manager. Link Variables(source, destination); Code snippet (Powershell): $source = "TIPC^Plc Proj^Plc Proj Instance^Plc Task Inputs^b In" $destination = "TIID^Ether CAT^EK1100^EL1004^Channel 1^Input" $system Manager. Link Variables($source, $destination) Unlink variables Similar to linking variables, the Automation Interface provides a method ITc Sys Manager::Unlink Variables() which releases the link between a given source tree item and a given destination tree item. Code snippet (C#): string source = "TIPC^Plc Proj^Plc Proj Instance^Plc Task Inputs^b In"; string destination = "TIID^Ether CAT^EK1100^EL1004^Channel 1^Input"; system Manager. Unlink Variables(source, destination); Code snippet (Powershell): $source = "TIPC^Plc Proj^Plc Proj Instance^Plc Task Inputs^b In" $destination = "TIID^Ether CAT^EK1100^EL1004^Channel 1^Input" $system Manager. Unlink Variables($source, $destination) Save/Restore all variable mappings To save or restore all variable mappings in a Twin CAT project, the methods ITc Sys Manager2::Produce Mapping Info() and ITc Sys Manager2::Consume Mapping Info() can be used. The former reads all variable mappings in a Twin CAT project and returns them in an XML structure that can be re-imported later by using the latter method. Code snippet (C#): ITc Sys Manager2 system Manager2 = (ITc Sys Manager2)system Manager; string mapping Info = system Manager2. Produce Mapping Info(); system Manager2. Consume Mapping Info(mapping Info); Code snippet (Powershell): $mapping Info = $system Manager. Produce Mapping Info() $system Manager. Consume Mapping Info($mapping Info) Delete all variable mappings To delete all variable mappings in a Twin CAT project, the method ITc Sys Manager3. Clear Mapping Info() may be used. Code snippet (C#): ITc Sys Manager3 system Manager = (ITc Sys Manager3)system Manager; system Manager. Clear Mapping Info(); Code snippet (Powershell): $system Manager. Clear Mapping Info() 42 Version: 1.5 Automation Interface

## Page 43

Configuration 4.3.3.4 Creating and handling Tasks This article explains how to create and handle Tasks via Twin CAT Automation Interface. It consists of the following topics: • General information • Inserting Tasks • Inserting input/output variables General information There are two types of Tasks which can be configured in Twin CAT XAE and therefore also via Automation Interface: Tasks with Process Image and without. When you insert a new Task in Twin CAT XAE, you can decide whether you want to include a Process Image or not by selecting the corresponding checkbox in the "Insert Task" dialog. As a result, the inserted Task either includes three more child nodes (Image, Inputs, Outputs) or not - as the following example shows (Task 1 = With Image, Task 2 = Without Image). Inserting Tasks To insert a Task via Automation Interface, you can make use of the ITc Sm Tree Item [} 124]::Create Child() [} 160] method and the corresponding Sub Types for "With Image" (Sub Type = 0) and "Without Image" (Sub Type = 1). Code Snippet (C#) ITc Sm Tree Item tasks = system Manager. Lookup Tree Item("TIRT"); tasks. Create Child("Task 1 (With Image)", 0, null, null); Code Snippet (Powershell): $tasks = $system Manager. Lookup Tree Item("TIRT") $tasks. Create Child("Task 1 (With Image)", 0, $null, $null) Code Snippet (C#) Automation Interface Version: 1.5 43

## Page 44

Configuration ITc Sm Tree Item tasks = system Manager. Lookup Tree Item("TIRT"); tasks. Create Child("Task 2 (Without Image)", 1, null, null); Code Snippet (Powershell): $tasks = $system Manager. Lookup Tree Item("TIRT") $tasks. Create Child("Task 1 (Without Image)", 1, $null, $null) Inserting input/output variables You can add Input/Output variables to process images (Task "With Image"), which can then be linked with I/ O devices or variables from other Tasks. The corresponding dialog from Twin CAT XAE lets you choose e.g. the data type and address of the input/output variable in the process image. By clicking on "Ok", the variable will be added to the process image. This procedure can also be triggered via Automation Interface by using the ITc Sm Tree Item [} 124]::Create Child() [} 160] method with the corresponding variable data type as v Info. In this case the Sub Type specifies the "Start Address", as shown in the dialog above. Code Snippet (C#): ITc Sm Tree Item task1 = system Manager. Lookup Tree Item("TIRT^Task 1 (With Image)^Inputs"); task1. Create Child("b Input", -1, null, "BOOL"); Code Snippet (Powershell): $task1 = $system Manager. Lookup Tree Item("TIRT^Task 1 (With Image)^Inputs") $task1. Create Child("b Input", -1, $null, "BOOL") By using Sub Type = -1, Twin CAT automatically attaches the new variable at the end of the variable list. 4.3.3.5 Using Templates The following article describes how to use templates instead of configuring every single setting separately via Automation Interface. The usage of templates provides many advantages: they are easier to maintain, easier to replace with new templates, and they provide great possibilities when working with multiple teams on one Twin CAT project. This document describes the usage of templates and covers the following topics: • The general idea behind templates and its different levels • Working with I/O templates • Working with Motion templates (axes) 44 Version: 1.5 Automation Interface

## Page 45

Configuration • Working with PLC templates The general idea behind templates and its different levels The idea behind the usage of templates is to simplify Automation Interface code and the Automation Interface application itself. Most users are not aware that, in a Twin CAT configuration, templates can exist on multiple levels. These include: • Templates on “configuration level” • Templates on configuration level may exist as several Twin CAT configurations (*.sln or *.tszip file). Each configuration may include different content and can be opened and activated by Automation Interface code. • Templates on “(PLC) project level” • Templates on (PLC) project level may exist as several Twin CAT PLC Projects, either as an unpacked folder structure (*.plcproj file) or as a container (*.tpzip) file. These PLC Projects can then be imported on demand via Automation Interface code. • Templates on “tree item level” • Templates on tree item level may exist as so-called Twin CAT export files (*.xti). These files can be imported on demand via Automation Interface code and contain all settings of a tree item, e.g. settings that have been made to an Ether CAT Master I/O device. As the description from above might suggest, all different template levels have one thing in common: the templates exist as files in the file system. It is best practice that, at the beginning of implementing an own Automation Interface application, one clearly defines what kind of “template pool” is being used. A template pool describes a repository, where all template files (which might also be a mix of different template levels) are being stored. This could simply be the local (or remote) file system, or might also be a source control system (e.g. Team Foundation Server), from which template files are automatically retrieved, checked out and put together to a new Twin CAT configuration. For your convenience and to make the first steps easier for you, we have prepared a separate documentation article that demonstrates how to use the Visual Studio Object Model (DTE) to connect to a Team Foundation Server (TFS) and execute these operations via program code. However, to get more information about using TFS via Automation Interface code, we heavily suggest to read the corresponding articles from the Microsoft Developer Network (MSDN). The following topics describe how each template level can be used in Automation Interface for a different Twin CAT area (I/O, PLC, …). Working with configuration templates Templates on configuration level provide the most basic way of using templates. In this scenario, a template pool holds two or more pre-configured Twin CAT configurations and provides them as Twin CAT Solution files (*.sln or *.tszip). These files can be opened via Automation Interface by using the Visual Studio method Add From Template(). Code Snippet (C#): project = solution. Add From Template(@"C:\Twin CAT Project.tszip", destination, project Name); Code Snippet (Powershell): $project = $solution. Add From Template(@"C:\Twin CAT Project.tszip", $destination, $project Name) OR Code Snippet (C#): project = solution. Open(@"C:\Twin CAT Project 1.sln"); Code Snippet (Powershell): $project = $solution. Open(@"C:\Twin CAT Project 1.sln") Automation Interface Version: 1.5 45

## Page 46

Configuration Working with I/O templates When working with I/O devices, users often experience the same tasks on I/O devices over and over again. That means, making the same settings to I/O devices with each Twin CAT configuration. Twin CAT provides a mechanism that stores all these settings in a special file format, the so-called XTI file (*.xti). This file format can be used by Automation Interface code to be imported to a new configuration by using the method Import Child() which is defined in the interface ITc Sm Tree Item. Code Snippet (C#): ITc Sm Tree Item io = system Manager. Lookup Tree Item("TIID"); ITc Sm Tree Item new Io = io. Import Child(@"C:\Io Template.xti", "", true, "Some Name"); Code Snippet (Powershell): $io = $system Manager. Lookup Tree Item("TIID") $new Io = $io. Import Child(@"C:\Io Template.xti", "", true, "Some Name") It is important to note that, if you export an I/O device from within Twin CAT XAE, that all sub devices are automatically exported and included in the export file as well. The following screenshot shows how to export I/O devices into an export file. Please note that you could also use the Automation Interface to export an I/O device into an XTI file. For this, the method Export Child() from the ITc Sm Tree Item interface is provided. Working with Motion templates (axes) The usage of Motion axes templates is very similar to I/O devices. Axes can also be exported into an XTI-file, either via Twin CAT XAE or via Automation Interface code by using Export Child(). By using Import Child(), these export files can later be imported again. 46 Version: 1.5 Automation Interface

## Page 47

Configuration Code Snippet (C#): ITc Sm Tree Item motion Axes = system Manager. Lookup Tree Item("TINC^NC-Task^Axes"); motion Axes. Import Child(@"C:\Axis Templates.xti", "", true, "Axis 1"); Code Snippet (Powershell): $motion Axes = $system Manager. Lookup Tree Item("TINC^NC-Task^Axes") $motion Axes. Import Child(@"C:\Axis Templates.xti", "", true, "Axis 1") Working with PLC templates PLC templates are available in two units: You can either use the complete PLC projects as a whole or each POU individually as a templates. To integrate the former into an existing Twin CAT project, simply use the Create Child() method of the ITc Sm Tree Item interface. Code Snippet (C#): ITc Sm Tree Item plc = system Manager. Lookup Tree Item("TIPC"); plc. Create Child("New Plc Project", 0, null, path To Tpzip Or Tc Proj File); Code Snippet (Powershell): $plc = $system Manager. Lookup Tree Item("TIPC") $plc. Create Child("New Plc Project", 0, $null, $path To Tpzip Or Tc Proj File) More options to import existing PLC projects can be found in the best practice article about “Accessing, creating and handling PLC projects”. The next granularity level of importing template files for the PLC is to import existing POUs, like function blocks, structs, enums, global variable lists, etc. One of the reasons a developer may choose individual POUs as templates, is that it is easier to build a pool of existing functionalities and encapsulate them in separate POUs, e.g. different function blocks covering different sorting algorithms. Upon project creation, the developer simply chooses which functionality he needs in his Twin CAT project and accesses the template tool to retrieve the corresponding POU and import it to his PLC project. Code Snippet (C#): ITc Sm Tree Item plc Project = system Manager. Lookup Tree Item(“TIPC^Name^Name Project”); plc Project. Create Child(“Name Of Pou”, 58, null, path To Pou File); plc Project. Create Child(null, 58, null, string Array With Paths To Pou Files); Code Snippet (Powershell): $plc Project = $system Manager. Lookup Tree Item("TIPC^Name^Name Project") $plc Project. Create Child("Name Of Pou", 58, $null, $path To Pou File) $plc Project. Create Child($null, 58, $null, $string Array With Paths To Pou Files) NOTE Importing one or more templates A POU template file may not only be a . Tc Pou file but also the corresponding files for DUTs and/or GVLs. The example above demonstrates two common ways to import POU template files. The first is to import a single file, the second to import multiple files at once by storing the file paths to a string array and using this string array as the v Info parameter of Create Child(). 4.3.3.6 Accessing Twin CAT Remote Manager This documentation article describes how to access the Twin CAT Remote Manager functionality via Automation Interface. The Twin CAT Remote Manager allows to switch between different Twin CAT 3 XAE versions that have been installed on the same engineering computer. To access the Remote Manager via Automation Interface, simply execute the following code snippets. Code Snippet (C#): ITc Remote Manager remote Manager = dte. Get Object("Tc Remote Manager"); remote Manager. Version = "3.1.4020.0"; Code Snippet (Powershell): $remote Manager = $dte. Get Object("Tc Remote Manager") Automation Interface Version: 1.5 47

## Page 48

Configuration $remote Manager. Version = "3.1.4020.0" 4.3.3.7 Assigning tasks to CPU cores Procedure • Enabling the Cores for realtime usage. • Paremetrization of the Cores with the Load Limit, base cycle time (Base Time) and a Latency Watchdog • Assignment of Tasks to CPU resources. The following code snippets are also available for download in our Samples section. Sample (C#): ITc Sys Manager3 system Manager = null; [Flags()] public enum Cpu Affinity : ulong { CPU1 = 0x0000000000000001, CPU2 = 0x0000000000000002, CPU3 = 0x0000000000000004, CPU4 = 0x0000000000000008, CPU5 = 0x0000000000000010, CPU6 = 0x0000000000000020, CPU7 = 0x0000000000000040, CPU8 = 0x0000000000000080, None = 0x0000000000000000, Mask Single = CPU1, Mask Dual = CPU1 | CPU2, Mask Quad = Mask Dual | CPU3 | CPU4, Mask Hexa = Mask Quad | CPU5 | CPU6, Mask Oct = Mask Hexa | CPU7 | CPU8, Mask All = 0x FFFFFFFFFFFFFFFF } public void Assign CPUCores() { ITc Sm Tree Item realtime Settings = system Manager. Lookup Tree Item("TIRS"); // CPU Settings // <Tree Item> // <RTime Set Def> // <Max CPUs>3</Max CPUs> // <Affinity>#x0000000000000007</Affinity> // <CPUs> // <CPU id="0"> // <Load Limit>10</Load Limit> // <Base Time>10000</Base Time> // <Latency Warning>200</Latency Warning> // </CPU> // <CPU id="1"> // <Load Limit>20</Load Limit> // <Base Time>5000</Base Time> // <Latency Warning>500</Latency Warning> // </CPU> // <CPU id="2"> // <Load Limit>30</Load Limit> // <Base Time>3333</Base Time> // <Latency Warning>1000</Latency Warning> // </CPU> // </CPUs> // </RTime Set Def> // </Tree Item> string xml = null; Memory Stream stream = new Memory Stream(); String Writer string Writer = new String Writer(); using(Xml Writer writer = Xml Text Writer. Create(string Writer)) { writer. Write Start Element("Tree Item"); writer. Write Start Element("RTime Set Def"); writer. Write Element String("Max CPUs", "4"); string affinity String = string. Format("#x{0}",((ulong) cpu Affinity. Mask Quad). To String("x16")); writer. Write Element String("Affinity", affinity String); writer. Write Start Element("CPUs"); 48 Version: 1.5 Automation Interface

## Page 49

Configuration write Cpu Properties(writer, 0, 10, 1000, 10000, 200); write Cpu Properties(writer, 1, 20, 5000, 10000, 500); write Cpu Properties(writer, 2, 30, 3333, 10000, 1000); writer. Write End Element(); // CPUs writer. Write End Element(); // RTime Set Def writer. Write End Element(); // Tree Item } xml = string Writer. To String(); realtime Settings. Consume Xml(xml); ITc Sm Tree Item tasks = system Manager. Lookup Tree Item("TIRT"); ITc Sm Tree Item task1 = tasks. Create Child("Task A",1); set Task Properties(task1,Cpu Affinity. CPU1); ITc Sm Tree Item task2 = tasks. Create Child("Task B",1); set Task Properties(task2, Cpu Affinity. CPU2); ITc Sm Tree Item task3 = tasks. Create Child("Task C", 1); set Task Properties(task3, Cpu Affinity. CPU3); } private void set Task Properties(ITc Sm Tree Item task, Cpu Affinity affinity Mask) { // <Tree Item> // <Task Def> // <Cpu Affinity>#x0000000000000004</Cpu Affinity> // </Task Def> // </Tree Item> String Writer string Writer = new String Writer(); using(Xml Writer writer = new Xml Text Writer(string Writer)) { writer. Write Start Element("Tree Item"); writer. Write Start Element("Task Def"); string affinity String = string. Format("#x{0}", ((ulong)affinity Mask). To String("x16")); writer. Write Element String("Cpu Affinity",affinity String); writer. Write End Element(); writer. Write End Element(); } string xml = string Writer. To String(); task. Consume Xml(xml); } private void write Cpu Properties(Xml Writer writer, int id, int load Limit, int base Time, int latency Warning) { writer. Write Start Element("CPU"); writer. Write Attribute String("id", id. To String()); writer. Write Element String("Load Limit", load Limit. To String()); writer. Write Element String("Base Time", base Time. To String()); writer. Write Element String("Latency Warning", latency Warning. To String()); writer. Write End Element(); } 4.3.3.8 Configuring Twin CAT Boot settings The following documentation article describes how to configure the Twin CAT Boot settings via Automation Interface. For this the methods ITc Sm Tree Item::Produce Xml() and ITc Sm Tree Item::Consume Xml() can be used to generate or import the following XML structure, which represents the corresponding settings in Twin CAT XAE. <Tree Item> <System> <Boot Settings> <Auto Run>true</Auto Run> <Auto Logon>true</Auto Logon> <Logon User Name>User Name</Logon User Name> <Logon Password>Password</Logon Password> <Boot File Encryption Type>None</Boot File Encryption Type> </Boot Settings> </System> </Tree Item> Automation Interface Version: 1.5 49

## Page 50

Configuration 4.3.3.9 Activate or deactivate Independent Project File setting To enhance engineering experience with regard to Source Control integration, Twin CAT 3 provides the possibility to store settings in separate project files – called “Independent Project File”. This tree item based setting can also be activated/deactivated via Twin CAT Automation Interface. The interface ITc Sm Tree Item6 provides the necessary property. The following code snippet demonstrates how to activate this setting if it is deactivated, e.g. on an Ether CAT Master device. Code Snippet (C#): ITc Sm Tree Item6 ether Cat Master = (ITc Sm Tree Item6)system Manager. Lookup Tree Item("TIID^Device 1 (Ether CAT)"); if (ether Cat Master. Save In Own File == false) ether Cat Master. Save In Own File = true; Code Snippet (Powershell): $ether Cat Master = $system Manager. Lookup Tree Item("TIID^Device 1 (Ether CAT)") if ($ether Cat Master. Save In Own File -eq $false) { $ether Cat Master. Save In Own File = $true } 4.3.3.10 From offline to online configurations This article explains how to convert a Twin CAT configuration, which has been created 'offline', via Twin CAT Automation Interface to an online configuration. The term "offline" means that no physical I/Os are present at the time of configuration creation and therefore the real address information is not available, e.g. for an Ether CAT Master . The following topics are part of this article: • General information • Creating an offline configuration • Switching to an online configuration General information When creating a Twin CAT configuration, there are two common scenarios: • Scenario 1: this scenario is based on the real physical device, on which the Twin CAT configuration should run later. Therefore, all I/Os are online and already available and attached to the device. • Scenario 2: this scenario could involve to create the configuration offline (that means without any I/Os attached to the engineering device) and later switch to an online configuration when the I/Os are available. This is the scenario which will be the primary focus of this article. Both scenarios are possible via Twin CAT Automation Interface. However, as scenario 2 lacks some important information about some of the I/Os, e.g. their physical addresses, this scenario could be slightly more complex because you need to hand in the required (address) information later. The familiar Twin CAT XAE functionality "Scan Devices" plays a significant role in this use-case because it scans for all available I/O devices and automatically attaches them to the configuration - together with all needed additional information, e.g. physical addresses. 50 Version: 1.5 Automation Interface

## Page 51

Configuration On a physical controller, this functionality can also be called via Automation Interface and then returns an XML representation of all found I/O devices including their corresponding address information. When a Twin CAT configuration should be activated on the controller, the required address information needs to be set for all I/O devices that are part of the configuration. This can be done by calling the "Scan Devices" functionality via Automation Interface and setting the address information for the I/O devices in the configuration. This will be explained in more detail now. Creating an offline configuration There are several articles which explain how to create an offline Twin CAT configuration. Please refer to our Product Description [} 10] page to get an overview. Switching to an online configuration If you finally have created a Twin CAT configuration that should now be activated on the physical controller, the following steps need to be taken to ensure that all required address information is available before downloading the configuration: • Step 1 [optional]: Connecting to the target device • Step 2: Scanning the device for available I/Os • Step 3: Iterating through XML and configuring address information of I/Os • Step 4: Activating the configuration Of course, you can also always create an online configuration directly by using the Scan Devices functionality. There is an own sample [} 93] which shows you exactly how to do that. Step 1 [optional]: Connecting to the target device If the physical controller is not located on the same machine as the Automation Interface code runs on, you can use the ITc Sys Manager [} 116]::Set Target Net Id() [} 121] method to connect to the remote device and then continue with the next steps. Step 2: Scanning the device for available I/Os The "Scan Devices" functionality mentioned above can be triggered via Automation Interface by calling the ITc Sm Tree Item::Produce Xml() method on the I/O devices node. Code Snippet (C#): Automation Interface Version: 1.5 51

## Page 52

Configuration ITc Sm Tree Item io Devices = system Manager. Lookup Tree Item("TIID"); string found Devices = io Devices. Produce Xml(); Step 3: Iterating through XML and configuring address information of I/Os In this example we want to update the address information of an Ether CAT device which is already part of our offline configuration. The Produce Xml() in step 2 has already returned the available I/O devices on the system, which is now available in the variable 'found Devices'. We will identify the Ether CAT device in this XML via its item sub type (111) and then update the address information of the Ether CAT Master in our configuration. Code Snippet (C#): Xml Document doc = new Xml Document(); doc. Load Xml(found Devices); Xml Node List devices = doc. Select Nodes("Tree Item/Device Grp Def/Found Devices/Device"); foreach (Xml Node device in devices) { xml Node type Node = device. Select Single Node("Item Sub Type"); int sub Type = int. Parse(type Node. Inner Text); if (sub Type == 111) { Xml Node address Info = device. Select Single Node("Address Info"); ITc Sm Tree Item device To Update = system Manager. Lookup Tree Item("TIID^Ether CAT Master"); string xml Address = string. Format("<Tree Item><Device Def>{0}</Device Def></Tree Item>", address Info. Outer Xml); device To Update. Consume Xml(xml Address); } } Step 4: Activating the configuration The last step only involves activating the configuration on the target device. Simply use the ITc Sys Manager::Activate Configuration() method to do that. Code Snippet (C#): sys Manager. Activate Configuration(); 4.3.3.11 Access to Twin CAT variant management This article describes access to the functions of the Twin CAT variant management via the Automation Interface. Access is possible from i Tc Sys Manager14 (TCat Sys Manager Lib V 3.3.0.0). The following functions are supported: 1. Adding project variants and groups of variants 2. Setting the active variant 3. Activate settings for variant management 1. Adding project variants and groups of variants Code snippet (C#): string variant Config = "<?xml version=\"1.0\"?><Project Variants><Group><Name>Group1</ Name><Member>Variant1</Member><Member>Variant2</Member></Group><Group><Name>Group2</ Name><Member>Variant2</Member><Member>Variant3</Member></Group><Variant><Name>Variant1</Name></ Variant><Variant><Name>Variant2</Name></Variant><Variant><Name>Variant3</Name></Variant></ Project Variants>"; sys Manager. Project Variant Config = variant Config; 2. Setting the active variant Code snippet (C#): sys Manager. Current Project Variant = "Variant3"; sys Manager. Current Project Variant = "[Group1]"; 3. Activate settings for variant management Code snippet (C#): 52 Version: 1.5 Automation Interface

## Page 53

Configuration ITc Sm Tree Item9 el2004_1 = (ITc Sm Tree Item9)sys Manager. Lookup Tree Item("TIID^Ether CAT Master^EK1100-1^EL2004-1"); // activate the "disable" setting for the Variant Management el2004_1. Pv Disable = true; // choose a variant and disable it only for this variant sys Manager. Current Project Variant = "Variant3"; el2004_1. Disabled = DISABLED_STATE. SMDS_DISABLED; 4.3.4 ADS 4.3.4.1 Creating and handling ADS routes Adding ADS routes via the Automation Interface can be achieved by using the Consume Xml() method of the ITc Sm Tree Item interface. However, it is important to understand the underlying XML structure before adding routes to a remote target. XML structure The following code snippets represent sample XML structures for adding routes to a remote target. Please note that you can either specify the IP address or the hostname of the remote target. This code snippet will add a regular route to a remote target. Code Snippet (XML): <Tree Item> <Item Name>Route Settings</Item Name> <Path Name>TIRR</Path Name> <Route Prj> <Target List> <Broadcast Search>true</Broadcast Search> </Target List> <Add Route> <Remote Name>Route Name</Remote Name> <Remote Net Id>1.2.3.4.5.6</Remote Net Id> <Remote Ip Addr>1.2.3.4</Remote Ip Addr> <User Name>user Name</User Name> <Password>password</Password> <No Encryption></No Encryption> <Local Name>Local Name</Local Name> </Add Route> </Route Prj> </Tree Item> This code snippet will add a project route to a remote target. Code Snippet (XML): <Tree Item> <Item Name>Route Settings</Item Name> <Path Name>TIRR</Path Name> <Route Prj> <Target List> <Broadcast Search>true</Broadcast Search> </Target List> <Add Project Route> <Name>Route Name</Name> <Net Id>1.2.3.4.5.6</Net Id> <Ip Addr>1.2.3.4</Ip Addr> </Add Project Route> </Route Prj> </Tree Item> The following code snippet will use the hostname instead of the IP address. Code Snippet (XML): <Tree Item> <Item Name>Route Settings</Item Name> <Path Name>TIRR</Path Name> <Route Prj> <Target List> <Broadcast Search>true</Broadcast Search> Automation Interface Version: 1.5 53

## Page 54

Configuration </Target List> <Add Route> <Remote Name>Route Name</Remote Name> <Remote Net Id>1.2.3.4.5.6</Remote Net Id> <Remote Host Name>CX-12345</Remote Host Name> <User Name>user Name</User Name> <Password>password</Password> <No Encryption></No Encryption> <Local Name>Local Name</Local Name> </Add Route> </Route Prj> </Tree Item> And for project routes. Code Snippet (XML): <Tree Item> <Item Name>Route Settings</Item Name> <Path Name>TIRR</Path Name> <Route Prj> <Target List> <Broadcast Search>true</Broadcast Search> </Target List> <Add Project Route> <Name>Route Name</Name> <Net Id>1.2.3.4.5.6</Net Id> <Host Name>1.2.3.4</Host Name> </Add Project Route> </Route Prj> </Tree Item> Please note that the XML structure for regular and project routes may be used simultaneously. The following code snippet creates an ADS route to a remote target that has been specified by its IP address (10.1.128.217) and its AMS Net Id (10.1.128.217.1.1). Code Snippet (C#): string xml String ="<Tree Item><Item Name>Route Settings</Item Name><Path Name>TIRR</ Path Name><Route Prj><Target List><Broadcast Search>true</Broadcast Search></ Target List><Add Route><Remote Name>Route Name</Remote Name><Remote Net Id>10.1.128.217.1.1</ Remote Net Id><Remote Ip Addr>10.1.128.217</Remote Ip Addr><User Name>Administrator</User Name><Password>1</ Password><No Encryption></No Encryption></Add Route></Route Prj></Tree Item>"; ITc Sm Tree Item routes = system Manager. Lookup Tree Item("TIRR"); routes. Consume Xml(xml String); Code Snippet (Powershell): $xml String ="<Tree Item><Item Name>Route Settings</Item Name><Path Name>TIRR</ Path Name><Route Prj><Target List><Broadcast Search>true</Broadcast Search></ Target List><Add Route><Remote Name>Route Name</Remote Name><Remote Net Id>10.1.128.217.1.1</ Remote Net Id><Remote Ip Addr>10.1.128.217</Remote Ip Addr><User Name>Administrator</User Name><Password>1</ Password><No Encryption></No Encryption></Add Route></Route Prj></Tree Item>" $routes = $system Manager. Lookup Tree Item("TIRR") $routes. Consume Xml($xml String) 4.3.4.2 Execute an ADS broadcast search To trigger a Twin CAT Broadcast search and find unknown remote ADS devices, the Consume Xml() and Produce Xml() methods from the ITc Sm Tree Item interface may be used. General broadcast search Code Snippet (C#): string xml String = "<Tree Item><Route Prj><Target List><Broadcast Search>true</Broadcast Search></ Target List></Route Prj></Tree Item>"; ITc Sm Tree Item routes = sys Man. Lookup Tree Item("TIRR"); routes. Consume Xml(xml String); string result = routes. Produce Xml(); Code Snippet (Powershell): 54 Version: 1.5 Automation Interface

## Page 55

Configuration $xml String = "<Tree Item><Route Prj><Target List><Broadcast Search>true</Broadcast Search></Target List></ Route Prj></Tree Item>" $routes = $system Manager. Lookup Tree Item("TIRR") $routes. Consume Xml($xml String) $result = $routes. Produce Xml() The variable “result” now contains an XML representation of all found ADS devices on the network. To select a specific device from that list, regular . NET mechanisms for XML handling may be used. Code Snippet (C#): Xml Document xml Document = new Xml Document(); xml Document. Load(result); string ams Net Id = xml Document. Select Single Node("//Tree Item/Route Prj/Target List/Target/ Ip Addr[text()=\"" + ip Address + "\"]/../Net Id"). Inner Text; string name = xml Document. Select Single Node("//Tree Item/Route Prj/Target List/Target/Ip Addr[text()=\"" + ip Address + "\"]/../Name"). Inner Text; Code Snippet (Powershell): $xml Document = [xml]$result $local Ams Net Id = $xml Document. Tree Item. Route Prj. Target This information might then be used to add a route to that ADS device, as described in a separate documentation article. Direct broadcast search Requires at least Twin CAT 3.1 Build 4020.10 or higher. To execute a broadcast search with a given hostname or IP address, the following XML structures can be used in Consume Xml(). XML - Search for Hostname: <Tree Item> <Route Prj> <Target List> <Search>CX-12345</Search> </Target List> </Route Prj> </Tree Item> XML - Search for IP address: <Tree Item> <Route Prj> <Target List> <Search>172.17.60.153</Search> </Target List> </Route Prj> </Tree Item> A subsequent Produce Xml() will return the found host as follows: XML - Found host: <Tree Item> <Route Prj> <Target List> <Target> <Name>CX-12345</Name> <Net Id>172.17.60.153.1.1</Net Id> <Ip Addr>172.17.60.153</Ip Addr> <Version>3.1.4020</Version> <OS>Windows 7</OS> </Target> </Target List> Automation Interface Version: 1.5 55

## Page 56

Configuration </Route Prj> </Tree Item> 4.3.5 PLC 4.3.5.1 Accessing, creating and handling PLC projects This chapter explains in-depth how to create, access and handle PLC projects. The following list shows all chapters in this article: • General information about PLC projects • Creating and handling PLC projects • Opening existing PLC projects • Nested projects and project instances • Saving the PLC project as a library • Handling online functionalities (Login, Start Plc, Stop Plc) • Setting Boot project options • Saving project and/or solution as archive • Calling Check All Objects() General information about PLC projects PLC projects are specified by their so-called project template. Twin CAT currently deploys two templates which are represented by a template file in the Twin CAT directory. The following table shows which PLC templates are available and the corresponding template file: Template name Template file Standard PLC template C:\Twin CAT\3.x\Components\Plc\Plc Template\Plc Templates\Standard PLC Template.plcproj Empty PLC template C:\Twin CAT\3.x\Components\Plc\Plc Template\Plc Templates\Empty PLC Template.plcproj Creating and handling PLC projects To create a new PLC project via Automation Interface, you need to navigate to the PLC node and then execute the Create Child() method with the corresponding template file as a parameter. Code snippet (C#): ITc Sm Tree Item plc = system Manager. Lookup Tree Item("TIPC"); ITc Sm Tree Item new Project = plc. Create Child("Name Of Project", 0, "", path To Template File); Code snippet (Powershell): $plc = $system Manager. Lookup Tree Item("TIPC") $new Project = $plc. Create Child("Name Of Project", 0, "", path To Template File) Please note When using standard PLC templates as provided by Beckhoff, please make sure to only use the template name instead of the full path, e.g. “Standard PLC Template”. All subsequent operations, like creating and handling POUs and filling them with code, are described in a separate article. After the PLC project has been created, it can be further handled by casting it to the special interface ITc Plc IECProject [} 168], which provided more functionalities and access to the projects specific attributes: Code snippet (C#): 56 Version: 1.5 Automation Interface

## Page 57

Configuration ITc Sm Tree Item plc Project = system Manager. Lookup Tree Item("TIPC^Name Of Project^Name Of Project Project"); ITc Plc IECProject iec Project = (ITc Plc IECProject) plc Project; Code snippet (Powershell): $plc Project = $system Manager. Lookup Tree Item("TIPC^Name Of Project^Name Of Project Project") The object "iec Project" can now be used to access the methods of the ITc Plc IECProject interface, e.g. to save the PLC project as a PLC library. Opening existing PLC projects To open an existing PLC-Project via Automation Interface, you need to navigate to the PLC node and then execute the Create Child() method with the path to the corresponding PLC project file file as a parameter. You can use three different values as Sub Type: • 0: Copy project to solution directory • 1: Move project to solution directory • 2: Use original project location (when used, please use "" as project name parameter) Basically, these values represent the functionalities (Yes, No, Cancel) from the following Message Box in Twin CAT XAE: In place of the template file you need to use the path to the PLC project (to its plcproj file) that needs to be added. As an alternative, you can also use a PLC project archive (tpzip file). Code snippet (C#): ITc Sm Tree Item plc = system Manager. Lookup Tree Item("TIPC"); ITc Sm Tree Item new Project = plc. Create Child("Name Of Project", 1, "", path To Project Or Tpzip File); Code snippet (Powershell): $plc = $system Manager. Lookup Tree Item("TIPC") $new Project = $plc. Create Child("Name Of Project", 1, "", path To Project Or Tpzip File) Twin CAT PLC Projects consist of two different areas – the so-called Nested Project and the Project Instance. The Nested Project (tree item sub type 56) contains the source code of the PLC program whereas the Project Instance contains the declared input and output variables of the PLC program. The following code snippet demonstrates a common way to generically access both tree items, if the full path name is not known. Automation Interface Version: 1.5 57

## Page 58

Configuration Code Snippet (C#): ITc Sm Tree Item plc = sys Manager. Lookup Tree Item("TIPC"); foreach (ITc Sm Tree Item plc Project in plc) { ITc Project Root project Root = (ITc Project Root)plc Project; ITc Sm Tree Item nested Project = project Root. Nested Project; ITc Sm Tree Item project Instance = plc Project.get_Child(1); } Code snippet (Powershell): $plc = $sys Manager. Lookup Tree Item("TIPC") For Each( $plc Project in $plc) { $nested Project = $plc Project. Nested Project $project Instance = $plc Project.get_Child(1) } Please note A minimum of Twin CAT 3.1 Build 4018 is required to access the interface ITc Project Root. Saving the PLC project as a library To save a PLC project as a PLC library, you need to make use of the ITc Plc IECProject [} 168]::Save As Library() [} 171] method. Code snippet (C#): iec Project. Save As Library(path To Library File, false); Code snippet (Powershell): $plc Project. Save As Library(path To Library File, $false) The second parameter determines whether the library should be installed to the default repository after it has been saved as a file. Handling online functionalities (Login, Start Plc, Stop Plc, Reset Cold, Reset Origin) Required version: Twin CAT 3.1 Build 4010 and above The Automation Interface also provides you with PLC online features, for example to login to a PLC runtime and start/stop/reset the PLC program. These features can be accessed via the ITc Sm Tree Item [} 124]::Produce Xml() [} 158] and ITc Sm Tree Item [} 124]::Consume Xml() [} 159] methods. These functions can be used on a ITc Plc IECProject [} 168] node. XML structure: <Tree Item> <IECProject Def> <Online Settings> <Commands> <Login Cmd>false</Login Cmd> <Logout Cmd>false</Logout Cmd> <Start Cmd>false</Start Cmd> <Stop Cmd>false</Stop Cmd> </Commands> </Online Settings> </IECProject Def> </Tree Item> Code snippet (C#): string xml = "<Tree Item><IECProject Def><Online Settings><Commands><Login Cmd>true</Login Cmd></ Commands></Online Settings></IECProject Def></Tree Item>"; ITc Sm Tree Item plc Project = system Manager. Lookup Tree Item("TIPC^Name Of Project^Name Of Project Project"); plc Project. Consume Xml(xml); Code snippet (Powershell): The following table describes every XML node in more detail: 58 Version: 1.5 Automation Interface

## Page 59

Configuration XML Description Login Cmd true = in SPS-Laufzeit einloggen Logout Cmd true = aus SPS-Laufzeit ausloggen Start Cmd true = Starten des aktuell in die Laufzeit geladenen SPS-Programms Stop Cmd true = Stoppen des aktuell in die Laufzeit geladenen SPS-Programms Please note: In order to use commands like Reset Origin Cmd, you must first execute a Login Cmd - similar to Twin CAT XAE. Setting Boot project options The following code snippet demonstrates how to use the ITc Plc Project interface to set Boot project options for a PLC project. Code Snippet (C#): ITc Sm Tree Item plc Project Root = system Manager. Lookup Tree Item(“TIPC^Plc Generated”); ITc Plc Project plc Project Root Iec = (ITc Plc Project) plc Project Root; plc Project Root Iec. Boot Project Autostart = true; plc Project Root Iec. Generate Boot Project(true); Code snippet (Powershell): $plc Project = $system Manager. Lookup Tree Item(“TIPC^Plc Generated“) $plc Project. Boot Project Autostart = $true $plc Project. Generate Boot Project($true) Saving project and/or solution as archive To save the whole Twin CAT solution in an ZIP compatible archive (*.tszip), the ITc Sys Manager9 interface may be used. Code Snippet (C#): ITc Sys Manager9 new Sys Man = (ITc Sys Manager9)system Manager; new Sys Man. Save As Archive(@"C:\test.tszip"); Code snippet (Powershell): $system Manager. Save As Archive("C:\test.tszip") To reload a previously saved TSZIP file, the DTE method Add From Template() may be used. Code Snippet (C#): dte. Solution. Add From Template("C:\test.tszip",@"C:\tmp","Created From Template"); Code snippet (Powershell): $dte. Solution. Add From Template("C:\test.tszip","C:\tmp","Created From Template") To save a specific PLC project in an ZIP compatible archive (*.tpzip), the method ITc Sm Tree Item::Export Child() may be used. Code Snippet (C#): ITc Sm Tree Item plc= sys Manager. Lookup Tree Item("TIPC"); plc. Export Child("Plc Project",@"C:\Plc Template.tpzip"); Code snippet (Powershell): $plc = $system Manager. Lookup Tree Item("TIPC") $plc. Export Child("Plc Project", "C:\Plc Template.tpzip") To reload a previously saved TPZIP file, the ITc Sm Tree Item::Create Child() method may be used. Code Snippet (C#): plc Config. Create Child("Plc From Template", 0, null, @"C:\Plc Template.tpzip"); Code snippet (Powershell): Automation Interface Version: 1.5 59

## Page 60

Configuration $plc. Create Child("plc From Template", 0, $null, "C:\Plc Template.tpzip") Calling Check All Objects() To call the Check All Objects() method on the PLC Nested Project, you can use the corresponding method that is available in interface ITc Plc IECProject2. Code snippet (C#): ITc Sm Tree Item plc Project = system Manager. Lookup Tree Item("TIPC^Name Of Project^Name Of Project Project"); ITc Plc IECProject2 iec Project = (ITc Plc IECProject2) plc Project; iec Project. Check All Objects(); Code snippet (Powershell): $plc Project = $system Manager. Lookup Tree Item("TIPC^Name Of Project^Name Of Project Project") $plc Project. Check All Objects() 4.3.5.2 Accessing, creating and handling PLC-Libraries and -Placeholde This chapter explains in-depth how to access and handle PLC libraries and PLC placeholders. The following list shows all chapters in this article: • General information about PLC libraries and placeholders • Navigating through references • Adding references • Removing references • Scanning available libraries • Freezing placeholder version • Working with repositories General information about PLC libraries and placeholders In Twin CAT 3 there are two types of library objects: Libraries and Placeholders. For more information about both types please see the Twin CAT 3 documentation about Library Management. In a Twin CAT 3 PLC project, references to libraries and placeholders are added as child items to the References node under the corresponding PLC project. When choosing the "Standard PLC Project" template, some libraries and placeholders are being added to the project by default, e.g. Tc2_Standard, Tc2_System, ... . 60 Version: 1.5 Automation Interface

## Page 61

Configuration Using Automation Interface, you can navigate to the References node simply by using the ITc Sys Manager [} 116]::Lookup Tree Item() [} 124] method. Code snippet (C#): ITc Sm Tree Item references = system Manager. Lookup Tree Item("TIPC^Untitled1^Untitled1 Project^References"); Code snippet (Powershell): $references = $system Manager. Lookup Tree Item("TIPC^Untitled1^Untitled1 Project^References") To be able to handle this object correctly, you need to type cast it to the ITc Plc Library Manager interface. ITc Plc Library Manager lib Manager = (ITc Plc Library Manager) references; Please note that this step is not required in Windows Powershell. Navigating through references You can iterate through all references by making use of the ITc Plc Library Manager [} 171]::References property. This property returns an ITc Plc References collection of either library objects (represented by ITc Plc Library [} 177]) or placeholder objects (represented by ITc Plc Placeholder Ref). Code Snippet (C#): ITc Sm Tree Item references = system Manager. Lookup Tree Item("TIPC^Untitled1^Untitled1 Project^References"); ITc Plc Library Manager lib Manager = (ITc Plc Library Manager) references; foreach (ITc Plc Lib Ref lib Ref in lib Manager. References) { if (lib Ref is ITc Plc Library) { ITc Plc Library library = (ITc Plc Library) lib Ref; // do something } else if (lib Ref is ITc Plc Placeholder Ref) { ITc Plc Placeholder Ref placeholder = (ITc Plc Placeholder Ref) lib Ref; Automation Interface Version: 1.5 61

## Page 62

Configuration // do something } } The object lib Ref, which is used for the iteration, is of type ITc Plc Lib Ref. This is a common base class for ITc Plc Library and ITc Plc Placeholder Ref objects. To work with one of these specific classes, we need to type cast the object accordingly, as shown in the code snippet above. Code Snippet (Powershell): $references = $system Manager. Lookup Tree Item("TIPC^Untitled1^Untitled1 Project^References") For Each( $lib Ref in $references ) { $lib Ref. Language Independent Name } Adding references There are two methods in the ITc Plc Library Manager [} 171] class which allow you to add a library or placeholder reference to a PLC project: Add Library() and Add Placeholder(). Adding a library can be achieved in two ways: • Either by specifying the library name, version and distributor • or by using the library display name • or (in case of a placeholder) by using the placeholder name The display name of a library can be determined in the properties window of a library or placeholder: Adding libraries: Code Snippet (C#): ITc Sm Tree Item references = system Manager. Lookup Tree Item("TIPC^Untitled1^Untitled1 Project^References"); ITc Plc Library Manager lib Manager = (ITc Plc Library Manager) references; lib Manager. Add Library("Tc2_MDP", "*", "Beckhoff Automation Gmb H"); // name, version, distribution list lib Manager. Add Library("Tc2_Math, * (Beckhoff Automation Gmb H)"); //monitored name Code Snippet (Powershell): $references = $system Manager. Lookup Tree Item("TIPC^Untitled1^Untitled1 Project^References") $references. Add Library("Tc2_MDP", "*", "Beckhoff Automation Gmb H") $references. Add Library("Tc2_Math, * (Beckhoff Automation Gmb H)") Adding a placeholder can be achieved in two ways: • Either by specifying the placeholder name, library name, library version and library distributor • or by using the placeholder name if the placeholder already exists Adding placeholders: Code Snippet (C#): 62 Version: 1.5 Automation Interface

## Page 63

Configuration ITc Sm Tree Item references = system Manager. Lookup Tree Item("TIPC^Untitled1^Untitled1 Project^References"); ITc Plc Library Manager lib Manager = (ITc Plc Library Manager) references; lib Manager. Add Placeholder("Tc2_MC2_Camming"); // add existing place holder with name lib Manager. Add Placeholder("Placeholder_NC", "Tc2_NC", "*", "Beckhoff Automation Gmb H"); Code Snippet (Powershell): $references = $system Manager. Lookup Tree Item("TIPC^Untitled1^Untitled1 Project^References") $references. Add Placeholder("Tc2_MC2_Camming") $references. Add Placeholder("Placeholder_NC", "Tc2_NC", "*", "Beckhoff Automation Gmb H") Please note: When adding a new placeholder, the parameters of the Add Placeholder() method specify its Default Resolution. To set the Effective Resolution, simply use the ITc Plc Library Manager [} 171]::Set Effective Resoltion() method. Removing references To remove a reference, simply use the method ITc Plc Library Manager [} 171]::Remove Reference(). Because this method operates on ITc Plc Lib Ref items (which is the base class for ITc Plc Library and ITc Plc Placeholder Ref objects), you can use this method both for library and placeholder references. Library references can be removed by either specifying their name, version and distributor or by specifying their display name. Placeholder references can be removed by the placeholder name. Code Snippet (C#): ITc Sm Tree Item references = system Manager. Lookup Tree Item("TIPC^Untitled1^Untitled1 Project^References"); ITc Plc Library Manager lib Manager = (ITc Plc Library Manager) references; lib Manager. Remove Reference("Tc2_Math"); // delete library lib Manager. Remove Reference("Placeholder_NC"); // delete a placeholder Code Snippet (Powershell): $references = $system Manager. Lookup Tree Item("TIPC^Untitled1^Untitled1 Project^References") $references. Remove Reference("Tc2_Math") $references. Remove Reference("Placeholder_NC") Scanning available libraries To scan the system for all available PLC libraries, simply use the ITc Plc Library Manager [} 171]::Scan Libraries() [} 175] method. This method returns an ITc Plc References collection of libraries (type ITc Plc Library). Code Snippet (C#): ITc Sm Tree Item references = system Manager. Lookup Tree Item("TIPC^Untitled1^Untitled1 Project^References"); ITc Plc Library Manager lib Manager = (ITc Plc Library Manager) references; ITc Plc References libraries = lib Manager. Scan Libraries(); foreach(ITc Plc Library library in libraries) { // do something } Code Snippet (Powershell): $references = $system Manager. Lookup Tree Item("TIPC^Untitled1^Untitled1 Project^References") $libraries = $references. Scan Libraries() For Each( $lib in $libraries ) { $lib. Name } Freezing placeholder version It is possible to freeze the used version of a placeholder to a specific version. This can be achieved by using the method ITc Plc Library Manager [} 171]::Freeze Placeholder(). This method is called on an object that points to the References node. Automation Interface Version: 1.5 63

## Page 64

Configuration Code Snippet (C#): ITc Sm Tree Item references = system Manager. Lookup Tree Item("TIPC^Untitled1^Untitled1 Project^References"); ITc Plc Library Manager lib Manager = (ITc Plc Library Manager) references; lib Manager. Freeze Placeholder(); // freezes the version of all place holders lib Manager. Freeze Placeholder("Placeholder_NC"); // freezes the version of a specific place holder Code Snippet (Powershell): $references = $system Manager. Lookup Tree Item("TIPC^Untitled1^Untitled1 Project^References") $references. Freeze Placeholder() $references. Freeze Placeholder("Placeholder_NC") Please note: The version is freezed to the Effective Resolution. If the Effective Resolution points to "*", then the newest version in the system is used. Working with repositories The Automation Interface provides method for handling PLC library repositories. A default repository is part of every Twin CAT installation. To create additional repositories, you can use the ITc Plc Library Manager [} 171]::Insert Repository() [} 174] method. Code Snippet (C#): ITc Sm Tree Item references = system Manager. Lookup Tree Item("TIPC^Untitled1^Untitled1 Project^References"); ITc Plc Library Manager lib Manager = (ITc Plc Library Manager) references; lib Manager. Insert Repository("Test Repository", @"C:\Temp", 0); Code Snippet (Powershell): $references = $system Manager. Lookup Tree Item("TIPC^Untitled1^Untitled1 Project^References") $references. Insert Repository("Test Repository", "C:\Temp", 0) When installing a new library into the system, the library needs to be part of a repository. This insertion can be achieved by using the ITc Plc Library Manager [} 171]::Install Library() [} 174] method. Code Snippet (C#): lib Manager. Install Library("Test Repository", @"C:\Some Folder\Tc Test Library.library", false); Code Snippet (Powershell): $references. Install Library("Test Repository", "C:\Some Folder\Tc Test Library.library", $false) To uninstall a library from the repository, use the ITc Plc Library Manager [} 171]::Uninstall Library() [} 176] method. Code Snippet (C#): lib Manager. Uninstall Library("Test Repository", "Tc2_MDP", "*", "Beckhoff Automation Gmb H"); Code Snippet (Powershell): $references. Uninstall Library("Test Repository", "Tc2_MDP", "*", "Beckhoff Automation Gmb H") To remove a repository, use the ITc Plc Library Manager [} 171]::Remove Repository() [} 175] method. Code Snippet (C#): lib Manager. Remove Repository("Test Repository"); Code Snippet (Powershell): $references. Remove Repository("Test Repository") 4.3.5.3 Accessing, creating and handling PLC POUs This chapter explains in-depth how to access PLC objects, for example POUs, Methods, Transitions, Properties, and how to access their corresponding implementation and declaration areas to handle PLC code. It also covers how to import/export PLC objects in PLCopen XML. The following list shows all chapters in this article: 64 Version: 1.5 Automation Interface

## Page 65

Configuration • General information about PLC objects • Accessing the implementation / declaration area of a POU • Accessing Sub-POUs (Actions, Properties, ...) • Creating PLC objects • PLC access modifier • Importing / Exporting PLCopen XML • Import existing POUs (templates) General information about PLC objects Although every tree item is considered to be of type ITc Sm Tree Item [} 124], some items need to be casted to a more special interface to gain access to all of their methods and properties, for example POUs which need to be casted to the interface ITc Plc Pou [} 165] to get access to their unique methods and properties. Code snippet (C#): ITc Sm Tree Item plc Pous Item = system Manager. Lookup Tree Item("TIPC^Plc Generated^Plc Generated Project^POUs"); ITc Sm Tree Item new Fb = plc Pous Item. Create Child("FB_TEST", 604, "", IECLANGUAGETYPES. IECLANGUAGE_ST); ITc Plc Pou fb Pou = (ITc Plc Pou)new Fb; Code snippet (Powershell): $plc Pous Item = $system Manager. Lookup Tree Item("TIPC^Plc Generated^Plc Generated Project^POUs") $new Fb = $plc Pous Item. Create Child("FB_TEST", 604, "", 6) In this example, the POU MAIN is being created in a PLC-Project. The object program Pou references this POU and can now be used to access specific methods and properties of the POU by using the corresponding method/property of the ITc Plc Pou interface. Accessing the implementation / declaration area of a POU You can also get read/write access to either the implementation or declaration area of a POU by using the interfaces ITc Plc Implementation [} 167] or ITc Plc Declaration [} 166], as the following example shows. Code snippet (C#): ITc Plc Declaration fb Pou Decl = (ITc Plc Declaration) fb Pou; ITc Plc Implementation fb Pou Impl = (ITc Plc Implementation) fb Pou; string decl = fb Pou Decl. Declaration Text; string impl = fb Pou Impl. Implementation Text; string impl Xml = fb Pou Impl. Implementation Xml; Code snippet (Powershell): $decl = $new Fb. Declaration Text $impl = $new Fb. Implementation Text $impl Xml = $new Fb. Implementation Xml When comparing both interfaces, you will notice that the accessible properties in both interfaces differ from each other. For example the ITc Plc Implementation interface offers a property "Language" whereas ITc Plc Declaration doesn't. This is because, according to IEC, the declaration area is not based on a real programming language (e.g. ST), therefore this property does not make sense when used on a declaration area. Accessing Sub-POUs (Actions, Properties, ...) POUs may have more sub-items like Methods, Transitions, Actions and Properties. It is important to understand that not every sub-item of a POU also has both an implementation and a declaration area. Actions and Transitions, for example, only have an implementation area. Therefore, casting to one of the interfaces mentioned above is only valid if the corresponding sub-object has this area. The following table gives an overview about which areas are available in the different types of POUs. Automation Interface Version: 1.5 65

## Page 66

Configuration Tree Item Type Declaration Area Implementation Area Program POU Yes Yes Function POU Yes Yes Function Block POU Yes Yes Action POU No Yes Method POU Yes Yes Property (Get/Set) POU Yes Yes Transition POU No Yes Enum DUT Yes No Struct DUT Yes No Union DUT Yes No Alias DUT Yes No Interface Interface Yes No Property (Get/Set) Interface Yes Yes Global variables GVL Yes No Creating PLC-Objects The creation of PLC-Objects is simple and can be achieved via the Create Child() [} 160] method of the ITc Sm Tree Item [} 124] interface. Depending on the type of POU, the parameters of this method need to be interpreted differently. The following table gives the necessary information to be able to create different POU types. Please note that the v Info parameter may be a string array, if more than one parameter is needed. Each array position and whether it is optional or not, is marked as [...] below. 66 Version: 1.5 Automation Interface

## Page 67

Configuration Tree Item Type Parameter "n Sub Type" Parameter "v Info" Program POU 602 [0, optional]: IEC programming language, as definied by IECLANGUAGETYPES [} 166]. By default, ST (Structured Text) is used. [1, optional]: May be used for derivation (keywords "Extends" or "Implements"). If keywords "Extends" AND "Implements" should be used, this field specifies the keyword "Extends". [2, optional]: Interface or POU name which should be extended/implemented (mandatory, if [1] is used). If keywords "Extends" AND "Implements" should be used, this field specifies the library to extend.. [3, optional]: If keywords "Extends" AND "Implements" should be used, this field specifies the keyword "Implements". [4, optional]: If keywords "Extends" AND "Implements" should be used, this field specifies the interface used for derivation. Function POU 603 [0]: IEC programming language, as definied by IECLANGUAGETYPES [} 166]. [1]: Return data type of function. May be a PLC data type, e.g. DINT, BOOL, ... Function POU 604 [0, optional]: IEC programming language, as definied by Block IECLANGUAGETYPES [} 166]. By default, ST (Structured Text) is used. [1, optional]: May be used for derivation (keywords "Extends" or "Implements"). If keywords "Extends" AND "Implements" should be used, this field specifies the keyword "Extends". [2, optional]: Interface or POU name which should be extended/implemented (mandatory, if [1] is used). If keywords "Extends" AND "Implements" should be used, this field specifies the library to extend.. [3, optional]: If keywords "Extends" AND "Implements" should be used, this field specifies the keyword "Implements". [4, optional]: If keywords "Extends" AND "Implements" should be used, this field specifies the interface used for derivation. Action POU 608 [0, optional]: IEC programming language, as definied by IECLANGUAGETYPES [} 166]. By default, ST (Structured Text) is used. [1, optional]: May contain PLCopen XML string with code for Action Method POU 609 [0, optional]: IEC programming language, as definied by IECLANGUAGETYPES [} 166]. By default, ST (Structured Text) is used. [1, optional]: Return data type [2, optional]: Access modfier, e.g. PUBLIC. By default, PUBLIC is used. [3, optional]: May contain PLCopen XML string with code for Action Property POU 611 [0]: IEC programming language, as definied by IECLANGUAGETYPES [} 166] [1]: Return data type [2, optional]: Access modifier, e.g. PUBLIC. By default, PUBLIC is used. Automation Interface Version: 1.5 67

## Page 68

Configuration Tree Item Type Parameter "n Sub Type" Parameter "v Info" Property Get POU 613 [0, optional]: IEC programming language, as definied by IECLANGUAGETYPES [} 166]. By default, ST (Structured Text) is used. [1, optional]: Access modifier, e.g. PUBLIC. By default, PUBLIC is used. [2, optional]: May contain PLCopen XML string with code for Action Property Set POU 614 [0, optional]: IEC programming language, as definied by IECLANGUAGETYPES [} 166]. By default, ST (Structured Text) is used. [1, optional]: Access modifier, e.g. PUBLIC. By default, PUBLIC is used. [2, optional]: May contain PLCopen XML string with code for Action Transition POU 616 [0, optional]: IEC programming language, as definied by IECLANGUAGETYPES [} 166]. By default, ST (Structured Text) is used. [1, optional]: May contain PLCopen XML string with code for Action Enum DUT 605 [0, optional]: May contain declaration text Struct DUT 606 [0, optional]: May contain declaration text Union DUT 607 [0, optional]: May contain declaration text Alias DUT 623 [0, optional]: May contain declaration text Interface Interfa 618 [0, optional]: Extending type ce Property Interfa 612 [0]: Return data type ce Property Get Interfa 654 No v Info parameter is needed and "null" can be used. ce Property Set Interfa 655 No v Info parameter is needed and "null" can be used. ce Method Interfa 610 [0]: Return data type ce Global GVL 615 [0, optional]: May contain declaration text variables PLC Folder Folder 601 No v Info parameter is needed and "null" can be used. Parameter PL 629 [0, optional]: May contain declaration text List UML Class POU 631 --- Diagram Example: The following code snippet shows how to use the v Info parameter to create a Functionblock "FB_Test" with the keywords extends and/or implements, depending on the value of the bool variables b Extends and b Implements. The extended library is ADSRDSTATE and the implemented interface ITc ADI. Code snippet (C#): string[] v Info; bool b Extends = true; bool b Implements = true; if (b Extends && b Implements) { v Info= new string[5]; } else { if (b Extends || b Implements) { v Info= new string[3]; } 68 Version: 1.5 Automation Interface

## Page 69

Configuration else { v Info= new string[1]; } } v Info[0] = language. As String(); if (b Extends && b Implements) { v Info[1] = "Extends"; v Info[2] = "ADSRDSTATE"; v Info[3] = "Implements"; v Info[4] = "ITc ADI"; } else { if (b Extends) { v Info[1] = "Extends"; v Info[2] = "ADSRDSTATE"; } else { if (b Implements) { v Info[1] = "Implements"; v Info[2] = "ITc ADI"; } } } ITc Sm Tree Item new POU = parent. Create Child("FB_Test", 604, "", fb VInfo); Please note If the paramerter v Info includes only one value (marked as [0] in the table above), you shouldn't cre- ate an array of size 1, instead just use a regular variable. Example: When using n Sub Type 618 (In- terface), you should use v Info as follows. Code snippet (C#): ITc Sm Tree Item interface1 = pou. Create Child("New Interface1", 618, "", null); // no expansion type ITc Sm Tree Item interface2 = pou. Create Child("New Interface2", 618, "", "ITc Unknown"); // expands ITc Unknown interface PLC access modifier The following access modifiers are valid and may be used as a v Info parameter, as shown in the table above: PUBLIC, PRIVATE, PROTECTED, INTERNAL. Importing / Exporting PLCopen XML You can also import/export PLC elements in PLCopen XML, which can be achieved via the ITc Plc IECProject [} 168] interface. Methods and properties of this interface can only be executed directly on a PLC project node, for example: Code snippet (C#): ITc Sm Tree Item plc Project = system Manager. Lookup Tree Item("TIPC^Plc Generated^Plc Generated Project"); ITc Plc IECProject import Export = (ITc Plc IECProject) plc Project; importexport. Plc Open Export(plc Open Export File, "My Pous. POUProgram;My Pous. POUFunction Block"); import Export. Plc Open Import(plc Open Export File, (int)PLCIMPORTOPTIONS. PLCIMPORTOPTIONS_NONE); Code snippet (Powershell): $plc Project = $system Manager. Lookup Tree Item("TIPC^Plc Generated^Plc Generated Project") $plc Project. Plc Open Export(plc Open Export File, "My Pous. POUProgram;My Pous. POUFunction Block") $plc Project. Plc Open Import(plc Open Export File,0) Automation Interface Version: 1.5 69

## Page 70

Configuration This code snippet assumes that there is already a PLC project added to the Twin CAT configuration, which will be referenced via the object plc Project. This reference is casted to the object importexport of type ITc Plc IECProject, which is then used to export the POUs POUProgram and POUFunction Block (both reside in the PLC folder "My POUs") into an XML file and then import them again. The available options for import are: None (0), Rename (1), Replace (2), Skip (3) Import existing POUs (templates) PLC templates are available in two units: You can either use the complete PLC project as a whole or each POU individually as a template. The later is covered in this chapter. One of the reasons a developer may choose individual POUs as templates, is that it is easier to build a pool of existing functionalities and encapsulate them in separate POUs, e.g. different function blocks covering different sorting algorithms. Upon project creation, the developer simply chooses which functionality he needs in his Twin CAT project and accesses the template tool to retrieve the corresponding POU and import it to his PLC project. Code snippet (C#): ITc Sm Tree Item plc Project = system Manager. Lookup Tree Item("TIPC^Plc Generated^Plc Generated Project"); plc Project. Create Child("Name Of Imported POU", 58, null, path To Pou File); plc Project. Create Child(null, 58, null, string Array With Paths To Pou Files); Code snippet (Powershell): $plc Project = $system Manager. Lookup Tree Item(“TIPC^Plc Generated^Plc Generated Project") $plc Project. Create Child("Name Of Imported POU", 58, $null, $path To Pou File) $plc Project. Create Child($null, 58, $null, $string Array With Paths To Pou Files) Please note: A POU template file may not only be a . Tc Pou file but also the corresponding files for DUTs and/or GVLs. The example above demonstrates two common ways to import POU template files. The first is to import a single file, the second to import multiple files at once by storing the file paths to a string array and using this string array as the v Info parameter of Create Child(). 4.3.6 I/O 4.3.6.1 Creating and handling Ether CAT devices This article explains how to build an Ether CAT topology via Twin CAT Automation Interface. It consists of the following topics: • General information • Creating an Ether CAT device • Creating Ether CAT boxes and insert into topology • Creating Ether CAT terminals and insert into topology • Exceptions to the Item Sub Type 9099 • Changing the "Previous Port" of an Ether CAT terminal • Adding Ether CAT slaves to a Hot Connect group • How to add Ether CAT Sync Units • Handle Ether CAT junction boxes (CU1128) All of these topics cover the case of an offline configuration, which means the real addresses of all devices ar not know at the time of config creation. The last chapter of this article therefore also explains how to • Activate the configuration General information This documentation should give you an overview avout how to create and handle Ether CAT devices and their corresponding topology via Automation Interface. For an in-depth understanding about how Ether CAT works and how it is generally integrated in Twin CAT System Manager/XAE, please consult the Ether CAT 70 Version: 1.5 Automation Interface

## Page 71

Configuration System Documentation and the corresponding chapter about Ether CAT configuration in Twin CAT. Ether CAT boxes and terminals, which are connected to an Ether CAT Master, share a common way of creation, which is explained in a separate article about E-Bus sub types [} 131]. Creating an Ether CAT device The first step in creating a Twin CAT Ether CAT configuration is to create an Ether CAT device, which may involve either to create an Ether CAT Master, Slave or Automation Protocol (e.g. to use network variables, as covered in a separate article [} 76]). To create an Ether CAT Master/Slave, simply make use of the ITc Sm Tree Item [} 160]::Create Child() [} 160] method with the corresponding parameter for Sub Type (Ether CAT Master = 111, Ether CAT Slave = 130). Ether CAT Master - Code Snippet (C#) ITc Sm Tree Item devices = system Manager. Lookup Tree Item("TIID"); ethercat Master = devices. Create Child("Ether CAT Master", 111, null, null); Ether CAT Master - Code Snippet (Powershell) $devices = $system Manager. Lookup Tree Item("TIID") $ethercat Master = $devices. Create Child("Ether CAT Master", 111, $null, $null) Ether CAT Slave - Code Snippet (C#) ITc Sm Tree Item devices = system Manager. Lookup Tree Item("TIID"); ethercat Slave = devices. Create Child("Ether CAT Slave", 130, null, null); Ether CAT Slave - Code Snippet (Powershell) $devices = $system Manager. Lookup Tree Item("TIID") $ethercat Slave = $devices. Create Child("Ether CAT Slave", 130, $null, $null) Creating Ether CAT boxes The second step involves creating Ether CAT boxes, for example an EK1100 Ether CAT Coupler. As the article about E-Bus Sub Types [} 131] explains, every child item (there a few exceptions - see below) of an Ether CAT Master uses a common Sub Type (9099) and will be identified via the Product Revision, which needs to be used in the v Info parameter of the ITc Sm Tree Item [} 124]::Create Child() [} 160] method. Code Snippet (C#) ITc Sm Tree Item ethercat Master = system Manager. Lookup Tree Item("TIID^Ether CAT Master"); ethercat Master. Create Child("EK1100", 9099, "", "EK1100-0000-0017"); Code Snippet (Powershell) $ethercat Master = $system Manager. Lookup Tree Item("TIID^Ether CAT Master") $ethercat Master. Create Child("EK1100", 9099, "", "EK1100-0000-0017") Automation Interface Version: 1.5 71

## Page 72

Configuration Please note: In addition to the full product revision, you can also use a "wildcard". If you only specify "EK1100" as v Info, Automation Interface will automatically detect and use the newest revision number. Example: Code Snippet (C#): ITc Sm Tree Item ethercat Master = system Manager. Lookup Tree Item("TIID^Ether CAT Master"); ethercat Master. Create Child("EK1100", 9099, "", "EK1100"); Code Snippet (Powershell): $ethercat Master = $system Manager. Lookup Tree Item("TIID^Ether CAT Master") $ethercat Master. Create Child("EK1100", 9099, "", "EK1100") Creating Ether CAT terminals and insert into topology The creation of Ether CAT terminals is based on the same concepts as Ether CAT boxes. Every terminal also shares a common Sub Type and will be identified via the Product Revision, which needs to be used in the v Info parameter of the ITc Sm Tree Item [} 124]::Create Child() [} 160] method. The parameter bstr Before lets you choose the position on which the terminal should be inserted into the configuration. Code Snippet (C#): ITc Sm Tree Item ek1100 = system Manager. Lookup Tree Item("TIID^Device 1 (Ether CAT)^EK1100"); ek1100. Create Child("Term 4 (EL2004)", 9099, "Term 3 (EL2004)", "EL2004-0000-0017"); Code Snippet (Powershell): $ek1100 = $system Manager. Lookup Tree Item("TIID^Device 1 (Ether CAT)^EK1100") $ek1100. Create Child("Term 4 (EL2004)", 9099, "Term 3 (EL2004)", "EL2004-0000-0017") Please note: Should you have trouble using the bstr Before parameter, please try to insert the terminal on a "device-level", for example: Code Snippet (C#): 72 Version: 1.5 Automation Interface

## Page 73

Configuration ITc Sm Tree Item device= system Manager. Lookup Tree Item("TIID^Device 1 (Ether CAT)"); device. Create Child("Term 4 (EL2004)", 9099, "Term 3 (EL2004)", "EL2004-0000-0017"); Code Snippet (Powershell): $device= $system Manager. Lookup Tree Item("TIID^Device 1 (Ether CAT)") $device. Create Child("Term 4 (EL2004)", 9099, "Term 3 (EL2004)", "EL2004-0000-0017") The new terminal will then be inserted before "Term 3 (EL2004)" under the last inserted Ether CAT box. Please note: In addition to the full product revision, you can also use a "wildcard". If you only specify "EL2004" as v Info, Automation Interface will automatically detect and use the newest revision number. Example: Code Snippet (C#): ITc Sm Tree Item ek1100 = system Manager. Lookup Tree Item("TIID^Device 1 (Ether CAT)^EK1100"); ek1100. Create Child("Term 4 (EL2004)", 9099, "Term 3 (EL2004)", "EL2004"); Code Snippet (Powershell): $ek1100 = $system Manager. Lookup Tree Item("TIID^Device 1 (Ether CAT)^EK1100") $ek1100. Create Child("Term 4 (EL2004)", 9099, "Term 3 (EL2004)", "EL2004") Exceptions to the Item Sub Type 9099 There are a few exceptions to the Item Sub Type 9099, e.g. the RS232 terminals EP6002 (Item Sub Type 9101) and EL600X (Item Sub Type 9101). The following table gives an overview about all exceptions and their corresponding Item Sub Type. I/O Item Sub Type EP6002 9101 EL6001 9101 EL6002 9101 EP6001-0002 9101 EP6002-0002 9101 EL6021 9103 EL6022 9103 EL6021-0021 9103 BK1120 9081 ILXB11 9086 EL6731 9093 EL6751 9094 EL6752 9095 EL6731-0010 9096 EL6751-0010 9097 EL6752-0010 9098 EL6601 9100 EL6720 9104 EL6631 9106 EL6631-0010 9107 EL6632 9108 EL6652-0010 9109 EL6652 9110 Changing the "Previous Port" of an Ether CAT terminal The Previous Port of an Ether CAT terminal determines the position of the terminal inside the Ether CAT topology. Automation Interface Version: 1.5 73

## Page 74

Configuration In Twin CAT XAE, the Drop Down box automatically includes all available previous ports. To configure this setting via Automation Interface, you can make use of the ITc Sm Tree Item [} 124]::Produce Xml() [} 158] and ITc Sm Tree Item [} 124]::Consume Xml() [} 159] methods to modify the XML description [} 25] of the corresponding Ether CAT terminal. This XML description therefore includes one or more XML nodes <Previous Port>, where its attribute "Selected=1" determines, which previous port has been currently selected. Each previous port device is identified by its physical address. Example (XML description) <Tree Item> <Ether CAT> <Slave> <Previous Port Selected="1"> <Port>B</Port> <Phys Addr>1045</Phys Addr> </Previous Port> <Previous Port> <Port>B</Port> <Phys Addr>1023</Phys Addr> </Previous Port> </Slave> <Ether CAT> </Tree Item> If you want to change the Previous port you need to know the <Phys Addr> of the desired device, which can also be determined via its XML description. When inserting childs to an Ether CAT configuration, the bstr Before parameter of the Import Child or Create Child method can be used to specify the previous item when calling the Import Child or Create Child method on a slave. On an Ether CAT master this setting has to be specified via the XML description from above. Adding Ether CAT slaves to a Hot Connect group Ether CAT Hot Connect allows pre-configured sections to be removed from or added to the data traffic before the start or during operation of the system. For more information about Ether CAT Hot Connect please read our Ether CAT System documentation. In Twin CAT XAE, an Ether CAT slave can be added to a Hot Connect group by clicking the corresponding option in the context menu of the device. 74 Version: 1.5 Automation Interface

## Page 75

Configuration In Twin CAT Automation Interface, the same can be achieved by consuming the following XML structure on the Ether CAT slave: Example (XML description): <Tree Item> <Ether CAT> <Slave> <Hot Connect> <Group Name>Term 1 (EK1101)</Group Name> <Group Member Cnt>4</Group Member Cnt> <Identify Cmd> <Comment>Hot Connect-Identität lesen</Comment> <Requires>cycle</Requires> <Cmd>1</Cmd> <Adp>0</Adp> <Ado>4096</Ado> <Data Length>2</Data Length> <Cnt>1</Cnt> <Retries>3</Retries> <Validate> <Data>0000</Data> <Timeout>5000</Timeout> </Validate> </Identify Cmd> </Hot Connect> </Slave> </Ether CAT> </Tree Item> Please note: • The <Group Member Cnt> tag needs to specify the exact amount of terminals plus the device itself How to set Ether CAT Sync Units Ether CAT Sync Units can be set via ITc Sm Tree Item::Consume Xml() and by using the following XML description. Example (XML description): <Tree Item> <Ether CAT> <Slave> <Sync Units> <Sync Unit>Sync Unit1</Sync Unit> </Sync Units> </Slave> </Ether CAT> </Tree Item> Handle Ether CAT junction boxes (CU1128) Ether CAT junction boxes can be handled similar to all other tree items. The following sample code shows how to add a CU1128 box and then add two EK1100 boxes below: Code Snippet (C#) ITc Sm Tree Item cu1128 = ethercat Master. Create Child("CU1128", 9099, null, "CU1128"); ITc Sm Tree Item cu1128_dev A = cu1128.get_Child(1); ITc Sm Tree Item cu1128_dev B = cu1128.get_Child(2); ITc Sm Tree Item ek1100_1 = cu1128_dev A. Create Child("EK1100-1", 9099, null, "EK1100"); ITc Sm Tree Item ek1100_2 = cu1128_dev B. Create Child("EK1100-2", 9099, null, "EK1100"); Code Snippet (Powershell) $cu1128 = $ethercat Master. Create Child("CU1128", 9099, $null, "CU1128") $cu1128_dev A = $cu1128.get_Child(1) $cu1128_dev B = $cu1128.get_Child(2) $ek1100_1 = $cu1128_dev A. Create Child("EK1100-1", 9099, $null, "EK1100") $ek1100_2 = $cu1128_dev B. Create Child("EK1100-2", 9099, $null, "EK1100") Automation Interface Version: 1.5 75

## Page 76

Configuration Activate the Ether CAT configuration To activate a created Twin CAT configuration via Automation Interface, the ITc Sys Manager [} 116]::Activate Configuration() [} 119] method may be used. However, the previous chapters only explained how to create an offline configuration, which means that every device created does not have real addresses, e.g. the Ether CAT Master has not been linked to a physical network interface card yet. Before activating the configuration you therefore need to configure each device with online addresses. To determine the real addresses, you can run a Scan Devices on the online system, determine the real addresses via the XML description (ITc Sm Tree Item [} 124]::Produce Xml() [} 158]) and then import the address information via ITc Sm Tree Item [} 124]::Consume Xml() [} 159] into the created (offline) configuration. There are two How To samples which help you exactly with this kind of configuration: • Scan Devices [} 93] via Automation Interface 4.3.6.2 Creating and handling network variables This chapter explains in-depth how to create and handle network variables. The following list shows all chapters in this article: • General information about network variables • Creating an Ether CAT Automation Protocol device • Creating a Publisher box • Creating a Subscriber box • Setting parameters for a Publisher/Subscriber box • Creating Publisher variables • Creating Subscriber variables • Linking Publisher/Subscriber variables • Reading Publisher/Subscriber variable IDs Please note that the Scripting Container [} 182] contains a detailed sample about how to create and configure network variables with the Automation Interface. General information about network variables Network variables may be used to send data between two Twin CAT devices via an IP-based network. One device declares variables as a "Publisher" (sender) and the other device receives variable values as a "Subscriber". Therefore we also speak in terms of Publisher/Subscriber variables. Twin CAT provides you with the flexibility to configure network variables directly in a Twin CAT project so that you may map them to your PLC or I/O. 76 Version: 1.5 Automation Interface

## Page 77

Configuration Network variables use the Ether CAT Automation Protocol device to communicate via the local network. Therefore, you need to add this device before you can configure a Publisher and/or Subscriber box together with the corresponding variables. More information about network variables and how they can be configured in Twin CAT may be found here. Creating an Ether CAT Automation Protocol device To create the Ether CAT Automation Protocol device, the method ITc Sm Tree Item [} 124]::Create Child() [} 160] may be used together with the corresponding Sub Type of this device (112). Code Snippet (C#): ITc Sm Tree Item devices Node = system Manager. Lookup Tree Item("TIID"); device = devices Node. Create Child("Device 1 (Ether CAT Automation Protocol)", 112, null, null); Code Snippet (Powershell): $devices Node = $system Manager. Lookup Tree Item("TIID") $device = $devices Node. Create Child("Device 1 (Ether CAT Automation Protocol)", 112, $null, $null) Creating a Publisher box The Publisher box is the container for Publisher variables, which defines for example which type of communication pattern should be used (Unicast, Multicast, Broadcast) for the variables contained within. To add a Publisher box, simply use the ITc Sm Tree Item [} 124]::Create Child() [} 160] method again together with the corresponding Sub Type (9051). Code Snippet (C#): ITc Sm Tree Item eap Device = system Manager. Lookup Tree Item("TIID^Device 1 (Ether CAT Automation Protocol)"); pub Box = eap Device. Create Child("Box 1 (Publisher)", 9051, null, null); Code Snippet (Powershell): $eap Device = $system Manager. Lookup Tree Item("TIID^Device 1 (Ether CAT Automation Protocol)") $pub Box = $eap Device. Create Child("Box 1 (Publisher)", 9051, $null, $null) Automation Interface Version: 1.5 77

## Page 78

Configuration This small code snippet adds a Publisher box to the Ether CAT Automation Protocol device created earlier. To configure the communication pattern of this box, you need to customize its settings via the ITc Sm Tree Item [} 124]::Consume Xml() [} 159], method. This is shown in more detail in the Ether CAT Automation Protocol sample of the Scripting Container [} 182] or later on this page. Creating a Subscriber box The Subscriber box is the container for Subscriber variables, which defines for example which type of communication pattern should be used (Unicast, Multicast, Broadcast) for the variables contained within. To add a Publisher box, simply use the ITc Sm Tree Item [} 124]::Create Child() [} 160] method again together with the corresponding Sub Type (9052). Code Snippet (C#): ITc Sm Tree Item eap Device = system Manager. Lookup Tree Item("TIID^Device 1 (Ether CAT Automation Protocol)"); sub Box = eap Device. Create Child("Box 1 (Subscriber)", 9052, null, null); Code Snippet (Powershell): $eap Device = $system Manager. Lookup Tree Item("TIID^Device 1 (Ether CAT Automation Protocol)") $sub Box = $eap Device. Create Child("Box 1 (Subscriber)", 9052, $null, $null) This small code snippet adds a Subscriber box to the Ether CAT Automation Protocol device created earlier. To configure the communication pattern of this box, you need to customize its settings via the ITc Sm Tree Item [} 124]::Consume Xml() [} 159], method. This is shown in more detail in the Ether CAT Automation Protocol sample of the Scripting Container [} 182] or later on this page. Creating Publisher variables After you have successfully added a Publisher box, you can add Publisher variables to this box by making use of the ITc Sm Tree Item [} 124]::Create Child() [} 160] method together with the needed parameters for Sub Type (0) and v Info, which specifies the data type of the Publisher variable, e.g. "BOOL". Code Snippet (C#): ITc Sm Tree Item pub Box = system Manager. Lookup Tree Item("TIID^Device 1 (Ether CAT Automation Protocol)^Box 1 (Publisher)"); pub Var = pub Box. Create Child("MAIN.b Test Var", 0, null, "BOOL"); Code Snippet (Powershell): $pub Box = $system Manager. Lookup Tree Item("TIID^Device 1 (Ether CAT Automation Protocol)^Box 1 (Publisher)") $pub Var = $pub Box. Create Child("MAIN.b Test Var", 0, $null, "BOOL") Please see the Scripting Container [} 182] sample "Ether CAT Automation Protocol" for more information. Setting parameters for a Publisher/Subscriber box There are two communication patterns which need to be configured on a Publisher and/or Subscriber box: RT-Ethernet or UDP/IP . The following screenshot shows the corresponding configuration tab from Twin CAT XAE. 78 Version: 1.5 Automation Interface

## Page 79

Configuration More detailed information about these options can be found here. To configure the box for RT-Ethernet , you need to make use of the ITc Sm Tree Item [} 124]::Consume Xml() [} 159] method to import the following XML structure: <Tree Item> <Box Def> <Fieldbus Address>1</Fieldbus Address> <Ams Address> <Ams Port>0</Ams Port> <Ams Port Timeout>5</Ams Port Timeout> </Ams Address> <Nv Pub Def> <Udp Enabled="false"/> <Mac Address>00 00 00 00 00 00</Mac Address> <Io Div> <Divider>1</Divider> <Modulo>0</Modulo> </Io Div> <VLAN> <Enable>false</Enable> <Id>0</Id> <Prio>0</Prio> </VLAN> <Arp Interval>1000</Arp Interval> <Disable Subscriber Monitoring>false</Disable Subscriber Monitoring> <Target Changeable>false</Target Changeable> </Nv Pub Def> </Box Def> </Tree Item> The following table shows how the bold marked nodes need to be adapted according to the desired communication pattern. RT-Ethernet Communication pat- <Publisher Net Id> <Mac Address> tern Broadcast 0.0.0.0.0.0 FF FF FF FF FF FF Multicast 0.0.0.0.0.0 Needs to contain a Multicast MAC Address, please refer here for more information. Unicast - MAC Address 0.0.0.0.0.0 Needs to contain a Unicast MAC Address, please refer here for more information. Unicast - Ams Net Id Contains Ams Net Id of target 00 00 00 00 00 00 computer. Import the following XML structure if you want to use UDP/IP: Automation Interface Version: 1.5 79

## Page 80

Configuration <Tree Item> <Box Def> <Fieldbus Address>1</Fieldbus Address> <Ams Address> <Ams Port>0</Ams Port> <Ams Port Timeout>5</Ams Port Timeout> </Ams Address> <Nv Pub Def> <Udp Enabled="true"> <Address>0.0.0.0</Address> <Gateway>0.0.0.0</Gateway> </Udp> <Io Div> <Divider>1</Divider> <Modulo>0</Modulo> </Io Div> <VLAN> <Enable>false</Enable> <Id>0</Id> <Prio>0</Prio> </VLAN> <Arp Interval>1000</Arp Interval> <Disable Subscriber Monitoring>false</Disable Subscriber Monitoring> <Target Changeable>false</Target Changeable> </Nv Pub Def> </Box Def> </Tree Item> The following table shows how the bold marked nodes need to be adapted according to the desired communication pattern. On the node <Udp>, the attribute "Enabled" needs to be set to "true". RT-Ethernet Communication pat- <Address> <Gateway> tern Broadcast 255.255.255.255 0.0.0.0 Multicast Needs to contain a Multicast IP May contain a default gateway address. Please refer here for where the packets should be send more information. to for routing. Otherwise you may leave it at 0.0.0.0 Unicast Needs to contain an (Unicast) IP May contain a default gateway address. Please refer here for where the packets should be send more information. to for routing. Otherwise you may leave it at 0.0.0.0 Creating Subscriber variables After you have successfully added a Publisher box, you can add Publisher variables to this box by making use of the ITc Sm Tree Item [} 124]::Create Child() [} 160] method together with the needed parameters for Sub Type (0) and v Info, which specifies the data type of the Publisher variable, e.g. "BOOL". Code Snippet (C#): ITc Sm Tree Item sub Box = system Manager. Lookup Tree Item("TIID^Device 1 (Ether CAT Automation Protocol)^Box 1 (Subscriber)"); sub Var = pub Box. Create Child("MAIN.b Test Var", 0, null, "BOOL"); Code Snippet (Powershell): $sub Box = $system Manager. Lookup Tree Item("TIID^Device 1 (Ether CAT Automation Protocol)^Box 1 (Subscriber)") $sub Var = $pub Box. Create Child("MAIN.b Test Var", 0, $null, "BOOL") Please see the Scripting Container [} 182] sample "Ether CAT Automation Protocol" for more information. Linking Publisher/Subscriber variables To link Publisher/Subscriber variables to PLC variables, simply use the ITc Sys Manager [} 116]::Linkvariables() [} 120] method. Code Snippet (C#): 80 Version: 1.5 Automation Interface

## Page 81

Configuration system Manager. Link Variales("TIPC^PLC Project^PLC Project Instance^Plc Task Outputs^MAIN.b Test Var", "TIID^Device 1 (Ether CAT Automation Protocol)^Box 1 (Publisher)^MAIN.b Test Var^Outputs^Var Data"); Code Snippet (Powershell): $system Manager. Link Variales("TIPC^PLC Project^PLC Project Instance^Plc Task Outputs^MAIN.b Test Var", "TIID^Device 1 (Ether CAT Automation Protocol)^Box 1 (Publisher)^MAIN.b Test Var^Outputs^Var Data") Please see the Scripting Container [} 182] sample "Ether CAT Automation Protocol" for more information. Reading Publisher/Subscriber variable IDs The following code snippet reads all variable IDs from a Publisher box and stores them in the List-Array "ids". This may also be used for Subscriber variables. Code Snippet (C#): List<uint> ids = new List<uint>(); ITc Sm Tree Item pub Box = system Manager. Lookup Tree Item("TIID^Device 1 (Ether CAT Automation Protocol)^Box 1 (Publisher)"); foreach(ITc Sm Tree Item var in pub Box) { if (var. Item Type == 35) // 35 = publisher variable, 36 = subscriber variable { string var Str = var. Produce Xml(); Xml Document var Xml = new Xml Document(); var Xml. Load Xml(var Str); Xml Node id = var Xml. Select Single Node("//Tree Item/Nv Pub Var Def/Nv Id"); ids. Add(Convert. To UInt32(id. Inner Xml)); } } Code Snippet (Powershell): $ids = New-Object System. Collections. Array List $pub Box = $system Manager. Lookup Tree Item("TIID^Device 1 (Ether CAT Automation Protocol)^Box 1 (Publisher)") foreach($var in $pub Box) { if($var. Item Type –eq 35) { $var Xml = [Xml]$var. Produce Xml() $id = $var Xml. Tree Item. Nv Pub Var Def. Nv Id $ids. Add($id) } } 4.3.6.3 Creating and handling Profinet devices This article explains how to create and handle Profinet I/O devices via Twin CAT Automation Interface. The following topics are being discussed: • Creating Profinet devices • Adding Profinet boxes • Adding Profinet modules • Adding Profinet Sub-Modules Creating Profinet devices To create Profinet I/O devices (Controller/Device), the ITc Sm Tree Item::Create Child() method can be used. The Sub Type sets the actual type that should be added. Automation Interface Version: 1.5 81

## Page 82

Configuration Name Sub Type Profinet Controller (RT) 113 Profinet Controller CCAT (RT) 140 Profinet Controller EL6631 (RT, Ether CAT) 119 Profinet Controller EL6632 (RT + IRT, Ether CAT) 126 Profinet Device (RT) 115 Profinet Device CCAT (RT) 142 Profinet Device CCAT (RT + IRT) 143 Profinet Device EL6631 (RT, Ether CAT) 118 Code Snippet (C#): ITc Sm Tree Item io = sys Manager. Lookup Tree Item("TIID"); ITc Sm Tree Item profinet Controller = io. Create Child("Profinet Controller", 113, null, null); Code Snippet (Powershell): $io = $sys Manager. Lookup Tree Item("TIID") $profinet Controller = $io. Create Child("Profinet Controller", 113, $null, $null) Adding Profinet boxes To create boxes below a Profinet device, the ITc Sm Tree Item::Create Child() may be used. The Sub Type depends on the box that should be added. The following table gives an overview about possible values: Name Sub Type BK9102 9125 EK9300 9128 EL6631 9130 In addition some knowledge about the corresponding Profinet GSD file is required to use the v Info parameter properly. The v Info parameter is composed of the following syntax: Path To GSDfile#Module Ident Number#Box Flags#DAPNumber The Module Ident Number can be determined from within the GSD file, e.g. via the XML structure <Profile Body><Application Process><Device Access Point List><Device Access Point Item Module Ident Number>. The Module Ident Number is usually unique. If not, the DAPNumber specifies the position in the Device Access Point List. The following Box Flags are currently interpreted: Name Value Description GENERATE_NAME_FROM_PAB 0x0004 Profinet name will be generated via process image GET_STATIONNAME 0x0400 Profinet name from TC config will be used (tree item name) SET_NOT_IP_TO_OS 0x4000 CE-only: Profinet IP will not be registered in OS Code Snippet (C#): ITc Sm Tree Item profinet EL6631 = profinet Controller. Create Child("EL6631", 9130, null, "C:\\Twin CAT\ \3.1\\Config\\Io\\Profinet\\GSDML-V2.31-beckhoff-EL6631-20140508.xml#0x3"); Code Snippet (Powershell): $profinet EL6631 = $profinet Controller. Create Child("EL6631", 9130, $null, "C:\\Twin CAT\\3.1\\Config\ \Io\\Profinet\\GSDML-V2.31-beckhoff-EL6631-20140508.xml#0x3") Adding Profinet modules Profinet modules are created below the API node of a Profinet box. The API node is automatically created when adding a Profinet box to the Twin CAT configuration. To add Profinet modules the ITc Sm Tree Item::Create Child() method may be used. The Sub Type determines the position of the module within the <Profile Body><Application Process><Module List> XML structure of the corresponding GSD file. Code Snippet (C#): 82 Version: 1.5 Automation Interface

## Page 83

Configuration ITc Sm Tree Item profinet EL6631api = profinet EL6631.get_Child(1); ITc Sm Tree Item profinet Module1 = profinet EL6631api. Create Child("", 30, null, null); // Sub Type 30 = 200 Byte In-Out ITc Sm Tree Item profinet Module2 = profinet EL6631api. Create Child("", 12, null, null); // Sub Type 12 = 8 Byte In-Out ITc Sm Tree Item profinet Module3 = profinet EL6631api. Create Child("", 8, null, null); // Sub Type 8 = 4 Byte Out Code Snippet (Powershell): $profinet EL6631api = $profinet EL6631.get_Child(1) $profinet Module1 = $profinet EL6631api. Create Child("", 30, $null, $null) $profinet Module2 = $profinet EL6631api. Create Child("", 12, $null, $null) $profinet Module3 = $profinet EL6631api. Create Child("", 8, $null, $null) Adding Profinet Sub-Modules Profinet Sub-Modules can be added below a so-called Profinet Modular Module. The handling is very similar to when adding regular Profinet modules. The Sub Type determines the position of the Sub-Module within the <Profile Body><Application Process><Module List> XML structure of the corresponding GSD file. Code Snippet (C#): ITc Sm Tree Item profinet Modular Module = profinet EL6631api. Create Child("", 98, null, null); // Sub Type 98 = Modular ITc Sm Tree Item modular Module1 = profinet Modular Module. Create Child("", 12, null, null); // Sub Type 12 = 8 Byte In-Out ITc Sm Tree Item modular Module2 = profinet Modular Module. Create Child("", 14, null, null); // Sub Type 14 = 16 Byte Out ITc Sm Tree Item modular Module3 = profinet Modular Module. Create Child("", 31, null, null); // Sub Type 31 = 8 Word In Code Snippet (Powershell): $profinet Modular Module = $profinet EL6631api. Create Child("", 98, $null, $null) $modular Module1 = $profinet Modular Module. Create Child("", 12, $null, $null) $modular Module2 = $profinet Modular Module. Create Child("", 14, $null, $null) $modular Module3 = $profinet Modular Module. Create Child("", 31, $null, $null) 4.3.6.4 Creating and handling Profibus devices This article explains how to create and handle Profibus Master and Slave devices via Twin CAT Automation Interface. It consists of following main points: • Creating and adding a Profibus Master • Searching appropriate device (EL6731, FC310x, etc.) and configuring • Creating and adding a Profibus Slave • Searching appropriate Slave device (EL6731-0010, etc.) and configuring • Changing fieldbus address Creating and adding a Profibus Master 1. To create a Profibus Master device, open a new or an existing Twin CAT configuration Automation Interface Version: 1.5 83

## Page 84

Configuration 2. Scan all the devices. (These actions can also be performed via Automation Interface.) 3. Create a system manager object and navigate to devices Code Snippet (C#): project = solution. Projects. Item(1); sysman = (Itc Sys Manager)project. Object; ITc Sm Tree Item io = (ITc Sm Tree Item)sysman. Lookup Tree Item("TIID"); Code Snippet (Powershell): $project = $sln. Projects. Items(1) $sysman = $project. Object $io = $sysman. Lookup Tree Item("TIID") To add a Profibus master, use ITc Sm Tree Item:Create Child method. Code Snippet (C#): ITc Sm Tree Item5 profi_master = (ITc Sm Tree Item5)io. Create Child("Device 2 (EL6731)", 86, "", null); Code Snippet (Powershell): $profi_master = $io. Create Child("Device 2 (EL6731) ", "86", "", $null) For other Profibus Masters, enter the correct Item Subtype listed here. This will add the new device as shown in the screenshot: 84 Version: 1.5 Automation Interface

## Page 85

Configuration Searching and claiming a Profibus Master device from the list: It is necessary to configure the newly added Profibus master, which is usually done in Twin CAT by pressing the search button and selecting the correct device from the list: This can be done via Automation Interface: Code Snippet (C#): string available Master = profi_master. Resources Count; profi_master. Claim Resources(1); Code Snippet (Powershell): $available Master = $profi_master. Resources Count $profi_master. Claim Resources(1) The ITc Sm Tree Item5:Resources Count gives out the number of compatible Profibus master devices, and the ITc Sm Tree Item5:Claim Resources takes the index of the CANOpen device to be configured as the master. Creating and adding a Profibus slave A Profibus slave can be added to the current configuration as shown below: Code Snippet (C#): ITc Sm Tree Item5 profi_slave = (ITc Sm Tree Item5)io. Create Child("Device 3 (EL6731-0010)", 97, null); Code Snippet (Powershell): $profi_slave = $io. Create Child("Device 3 (EL6731-0010)", "97", "", $null) Searching and claiming a Profibus slave Similar to Profibus master, number of Profibus slaves can be published by following code: Code Snippet (C#): string available Slaves = profi_slave. Resources Count; profi_slave. Claim Resource(1); Code Snippet (Powershell): Automation Interface Version: 1.5 85

## Page 86

Configuration $available Slaves = $profi_slave. Resources Count $profi_slave. Claim Resources(1) The last line in code claims the EL6731-0010 as the Profibus slave, similar to the dialog box that appears in Twin CAT user interface. Fig. 2: Changing fieldbus address To change the the fieldbus address (station no.) of a profibus box in a configuration, an instance of the Twin CAT System Manager has to be created and the configuration has to be opened. The Lookup Tree Item [} 122] method of the ITc Sys Manager [} 116] interface returns a ITc Sm Tree Item [} 124] interface pointer implemented by the tree item referenced by its pathname [} 10]. This interface contains a Consume Xml [} 159] method of the tree item. Procedure The Procedure to create the ITc Sys Manager [} 116] interface (the 'sys Man' instance here) is described in the chapter Accessing Twin CAT Configurations. [} 20] This interface has a Lookup Tree Item [} 122] method that returns a ITc Sm Tree Item [} 124] pointer to a specific tree item given by its pathname [} 10]. To change the the fieldbus address (station no.) of a profibus box "TIID^Device 1 (FC310x)^Box 1 (BK3100)" to 44 the following code can be used: Code Snippet (C#): Itc Sm Tree Item item = sys Man. Lookup Tree Item("TIID^Device 1 (FC310x)^Box 1 (BK3100)"); item. Consume Xml("44"); Code Snippet (Power Shell): $item = $sys Man. Lookup Tree Item("TIID^Device 1 (FC310x)^Box 1 (BK3100)") $item. Consume Xml("44") 4.3.6.5 Creating and handling CANOpen devices This article explains how to create and handle CANOpen Master and Slave devices via Twin CAT Automation Interface. It consists of following main points: • Creating and adding a CANOpen Master • Searching appropriate devices (EL6751, FC510x, etc.) and configuring • Creating and adding CANOpen Slave • Searching appropriate devices (EL6751-0010, etc.) and configuring • Importing DBC files via Automation Interface Creating and adding a CANOpen Master 86 Version: 1.5 Automation Interface

## Page 87

Configuration To create a CANOpen Master device, open a new or an existing Twin CAT configuration, scan all the devices. Note that these actions can also be performed via Automation Interfaces Create a system manager object, and navigate to devices. Code Snippet (C#): project = solution. Projects. Item(1); sysman = (ITc Sys Manager)project. Object; ITc Sm Tree Item io = (ITc Sm Tree Item)sysman. Lookup Tree Item("TIID"); Code Snippet (Powershell): $project = $sln. Projects. Items(1) $sysman = $project. Object $io = $sysman. Lookup Tree Item("TIID") To add a CANOpen Master, use ITc Sm Tree Item:Create Child method: Code Snippet (C#): ITc Sm Tree Item5 can_master = (ITc Sm Tree Item5)io. Create Child("Device 2 (EL6751)", 87, "", null); Code Snippet (Powershell): $can_master = $io. Create Child("Device 2 (EL6751)", "87", "", $null) For other CANOpen master devices, enter the correct Item Subtype listed here [} 133]. This will add the new device as shown in the screenshot: Automation Interface Version: 1.5 87

## Page 88

Configuration Fig. 3: CANOpen Master added Searching and claiming a CANOpen Master device from the list: It is necessary to configure the newly added CANOpen master, which is usually done in Twin CAT by pressing the search button and selecting the correct device from the list: Fig. 4: CANOpen Master via Search button This can be done via Automation Interface: Code Snippet (C#): string available Master = can_master. Resource Count; can_master. Claim Resources(1); 88 Version: 1.5 Automation Interface

## Page 89

Configuration Code Snippet (Powershell): $available Master = $can_master. Resource Count $can_master. Claim Resources(1) The ITc Sm Tree Item5:Resource Count gives out the number of compatible CANOpen master devices and the ITc Sm Tree Item5:Claim Resources takes the index of the CANOpen device to be configured as the master. Creating and adding a CANOpen Slave A CANOpen slave can be added to the current configuration as shown below: Code Snippet (C#): ITc Sm Tree Item5 can_slave = (ITc Sm Tree Item5)io. Create Child("Device 3 (EL6751-0010)", "98", null); Code Snippet (Powershell): $can_slave = $io. Create Child("Device 3 (EL6751-0010)", "98", $null) Searching and claiming a CANOpen slave Similar to CANOpen Master, a list of CANOpen slaves can be published by following code: Code Snippet (C#) : string available Slaves = can_slave. Resource Count; can_slave. Claimresources(1); Code Snippet (Powershell) : $available Slaves = $can_slave. Resource Count $can_slave. Claimresources(1) The last line of code, claims the EL6751-0010 as the CANOpen slave, similar to the dialog box that appears in Twin CAT user interface. Fig. 5: CANOpen claim resources via dialog box Importing DBC files via Automation Interface Required Version: Twin CAT 3.1 Build 4018 or above Twin CAT offers DBC file to be imported via dialog box as seen in the screenshot. On right clicking a CANOpen Master e.g. EL6751 and selecting “Import dbc-file”, a dialog box prompts user to browse the DBC file. Upon clicking okay, a CANOpen configuration is loaded automatically. Automation Interface Version: 1.5 89

## Page 90

Configuration Fig. 6: CANOpen DBC file importing Automation Interface also supports DBC file import. To do this, navigate to the CANOpen Master tree item and export the Xml file via ITc Sm Tree Item:Produce Xml(). In the Xml file, add the path to the DBC file to be imported along with the additional properties that are part of the dialog box shown above. <Device Def> <Ams Port>28673</Ams Port> <Ams Net Id>172.17.251.109.2.1</Ams Net Id> <Address Info> <Ecat> <Ether CATDevice Id>0</Ether CATDevice Id> </Ecat> </Address Info> <Max Boxes>126</Max Boxes> <Scan Boxes>false</Scan Boxes> <Can Open Master> <Import Dbc File> <File Name>c:\dbc_file_folder\dbc_file_to_be_imported.dbc</File Name> <Import Extended Messages>false</Import Extended Messages> <Import Multiplexed Data Messages>false</Import Multiplexed Data Messages> <Keep Unchanged Messages>true</Keep Unchanged Messages> <Ext Boxes Support>false</Ext Boxes Support> <Vector XXXSupport>false</Vector XXXSupport> <Communicate With Slaves From Dbc File>true</Communicate With Slaves From Dbc File> </Import Dbc File> </Can Open Master> <Fcxxxx> <Calculate Equi Times>0</Calculate Equi Times> <Node Id>127</Node Id> <Baudrate>500 k</Baudrate> <Disable Node State Modification>false</Disable Node State Modification> </Fcxxxx> </Device Def> Import the modified Xml file back into the Twin CAT configuration via ITc Sm Tree Imte:Consume Xml(). The configuration will now be loaded below the CANOpen Master. 4.3.6.6 Creating and handling Devicenet devices Just like any other I/O component, Devicenet devices may be added via the Twin CAT Automation Interface by using the Create Child() method of the ITc Sm Tree Item interface. The Sub Type specifies the device that should be added. Code Snippet (C#): ITc Sm Tree Item io = sys Manager. Lookup Tree Item("TIID"); ITc Sm Tree Item devicenet1 = io. Create Child("Device 1 (EL6752)", 88, null, null); ITc Sm Tree Item devicenet2 = io. Create Child("Device 2 (EL6752-0010)", 99, null, null); 90 Version: 1.5 Automation Interface

## Page 91

Configuration Code Snippet (Powershell): $io = $sys Manager. Lookup Tree Item("TIID") $devicenet1 = $io. Create Child("Device 1 (EL6752)", 88, $null, $null) $devicenet2 = $io. Create Child("Device 2 (EL6752-0010)", 99, $null, $null) The following table gives an overview about all Devicenet I/O devices and their corresponding Sub Types. If a device should be missing, you can always find out the Sub Type yourself by following our documentation article about the XML description of a tree item [} 25]. Device Sub Type Devicenet Master FC52xx PCI 41 Devicenet Master EL6752 Ether CAT 88 Devicenet Slave FC52xx PCI 62 Devicenet Slave EL6752 Ether CAT 99 Devicenet Master CX1500-M520 PC104 73 Devicenet Slave CX1500-B520-PC104 74 Devicenet Monitor FC52xx PCI 59 Devicenet boxes can also be attached via Create Child(). The Sub Type specifies the box that should be added. Code Snippet (C#): ITc Sm Tree Item devicenet1box = devicenet1. Create Child("Box 2 (EL6752-0010)", 5203, null, null); Code Snippet (Powershell): $devicenet1box = $devicenet1. Create Child("Box 2 (EL6752-0010)", 5203, $null, $null) To add variables to a Devicenet box, simply use the following code snippet. The v Info parameter specifies the data type of the variable. Code Snippet (C#): ITc Sm Tree Item input Vars = devicenet1box. Lookup Child("Inputs"); input Vars. Create Child("Test Var Int", 0, null, "INT"); input Vars. Create Child("Test Var Bool", 0, null, "BOOL"); Code Snippet (Powershell): $input Vars = $devicenet1box. Lookup Child("Inputs") $input Vars. Create Child("Test Var Int", 0, $null, "INT") $input Vars. Create Child("Test Var Bool", 0, $null, "BOOL") 4.3.6.7 Creating and handling AX5000 devices This documentation article describes how to create AX5000 devices and and modify their mailbox startup list as well as their power management, PDO and motor condfiguration. All of these settings can be modifies by using the XML description [} 25] of the AX5000 Tree Item. This article consists of the following chapters: • Creating an AX5000 I/O device • Overview XML description • Parametrization and template generation • Available tools and samples • Mappings Creating an AX5000 I/O device AX5000 devices can be created by using the Create Child() method. Please consult the documentation article Creating and handling Ether CAT devices [} 70] for more information. Code snippet (C#) Automation Interface Version: 1.5 91

## Page 92

Configuration ITc Sm Tree Item ether Cat Master = sys Manager. Lookup Tree Item("TIID^Ether CAT Master"); ITc Sm Tree Item ax5000 = ethercat Master. Create Child("AX5000", 9099, "", "AX5203"); Code snippet (Powershell) $ether Cat Master = $sys Manager. Lookup Tree Item("TIID^Ether CAT Master") $ax5000 = $ethercat Master. Create Child("AX5000", 9099, "", "AX5203") Overview XML description The XML description of an AX5000 device consists of the following parts (references to an XML node written as XPath). Part Description /Tree Item/Ether CAT/Slave/Mailbox/So E/Init Cmds/ Mailbox startup list for drive, including the power management and motor configuration. /Tree Item/Ether CAT/Slave/Process Data/Tx Pdo PDO configuration /Tree Item/Ether CAT/Slave/Process Data/Rx Pdo Mailbox startup list The mailbox startup list therefore includes many different types of init commands, which are identified via their IDN. Please note that the IDN that is displayed in Twin CAT XAE does not equal the IDN in the XML description, which is why a mapping needs to happen. For example: The IDN P-0-0050 (Motor construction type) equals <IDN>32818</IDN> (0x800A hex). To make this mapping and the identification which init command belongs to which type (drive, motor, power management), the tools that are mentioned below already include a sample mapping for an AX5000_0000_0210. Import of startup list Please note that the startup list always needs to be imported as a whole (including all init com- mands). This is also true if only one or two init commands have been changed. PDO configuration The PDO configuration is straight-forward and consists of a Tx Pdo (Inputs) and Rx Pdo (Outputs) section. Each PDO entry is identified by its Index (hex) and contains a name, bit length and data type. The optional property “Fixed” describes whether this entry can be deleted via Twin CAT XAE. Ads Info When creating a template, the <Ads Info> section does not need to be present and can be removed from the template file because this information is generated by the Twin CAT XAE. Import of PDO configuration Please note that the PDO configuration always needs to be imported as a whole. This is also true if only one or two PDO entries have been changed. Parametrization and template generation It is recommended to create templates for different AX5000 configurations and also a different template for each channel (A and B) of a drive. These templates can then be assembled to a full AX5000 XML description, which can be imported either via the XAE menu entry “Twin CAT -> Selected Item -> Import XML description” or via the Automation Interface method Consume Xml(). In order to make the template generation process easier, several tools and samples for the Windows Powershell and C# are available for download. All of these tools are further described below. 92 Version: 1.5 Automation Interface

## Page 93

Configuration Available tools and samples The following table provides an overview about the available tools and samples that provide help with handling AX5000 configurations via Automation Interface. Name Language Description Create Tc Io Ax5000_Templates Windows Powershell Demonstrates how to generate template files out of a pre- configured AX5000 configuration. Create Tc Io Ax5000_Config Windows Powershell Demonstrates how to create an AX5000 configuration based on template files. Please note that these scripts do not use the Twin CAT Automation Interface API but instead provide help with the preparation of XML configuration files. Create Tc Io Ax5000_Templates This Windows Powershell script demonstrates how to generate template files out of a pre-configured AX5000 configuration. As a prerequisite, the AX5000 configuration needs to be exported to XML via the Twin CAT XAE menu entry “Twin CAT -> Selected Item -> Export XML description”. This has been done demonstratively for two configuration (Selected Item_Export Xml_Test1.xml and Selected Item_Export Xml_Test2.xml). The path to one of these files is then configured in the local variable $Full Name Xml Export within the Powershell script. The script then loads the config file and subsequently extracts the XML configuration entries for the mailbox startup list, PDOs, power management and motor configuration and saves this information in separate template files (for each channel and for each type of configuration), which can later be re-added to a configuration by using the script “Create Tc Io Ax5000_Config”. Create Tc Io Ax5000_Config This Windows Powershell scripts demonstrates how to build a full AX5000 configuration out of different template files. These template files provide the settings for the PDO configuration as well as the mailbox startup list with their init commands for power management and motor configuration. The script output is a full AX5000 XML description, which can be imported on a AX5000 Tree Item either by using the menu entry “Twin CAT -> Selected Item -> Import XML description” or by using the Automation Interface method Consume Xml(). At the beginngin of the script, the local variable $Full Name Config File includes the path to the output file. Next, the script provides three different AX5000 configurations to choose from, each using a different template combination from the templates that were previously generated by using the script Create Tc Io Ax5000_Templates (see above). Depending on the chosen config, the script then builds the AX5000 XML description by importing the different configuration parts into their corresponding XML section. Mappings Process data mapping can be performed via regular Automation Interface mechanisms. Please consult the article Creating and handling variable mappings [} 41] for more information. 4.3.6.8 Scanning for devices and boxes When creating a new configuration it is often necessary to align the Twin CAT XAE configuration to the actually available hardware. One option to fullfill this is to start a new Twin CAT XAE configuration from scratch and process the following steps: • Creation of a new Twin CAT XAE configuration • Setting the address of the target system Automation Interface Version: 1.5 93

## Page 94

Configuration • Scan of the available devices • Addition and parametrization of the devices to be used • Scanning and insertion of boxes for each device Procedure The procedure to create the ITc Sys Manager [} 116] interface (the 'system Manager' instance here) is described in the chapter Accessing Twin CAT Configurations. [} 20] This interface has a Lookup Tree Item [} 122] method that returns a ITc Sm Tree Item [} 124] pointer to a specific tree item given by its pathname [} 10], in this case the shortcut "TIID" which references the I/O devices node. Code snippet (C#): ITc Sys Manager3 system Manager = null; public void Scan Devices And Boxes() { system Manager. Set Target Net Id("1.2.3.4.5.6"); ITc Sm Tree Item io Devices Item = system Manager. Lookup Tree Item("TIID"); string scanned Xml = io Devices Item. Produce Xml(false); Xml Document xml Doc = new Xml Document(); xml Doc. Load Xml(scanned Xml); Xml Node List xml Device List = xml Doc. Select Nodes("Tree Item/Device Grp Def/Found Devices/Device"); List<ITc Sm Tree Item> devices = new List<ITc Sm Tree Item>(); int device Count = 0; foreach (Xml Node node in xml Device List) { int item Sub Type = int. Parse(node. Select Single Node("Item Sub Type"). Inner Text); string type Name = node. Select Single Node("Item Sub Type Name"). Inner Text; Xml Node xml Address = node. Select Single Node("Address Info"); ITc Sm Tree Item device = io Devices Item. Create Child(string. Format("Device_{0}",+ +device Count),item Sub Type,string. Empty,null); string xml = string. Format("<Tree Item><Device Def>{0}</Device Def></ Tree Item>",xml Address. Outer Xml); device. Consume Xml(xml); devices. Add(device); } foreach (ITc Sm Tree Item device in devices) { string xml = "<Tree Item><Device Def><Scan Boxes>1</Scan Boxes></Device Def></Tree Item>"; try { device. Consume Xml(xml); } catch (Exception ex) { Console. Write Line("Warning: {0}",ex. Message); } foreach (ITc Sm Tree Item box in device) { Console. Write Line(box. Name); } } } 4.3.6.9 Enabling and disabling I/O devices To disable/enable a tree item in a configuration, an instance of the Twin CAT System Manager has to be created and the configuration has to be opened. The Lookup Tree Item [} 122] method of the ITc Sys Manager [} 116] interface returns a ITc Sm Tree Item [} 124] interface pointer implemented by the tree item referenced by its pathname [} 10]. This interface contains a Disabled [} 124] property of the tree item. Procedure The Procedure to create the ITc Sys Manager [} 116] interface (the 'sys Man' instance here) is described in the chapter Accessing Twin CAT Configurations. [} 20] This interface has a Lookup Tree Item [} 122] method that returns a ITc Sm Tree Item [} 124] pointer to a specific tree item given by its pathname [} 10]. To disable/ enable the tree item "TIID^Ether CAT Master" the following code snippets can be used. 94 Version: 1.5 Automation Interface

## Page 95

Configuration Sample (CSharp): ITc Sm Tree Item item = sys Man. Lookup Tree Item("TIID^Ether CAT Master"); item. Disabled = DISABLED_STATE. SMDS_DISABLED; Please note, that, for this sample, you need to add both a reference to "Microsoft Developer Environment 10.0" and "Beckhoff TCat Sys Manager Library 1.1" to your project. Sample (Power Shell): $DISABLED_STATE = @{"SMDS_NOT_DISABLED" = "0"; "SMDS_DISABLED" = "1"} $item = $system Manager. Lookup Tree Item("TIID^Ether CAT Master") $item. Disabled = $DISABLED_STATE. SMDS_DISABLED Sample (VBScript): dim dte,sln,proj,sys Man set dte = Create Object("Visual Studio. DTE.10.0") set sln = dte. Solution call sln. Open("C:\Solution Folder\My Solution1.sln") set proj = sln. Projects(1) set sys Man = proj. Object set item = sys Man. Lookup Tree Item("TIID^Ether CAT Master") item. Disabled = SMDS_DISABLED '(oder item. Disabled = SMDS_NOT_DISABLED um Strukturelement zu aktivieren) 4.3.7 Tc COM 4.3.7.1 Creating and handling Tc COM modules This chapter explains how to add existing Tc COM modules to a Twin CAT configuration and parameterize them. The following topics will be briefly covered in this chapter: • Acquiring a reference to “Tc COM Objects” node • Adding existing Tc COM modules • Iterating through added Tc COM modules • Setting Create Symbol flag for parameters • Setting Create Symbol flag for Data Areas • Setting Context (Tasks) • Linking variables Acquiring a reference to “Tc COM Objects” node In a Twin CAT configuration, the “Tc COM Objects” node is located under “SYSTEM^Tc COM Objects”. Therefore you can acquire a reference to this node by using the method ITc Sys Manager::Lookup Tree Item() in the following way: Code Snippet (C#): ITc Sm Tree Item tc Com Objects = system Manager. Lookup Tree Item("TIRC^Tc COM Objects"); Code Snippet (Powershell): $tc Com Objects = $system Manager. Lookup Tree Item("TIRC^Tc COM Objects") The code above assumes that there is already a system Manager objects present in your AI code. Adding existing Tc COM modules To add existing Tc COM modules to your Twin CAT configuration, these modules need to be detectable by Twin CAT. This can be achieved by either of the following ways: • Copying Tc COM modules to folder %TWINCAT3. XDIR”\Custom Config\Modules\ • Editing %TWINCAT3. XDIR”\Config\Io\Tc Module Folders.xml to add a path to a folder of your choice and place the modules within that folder Automation Interface Version: 1.5 95

## Page 96

Configuration Both ways will be sufficient to make the Tc COM modules detectable by Twin CAT. A Tc COM module is being identified by its GUID or name: • This GUID can be used to add a Tc COM module to a Twin CAT configuration via the ITc Sm Tree Item::Create Child() method. The GUID can be determined in Twin CAT XAE via the properties page of a Tc COM module. Alternatively, you can also determine the GUID via the TMC file of the Tc COM module. <Tc Module Class> <Modules> <Module GUID="{8f5fdcff-ee4b-4ee5-80b1-25eb23bd1b45}"> ... </Module> </Modules> </Tc Module Class> Let’s assume that we already own a Tc COM module that is registered in and detectable by Twin CAT. We now would like to add this Tc COM module, which has the GUID {8F5FDCFF- EE4B-4EE5-80B1-25EB23BD1B45} to our Twin CAT configuration. This can be done by the following way: Code Snippet (C#): Dictionary<string,Guid> tcom Module Table = new Dictionary<string,Guid>(); tcom Module Table. Add("Temp Contr",Guid. Parse("{8f5fdcff-ee4b-4ee5-80b1-25eb23bd1b45}")); ITc Sm Tree Item temp Controller = tc Com Objects. Create Child(“Test”, 0, "", tcom Module Table["Temp Contr"]); Code Snippet (Powershell): $tcom Module Table = @"" $tcom Module Table. Add("Temp Contr", "{8f5fdcff-ee4b-4ee5-80b1-25eb23bd1b45}") $temp Controller = $tc Com Objects. Create Child("Test", 0, "", $tcom Module Table["Temp Contr"]) Please note that the v Info parameter of the method Itc Sm Tree Item::Create Child() contains the GUID of the Tc COM module which is used to identify the module in the list of all registered Tc COM modules in that system. • This name can be used to add a Tc COM module to a Twin CAT configuration via the ITc Sm Tree Item::Create Child() method. The name can be determined in Twin CAT XAE via the TMC Editor. 96 Version: 1.5 Automation Interface

## Page 97

Configuration • • This can be done by the following way: Code Snippet (C#): ITc Sm Tree Item temp Controller = tc Com Objects. Create Child(“Test”, 1, "", "New Module"); Code Snippet (Powershell): $temp Controller = $tc Com Objects. Create Child("Test", 0, "", "New Module") Iterating through added Tc COM modules To iterate through all added Tc COM module instances, you may use the ITc Module Manager2 interface. The following code snippet demonstrates how to use this interface. Code Snippet (C#): ITc Module Manager2 module Manager = (ITc Module Manager2)system Manager. Get Module Manager(); foreach (ITc Module Manager2 module Instance in module Manager) { string module Type = module Instance. Module Type Name; string instance Name = module Instance. Module Instance Name; Guid class Id = module Instance. Class ID; uint obj Id = module Instance.oid; uint parent Obj Id = module Instance. Parent OID; } Code Snippet (Powershell): $module Manager = $system Manager. Get Module Manager() For Each( $module Instance in $module Manager ) { $module Type = $module Instance. Module Type Name $instance Name = $module Instance. Module Instance Name $class Id = $module Instance. Class ID $obj Id = $module Instance.oid $parent Obj Id = $module Instance. Parent OID } Please note that every module object can also be interpreted as an ITc Sm Tree Item, therefore the following type cast would be valid: Code Snippet (C#): ITc Sm Tree Item tree Item = module Instance As ITc Sm Tree Item; Please note: Powershell uses dynamic data types by default. Setting Create Symbol flag for parameters The Create Symbol (CS) flag for parameters of a Tc COM module can be set via its XML description. The following code snippet demonstrates how to activate the CS flag for the Parameter “Call By”. Code Snippet (C#): bool activate CS = true; // First step: Read all Parameters of Tc COM module instance string temp Controller Xml = temp Controller. Produce Xml(); Automation Interface Version: 1.5 97

## Page 98

Configuration Xml Document temp Controller Doc = new Xml Document(); temp Controller Doc. Load Xml(temp Controller Xml); Xml Node source Parameters = temp Controller Doc. Select Single Node("Tree Item/Tc Module Instance/Module/ Parameters"); // Second step: Build target XML (for later Consume Xml()) Xml Document target Doc = new Xml Document(); Xml Element tree Item Element = target Doc. Create Element("Tree Item"); Xml Element module Instance Element = target Doc. Create Element("Tc Module Instance"); Xml Element module Element = target Doc. Create Element("Module"); Xml Element parameters Element = (Xml Element) target Doc. Import Node(source Parameters, true); module Element. Append Child(parameters Element); module Instance Element. Append Child(module Element); tree Item Element. Append Child(module Instance Element); target Doc. Append Child(tree Item Element); // Third step: Look for specific parameter (in this case “Call By”) and read its Create Symbol attribute Xml Node dest Module = target Doc. Select Single Node("Tree Item/Tc Module Instance/Module "); Xml Node call By Parameter = dest Parameters. Select Single Node("Parameters/Parameter[Name='Call By']"); Xml Attribute create Symbol = call By Parameter. Attributes["Create Symbol"]; create Symbol. Value = "true"; // Fifth step: Write prepared XML to configuration via Consume Xml() string target Xml = target Doc. Outer Xml; temp Controller. Consume Xml(target Xml); Code Snippet (Powershell): $temp Controller Xml = [Xml]$temp Controller. Produce Xml() $source Parameters = $temp Controller Xml. Tree Item. Tc Module Instance. Module. Parameters [System. XML. Xml Document] $target Doc = New-Object System. XML. Xml Document [System. XML. Xml Element] $tree Item Element = $target Doc. Create Element("Tree Item") [System. XML. Xml Element] $module Instance Element = $target Doc. Create Element("Tc Module Instance") [System. XML. Xml Element] $module Element = $target Doc. Create Element("Module") [System. XML. Xml Element] $parameters Element = $target Doc. Import Node($source Parameters, $true) $module Element. Append Child($parameters Element) $module Instance Element. Append Child($module Element) $tree Item Element. Append Child($module Instance Element) $target Doc. Append Child($tree Item Element) $dest Module = $target Doc. Tree Item. Tc Module Instance. Module $call By Parameter = $destmodule. Select Single Node("Parameters/Parameter[Name='Call By']") $call By Parameter. Create Symbol = "true" $target Xml = $target Doc. Outer Xml $temp Controller. Consume Xml($target Xml) Setting Create Symbol flag for Data Areas The Create Symbol (CS) flag for Data Areas of a Tc COM module can be set via its XML description. The following code snippet demonstrates how to activate the CS flag for the Data Area “Input”. Please note that the procedure is pretty much the same as for parameters. Code Snippet (C#): bool activate CS = true; // First step: Read all Data Areas of a Tc COM module instance string temp Controller Xml = temp Controller. Produce Xml(); Xml Document temp Controller Doc = new Xml Document(); temp Controller Doc. Load Xml(temp Controller Xml); Xml Node source Data Areas = temp Controller Doc. Select Single Node("Tree Item/Tc Module Instance/Module/ Data Areas"); // Second step: Build target XML (for later Consume Xml()) Xml Document target Doc = new Xml Document(); Xml Element tree Item = target Doc. Create Element("Tree Item"); Xml Element module Instance = target Doc. Create Element("Tc Module Instance"); Xml Element module = target Doc. Create Element("Module"); Xml Element data Areas = (Xml Element) target Doc. Import Node(source Data Areas, true); module. Append Child(data Areas); module Instance. Append Child(module); tree Item. Append Child(module Instance); target Doc. Append Child(tree Item); 98 Version: 1.5 Automation Interface

## Page 99

Configuration // Third step: Look for specific Data Area (in this case "Input") and read its Create Symbol attribute Xml Element data Area = (Xml Element)target Doc. Select Single Node("Tree Item/Tc Module Instance/Module/ Data Areas/Data Area[Context Id=’0’ and Name=’Input’]"); Xml Node data Area No = data Area. Select Single Node("Area No"); Xml Attribute create Symbol = data Area No Node. Attributes["Create Symbols"]; // Fourth step: Set Create Symbol attribute to true if it exists. If not, create attribute and set its value if (create Symbol != null) string old Value = create Symbol. Value; else { create Symbol = target Doc. Create Attribute("Create Symbols"); data Area No. Attributes. Append(create Symbol); } create Symbol. Value = Xml Convert. To String(activate CS); // Fifth step: Write prepared XML to configuration via Consume Xml() string target Xml = target Doc. Outer Xml; temp Controller. Consume Xml(target Xml); Code Snippet (Powershell): $temp Controller Xml = [Xml]$temp Controller. Produce Xml() $source Data Areas = $temp Controller Xml. Tree Item. Tc Module Instance. Module. Data Areas [System. XML. Xml Document] $target Doc = New-Object System. XML. Xml Document [System. XML. Xml Element] $tree Item = $target Doc. Create Element("Tree Item") [System. XML. Xml Element] $module Instance = $target Doc. Create Element("Tc Module Instance") [System. XML. Xml Element] $module = $target Doc. Create Element("Module") [System. XML. Xml Element] $data Areas = $target Doc. Import Node($source Data Areas, $true) $module. Append Child($data Areas) $module Instance. Append Child($module) $tree Item. Append Child($module Instance) $target Doc. Append Child($tree Item) $dest Module = $target Doc. Tree Item. Tc Module Instance. Module [System. XML. Xml Element] $data Area = $dest Module. Select Single Node("Data Areas/Data Area[Context Id='0' and Name='Input']") $data Area No = $data Area. Select Single Node("Area No") $data Area No. Create Symbols = "true" // Fifth step: Write prepared XML to configuration via Consume Xml() $target Xml = $target Doc. Outer Xml $temp Controller. Consume Xml($target Xml) Setting Context (Tasks) Every Tc COM module instance needs to be run in a specific context (task). This can be done via the ITc Module Instance2::Set Module Context() method. This method awaits two parameters: Context Id and Task Object Id. Both are equivalent to the corresponding parameters in Twin CAT XAE: Please note that the Task Object Id is shown in hex in Twin CAT XAE. Automation Interface Version: 1.5 99

## Page 100

Configuration Code Snippet (C#): ITc Module Instance2 temp Controller Mi = (ITc Module Instance2) temp Controller; temp Controller Mi. Set Module Context(0, 33619984); You can determine the Task Object Id via the XML description of the corresponding task, for example: Code Snippet (C#): ITc Sm Tree Item some Task = system Manager. Lookup Tree Item(“TIRT^Some Task”); string some Task Xml = some Task. Produce Xml(); Xml Document some Task Doc = new Xml Document(); some Task Doc. Load Xml(some Task Xml); Xml Node task Object Id Node = some Task Doc. Select Single Node(“Tree Item/Object Id”); string task Object Id Str = task Object Id. Inner Text; uint task Object Id = uint. Parse(task Object Id Str, Number Styles. Hex Number); Linking variables Linking variables of a Tc COM module instance to PLC/IO or other Tc COM modules can be done by using regular Automation Interface mechanisms, e.g. ITc Sys Manager::Link Variables(). 4.3.8 C++ 4.3.8.1 Creating and handling C++ projects and modules This chapter explains in-depth how to create, access and handle Twin CAT C++ projects. The following list shows all chapters in this article: • General information about C++ projects • Creating new C++ projects • Creating new module within a C++ project • Opening existing C++ projects • Creating module instances • Calling TMC Code Generator • Calling Publish Modules command • Setting C++ Project Properties • Building project General information about C++ projects C++ projects are specified by their so-called project template, which are used by the “Twin CAT C++ Project Wizard”. Inside a project multiple modules could be defined by module templates, which are used by the “Twin CAT Class Wizard”. Twin CAT-defined templates are documented in the Section C++ / Wizards. The customer could define own templates, which is documented at the corresponding sub-section if C++ Section / Wizards. Create C++ projects To create a new C++ project using the Automation Interface, you must navigate to the C++ node and then execute the Create Child() method with the appropriate template file as a parameter. Code snippet (C#): ITc Sm Tree Item cpp = system Manager. Lookup Tree Item("TIXC"); ITc Sm Tree Item cpp Project = cpp. Create Child("New Cpp Project", 0, "", path To Template File); Code snippet (Powershell): 100 Version: 1.5 Automation Interface

## Page 101

Configuration $cpp = $system Manager. Lookup Tree Item("TIXC") $new Project = $cpp. Create Child("New Cpp Project", 0, "", $path To Template File) To instantiate a driver project, use "Tc Versioned Driver Wizard" as path To Template File. Creating new module within a C++ project Within a C++ project usually a Twin CAT Module Wizard is used to let the wizard create a module by a template. Code snippet (C#): ITc Sm Tree Item cpp Module = cpp Project. Create Child("New Module", 1, "", path To Template File); Code snippet (Powershell): $cpp Module = $cpp Project. Create Child("New Module", 0, "", $path To Template File); As example for instantiating a Cyclic IO module project please use "Tc Module Cyclic Caller Wizard " as path To Template File. Opening existing C++ projects To open an existing C++-Project via Automation Interface, you need to navigate to the C++ node and then execute the Create Child() method with the path to the corresponding C++ project file as a parameter. You can use three different values as Sub Type: • 0: Copy project to solution directory • 1: Move project to solution directory • 2: Use original project location (specify “” as Name Of Project parameter) Basically, these values represent the functionalities (Yes, No, Cancel) from the following Message Box in Twin CAT XAE: In place of the template file you need to use the path to the C++ project (to its vcxproj file) that needs to be added. As an alternative, you can also use a C++ project archive (tczip file). Code snippet (C#): ITc Sm Tree Item cpp = system Manager. Lookup Tree Item("TIXC"); ITc Sm Tree Item new Project = cpp. Create Child("Name Of Project", 1, "", path To Project Or Tczip File); Code snippet (Powershell): $cpp = $system Manager. Lookup Tree Item("TIXC") $new Project = $cpp. Create Child("Name Of Project", 1, "", $path To Project Or Tczip File) Please note that C++ projects can’t be renamed, thus the original project name needs to be specified. (cmp. Renaming Twin CAT C++ projects) Automation Interface Version: 1.5 101

## Page 102

Configuration Creating module instances Tc COM Modules could be created at the System -> Tc COM Modules node. Please see documentation there [} 95]. The same procedure could also be applied to the C++ project node to add Tc COM instances at that place ($new Project at the code on top of this page.). Calling TMC Code Generator TMC Code generator could be called to generate C++ code after changes at the TMC file of the C++ project. Code snippet (C#): string start Tmc Code Generator = @"<?xml version=""1.0"" encoding=""UTF-16""?> <Tree Item> <Cpp Project Def> <Methods> <Start Tmc Code Generator> <Active>true</Active> </Start Tmc Code Generator> </Methods> </Cpp Project Def> </Tree Item>"; cpp Project. Consume Xml(start Tmc Code Generator); Code snippet (Powershell): $start Tmc Code Generator = @"<?xml version=""1.0"" encoding=""UTF-16""?> <Tree Item> <Cpp Project Def> <Methods> <Start Tmc Code Generator> <Active>true</Active> </Start Tmc Code Generator> </Methods> </Cpp Project Def> </Tree Item>" $cpp Project. Consume Xml($start Tmc Code Generator) Calling Publish Modules command Publishing includes building the project for all platforms. The compiled module will be provided for Export like described in the Module-Handling section of C++. Code snippet (C#): string publish Modules = @"<?xml version=""1.0"" encoding=""UTF-16""?> <Tree Item> <Cpp Project Def> <Methods> <Publish Modules> <Active>true</Active> </Publish Modules> </Methods> </Cpp Project Def> </Tree Item>"; cpp Project. Consume Xml(publish Modules); Code snippet (Powershell): $publish Modules = @"<?xml version=""1.0"" encoding=""UTF-16""?> <Tree Item> <Cpp Project Def> <Methods> <Publish Modules> <Active>true</Active> </Publish Modules> </Methods> </Cpp Project Def> </Tree Item>" $cpp Project. Consume Xml($publish Modules) 102 Version: 1.5 Automation Interface

## Page 103

Configuration Setting C++ Project Properties C++ projects provide different options for the build and deployment process. These are settable by the Automation Interface. Code snippet (C#): string proj Props = @"<?xml version=""1.0"" encoding=""UTF-16""?> <Tree Item> <Cpp Project Def> <Boot Project Encryption>Target</Boot Project Encryption> <Target Archive Settings> <Save Project Sources>false</Save Project Sources> </Target Archive Settings> <File Archive Settings> <Save Project Sources>false</Save Project Sources> </File Archive Settings> </Cpp Project Def> </Tree Item>"; cpp Project. Consume Xml(proj Props); Code snippet (Powershell): $proj Props = @"<?xml version=""1.0"" encoding=""UTF-16""?> <Tree Item> <Cpp Project Def> <Boot Project Encryption>Target</Boot Project Encryption> <Target Archive Settings> <Save Project Sources>false</Save Project Sources> </Target Archive Settings> <File Archive Settings> <Save Project Sources>false</Save Project Sources> </File Archive Settings> </Cpp Project Def> </Tree Item>" $cpp Project. Consume Xml($proj Props) For the Boot Project Encryption the values “None” and “Target” are valid. Both other settings are “false” and “true” values. Building project To build the project or solution you can use the corresponding classes and methods of the Visual Studio API, which are documented here [} 31]. 4.3.9 Measurement 4.3.9.1 Creating and handling Twin CAT Measurement projects The Twin CAT Automation Interface provides methods and properties to create and access Twin CAT Measurement projects. The following chapter explains how to solve some basic tasks with that kind of Twin CAT project and includes information about the following topics: • Requirements • Creating a Twin CAT Measurement project • Creating a Twin CAT Scope configuration • Creating, accessing and handling charts • Creating, accessing and handling axes • Creating, accessing and handling channels • Starting and stopping records • For more information about Twin CAT Measurement, please visit the corresponding webpage in our Information System. Automation Interface Version: 1.5 103

## Page 104

Configuration Requirements Integrating Twin CAT Measurement projects via Automation Interface is available since Twin CAT 3.1 Build 4013. As a prerequisite to use the Scope AI functionalities, a reference to the following COM interfaces is required: • Twin CAT Measurement Automation Interface (registered as COM library) • Twin CAT Scope2 Communications (. NET assembly: C: \Windows\Microsoft. NET\assembly\GAC_MSIL\Twin CAT. Scope2. Communications\v4.0_3.1.3121.0__ 180016cd49e5e8c3\) Creating a Twin CAT Measurement project Twin CAT Measurement is a global "container" which can host one or more measurement projects, e.g. a Twin CAT Scope configuration. Similar to a regular Twin CAT configuration, each project is first-of-all described by a template-file. This template file is used when adding a new project to the solution, which can be achieved by calling the Add From Template() method from the Visual Studio DTE object. Please note that this procuedure is the same when adding a regular Twin CAT project. The following code snippet assumes that you have already acquired a DTE instance and created a Visual Studio solution, as demonstrated in our article about Accessing Twin CAT configurations. A reference to the DTE instance is stored in the object "dte". Code Snippet (C#): Env DTE. Project scope Project = dte. Solution. Add From Template(template, destination, name); [template]: The default template files are stored under C:\Twin CAT\Functions\TE130X-Scope- View\Templates\Projects\ and have the file type "tcmproj". [destination]: Path where the new configuration should be stored on hard disk. [name]: Name for the new configuration, as displayed in Twin CAT XAE. Creating a Twin CAT Scope configuration A Twin CAT Scope project stands for a recording configuration. This means that all elements inserted in that project are subject to the same recording settings. You can add a Scope project via Automation Interface by specifying the corresponding "Twin CAT Scope Project" template when adding a project using the Add From Template() method, as described above. 104 Version: 1.5 Automation Interface

## Page 105

Configuration Creating, accessing and handling charts Several charts can exist in parallel in a Scope configuration. To add charts to an existing Scope project, simply use the Create Child() method from the IMeasurement Scope interface. The following code snippet assumes that a Twin CAT Measurement Project has already been created and a reference to this project is stored in the object "scope Project". Code Snippet (C#): ((IMeasurement Scope)scope Project. Project Items. Item(1). Object). Show Control(); Env DTE. Project Item new Chart; ((IMeasurement Scope)scope Project. Project Items. Item(1). Object). Create Child(out new Chart); IMeasurement Scope new Chart Obj = (IMeasurement Scope)new Chart. Object; new Chart Obj. Change Name("NC Chart"); The object "new Chart Obj" now stores a reference to the newly added chart. At this point, please keep in mind that we still need the original object "new Chart" for later purposes, e.g. to set chart properties. In Twin CAT XAE, chart properties are set via the Visual Studio properties window. The object "new Chart" gives access to these properties via its collection "Properties". The following code snippet iterates through all properties of a chart and sets the property "Stacked YAxis" to "true". Code Snippet (C#): foreach (Env DTE. Property prop in new Chart. Properties) { If (prop. Name = "Stacked YAxis") prop. Value = true; } Creating, accessing and handling axes The following code snippet demonstrates how to add axes. Code Snippet (C#): Env DTE. Project Item new Axis; new Chart Obj. Create Child(out new Axis); IMeasurement Scope new Axis Obj = (IMeasurement Scope)new Axis. Object; new Axis Obj. Change Name(“Axis 1”); Creating, accessing and handling channels A Scope channel scribes a connection to a runtime symbol, e.g. a PLC variable. To add channels via Automation Interface, you can use the Create Child() method of the IMeasurement Scope interface. Code Snippet (C#): Env DTE. Project Item new Channel; new Axis Obj. Create Child(out new Channel); IMeasurement Scope new Channel Obj = (IMeasurement Scope)new Channel. Object; new Channel Obj. Change Name("Signals. Rectangle"); The object "new Channel Obj" now stores a reference to the newly added channel. At this point, please keep in mind that we still need the original object "new Channel" for later purposes, e.g. to set channel properties. In Twin CAT XAE, channel properties are set via the Visual Studio properties window. The object "new Channel" gives access to these properties via its collection "Properties". The following code snippet iterates through all properties of a channel and sets multiple properties. Code Snippet (C#): foreach (Env DTE. Property prop in new Channel. Properties) { switch (prop. Name) { case "Target Ports": prop. Value = "851"; break; case "Symbolbased": prop. Value = true; break; Automation Interface Version: 1.5 105

## Page 106

Configuration case "Symbol Data Type": prop. Value = Twin CAT. Scope2. Communications. Scope2Data Type. BIT; break; case "Symbol Name": prop. Value = "MAIN.b Signal"; break; case "Sample State": prop. Value = 1; break; case "Line Width": prop. Value = 3; break; } } As you can see, the Scope2Data Type enum defines several data types that are supported when configuring a channel. At creation time of this document, this enum is defined as follows: Code Snippet (C#): public enum Scope2Data Type { VOID = 0, BIT = 1, INT16 = 2, INT32 = 3, INT64 = 4, INT8 = 5, REAL32 = 6, REAL64 = 7, UINT16 = 8, UINT32 = 9, UINT64 = 10, UINT8 = 11, BIT_ARRAY_8 = 12, } Please use a DLL explorer (e.g. Visual Studio) for a more recent and up-to-date list. Starting and stopping records To start/stop a configured Scope record, the corresponding methods from the IMeasurement Scope interface can be used: Code Snippet (C#): ((IMeasurement Scope)scope Project. Project Items. Item(1). Object). Start Record() ((IMeasurement Scope)scope Project. Project Items. Item(1). Object). Stop Record(); 4.3.9.2 Creating and handling Twin CAT Analytics projects The Twin CAT Automation Interface provides methods and properties to create and access Twin CAT Measurement projects. The following chapter describes how some basic tasks can be solved with a Twin CAT project and includes information on the following topics: • Requirements • Creating a Twin CAT Measurement project • Creating, accessing and handling a Twin CAT Analytics configuration • Creating, accessing and handling networks • Creating, accessing and handling functions • Starting and stopping an analysis • Further information on Twin CAT Measurement can be found on the corresponding webpage in our information system. 106 Version: 1.5 Automation Interface

## Page 107

Configuration Creating a Twin CAT Measurement project Twin CAT Measurement is a global "container" that can host one or more measurement projects, e.g. a Twin CAT Scope configuration. Similar to a regular Twin CAT configuration, each project is first described with the aid of a template file. This template file is used when adding a new project to the solution, which can be done by calling the Add From Template() method from the Visual Studio DTE object. Note that this procedure is the same when adding a regular Twin CAT project. The following code snippet assumes that you have already acquired a DTE instance and created a Visual Studio solution, as shown in our article about accessing Twin CAT configurations. A reference to the DTE instance is stored in the "dte" object. Env DTE. Project scope Project = dte. Solution. Add From Template(template, destination, name); Creating, accessing and handling a Twin CAT Analytics configuration A Twin CAT Analytics project represents an analysis configuration. This means that all elements inserted into the project are subject to the same analysis settings. You can add an analytics project via the Automation Interface by specifying the appropriate "Twin CAT Analytics Project" template when adding a project using the Add From Template() method, as described above. The Env DTE. Project element thus added can then be mapped to the IMeasurement Analytics Project interface, which provides the following methods: int Start Analytics() Starts the analysis process. int Stop Analytics(); Stops the analysis process. int Add Referenced Scope(); Adds an instance of a Twin CAT Scope project to the solution and links the analytics elements. The Twin CAT Scope instance can be adapted with the IMeasurement Scope interface via Automation Interface. int Change Name(string name); Method of changing the project name. int Show Control(); Brings the Microsoft Visual Studio© Editor to the foreground to display the Analytics project. int Close Control(); Closes the editor. int Get Available Modules(out Hashtable modules); Fills a hash table with the data from the analytics engine modules provided. The hash table might look like this: {02040109-0000-0000-f000-000000000064} "Min Max Avg 1Ch" {02040103-0000-0000-f000-000000000064} "Edge Counter On Off 2Ch" {02040102-0000-0000-f000-000000000064} "Edge Counter On Off 1Ch" {02040101-0000-0000-f000-000000000064} "Edge Counter 1Ch" The GUIDs are necessary for later generation of the analysis functions. int Add Network(out Project Item item, string name = Adds a network to the Analytics project and issues ""); the instance of the Env DTE. Project Item with which you can continue. The object Env DTE. Project Item. Object can be mapped to the IMeasurement Analytics Network interface. Creating, accessing and handling networks A Twin CAT Analytics network represents the level at which function blocks are created, managed and visualized. Automation Interface Version: 1.5 107

## Page 108

Configuration A network can contain multiple instances of different functions, as well as other networks as so-called sub- networks. Each network is represented within a Microsoft Visual Studio© Editor instance, so that the internal docking mechanisms can be used to simultaneously represent different networks. The IMeasurement Analytics Network interface defines the following methods: int Show Control(); Brings the Microsoft Visual Studio© Editor to the foreground to display the Analytics network. int Close Control(); Closes the editor. int Add Function(out Project Item item, Guid guid, Adds an analysis function to the network. string name = ""); The function is determined by the corresponding GUID, which can be selected via the interface method IMeasurement Analytics Project. Get Available Modules( out Hashtable modules). The instance of Env DTE. Project Item. Object can be mapped to the IMeasurement Analytics Function interface. int Add Network(out Project Item item, string name = The object Env DTE. Project Item. Object can be ""); mapped to the IMeasurement Analytics Network interface. int Change Name(string name); Changes the name of the network. int Add Network Template(out Project Item item, string Adds a network from a template. The template must path); be specified at file level. The object Env DTE. Project Item. Object can be mapped to the IMeasurement Analytics Network interface. Creating, accessing and handling functions A Twin CAT Analytics Function represents the level of the analysis function. Each function has its own input and output variables as well as various configuration parameters. The IMeasurement Analytics Function interface defines the following methods: int Show Control(); Brings the Microsoft Visual Studio© Editor to the foreground to display the Analytics project. int Close Control(); Closes the editor. int Change Name(string name); Changes the name of the function. int Set Input Variable(string input, int input Index); Sets the input variable to the specified index of the function on the input string. The input string must be in XML format as an example from the Target Browser. Target Browser Export Info To obtain the XML-formatted string, you can simply drag and drop the desired variable from the target browser into a text editor. Please note that the text editor must be started as an administrator if the target browser host (e.g. Visual Studio) has also been started as an administrator. No interface is required to adjust the parameters of the function. To do this, you can simply search the Env DTE-Properties list of the Env DTE. Project Item. Properties object for the Env DTE. Property and set its value. 108 Version: 1.5 Automation Interface

## Page 109

Configuration 4.3.9.3 Creating and handling Analytics Logger and Stream Helper The Twin CAT Automation Interface provides methods and properties to create and access Twin CAT Analytics Logger and Stream Helper. All functions are described below with C# code samples. • Creating and deleting a Data Logger • Creating and deleting a stream helper • Parameterizing an already created Data Logger • Parameterizing streams • Selecting symbols to be logged. All these operations are related to the respective nodes of the Analytics Configuration, Analytics Data Logger, Streams and Stream Helpers in a Twin CAT XAE project. 4.3.9.3.1 Creating and deleting a Data Logger Env DTE. Solution solution = dte. Solution; Env DTE. Project xae Project = null; // Get xae Project … ITc Sys Manager sys Manager = (ITc Sys Manager)xae Project. Object; // Navigate to the Analytics Configuration Node ITc Sm Tree Item analytics Config = sys Manager. Lookup Tree Item("TIAN"); analytics Config. Create Child("My Data Logger Name", 1, null, null); analytics Config. Delete Child("My Data Logger Name"); 4.3.9.3.2 Creating and deleting a Stream Helper Env DTE. Solution solution = dte. Solution; Env DTE. Project xae Project = null; // Get xae Project … ITc Sys Manager sys Manager = (ITc Sys Manager)xae Project. Object; // Navigate to the Analytics Configuration Node ITc Sm Tree Item analytics Config = sys Manager. Lookup Tree Item("TIAN"); analytics Config. Create Child("My Stream Helper Name", 0, null, null); analytics Config. Delete Child("My Stream Helper Name_Obj1 (Stream Helper)"); When deleting, note the addition "_Obj1 (Stream Helper)" appended to the name passed in Create Child. 4.3.9.3.3 Parameterizing an already created Data Logger Env DTE. Solution solution = dte. Solution; Env DTE. Project xae Project = null; // Get xae Project … ITc Sys Manager sys Manager = (ITc Sys Manager)xae Project. Object; // Navigate to the Analytics Data Logger Node ITc Sm Tree Item data Logger = sys Manager. Lookup Tree Item("TIAN^My Data Logger Name"); string s Xml Doc = data Logger. Produce Xml(); Xml Document xml Doc = new Xml Document(); xml Doc. Load Xml(s Xml Doc); Xml Element elem Set Param = xml Doc. Create Element("Set Parameter"); Automation Interface Version: 1.5 109

## Page 110

Configuration Xml Attribute attr Param Name = xml Doc. Create Attribute("name"); attr Param Name. Value = "Data Format"; Xml Attribute attr Param Value = xml Doc. Create Attribute("value"); attr Param Value. Value = "ANALYTICS_FORMAT_FILE"; elem Set Param. Attributes. Append(attr Param Name); elem Set Param. Attributes. Append(attr Param Value); xml Doc. Document Element. Append Child(elem Set Param); string s Consume Xml = xml Doc. Outer Xml; data Logger. Consume Xml(s Consume Xml); The code snippet shows the use of the Produce-Consume-XML mechanism, where the XML text describing the project node can be read, modified and written again, which can be followed by actions on the part of the System Manager. The imported XML text contains, among other things, a listing of the parameters with name and current value. The name corresponds exactly to the name of the parameter under the Parameter (Init) tab of the Data Logger project node. This also applies to the respective values. 4.3.9.3.4 Parameterizing a stream Env DTE. Solution solution = dte. Solution; Env DTE. Project xae Project = null; // Get xae Project … ITc Sys Manager sys Manager = (ITc Sys Manager)xae Project. Object; // Navigate to the Analytics Data Logger Node ITc Sm Tree Item stream = sys Manager. Lookup Tree Item("TIAN^My Data Logger Name^Plc Stream1"); string s Xml Doc = stream. Produce Xml(); Xml Document xml Doc = new Xml Document(); xml Doc. Load Xml(s Xml Doc); Xml Element elem Set Param = xml Doc. Create Element("Set Parameter"); Xml Attribute attr Param Name = xml Doc. Create Attribute("name"); attr Param Name. Value = "Max ADS Buffer"; Xml Attribute attr Param Value = xml Doc. Create Attribute("value"); attr Param Value. Value = "23"; elem Set Param. Attributes. Append(attr Param Name); elem Set Param. Attributes. Append(attr Param Value); xml Doc. Document Element. Append Child(elem Set Param); string s Consume Xml = xml Doc. Outer Xml; data Logger. Consume Xml(s Consume Xml); The code snippet shows the use of the Produce-Consume-XML mechanism, where the XML text describing the project node can be read, modified and written again, which can be followed by actions on the part of the System Manager. The imported XML text contains, among other things, a listing of the parameters with name and current value. The name corresponds exactly to the name of the parameter under the Data Handling tab of the stream project node. This also applies to the respective values. 4.3.9.3.5 Selecting symbols Env DTE. Solution solution = dte. Solution; Env DTE. Project xae Project = null; // Get xae Project … ITc Sys Manager sys Manager = (ITc Sys Manager)xae Project. Object; // Navigate to the Analytics Data Logger Node ITc Sm Tree Item stream = sys Manager. Lookup Tree Item("TIAN^My Data Logger Name^Plc Stream1"); string s Xml Doc = stream. Produce Xml(); Xml Document xml Doc = new Xml Document(); xml Doc. Load Xml(s Xml Doc); 110 Version: 1.5 Automation Interface

## Page 111

Configuration Xml Element elem Set Symbol = xml Doc. Create Element("Set Symbol"); Xml Attribute attr Symbol Name = xml Doc. Create Attribute("name"); attr Symbol Name. Value = "MAIN.st Test Struct Simple.n Member1"; Xml Attribute attr Enable = xml Doc. Create Attribute("value"); attr Enable. Value = "true"; elem Set Symbol. Attributes. Append(attr Symbol Name); elem Set Symbol. Attributes. Append(attr Enable); xml Doc. Document Element. Append Child(elem Set Symbol); string s Consume Xml = xml Doc. Outer Xml; stream. Consume Xml(s Consume Xml); 4.3.10 Motion 4.3.10.1 Creating and handling Motion projects This chapter explains in-depth how to create and handle Motion projects. The following list shows all chapters in this article: • General information about Twin CAT 3 Motion • Creating a NC-Task • Creating axes • Parameterize axes General information about Twin CAT Motion Twin CAT 3 Motion consists of the following three components: NC-I, NC-PTP and CNC. It is therefore an assembly of function groups used for the control and regulation of axes or of synchronised axis groups. For more information about Twin CAT Motion please see the Twin CAT 3 Motion documentation. Creating a NC-Task The first step to create a Twin CAT 3 Motion project is to create a so-called NC-Task. In Twin CAT Automation Interface, you can create this task simply by calling the method ITc Sm Tree Item [} 124]::Create Child() [} 160] and using the Sub Type parameter 1, as the following code snippet shows. Code Snippet (C#): ITc Sm Tree Item nc Config = system Manager. Lookup Tree Item("TINC"); nc Config. Create Child("NC-Task", 1); Code Snippet (Powershell): $nc Config = $system Manager. Lookup Tree Item("TINC") $nc Config. Create Child("NC-Task", 1) Automation Interface Version: 1.5 111

## Page 112

Configuration Creating axes As the NC-Task does not contain any axes by default. you need to add them, again by using the Create Child() method - this time on a reference to the Axes node below the NC-Task. Code Snippet (C#): ITc Sm Tree Item axes = system Manager. Lookup Tree Item("TINC^NC-Task^Axes"); axes. Create Child("Axis 1", 1); Code Snippet (Powershell): $axes = $system Manager. Lookup Tree Item("TINC^NC-Task^Axes") $axes. Create Child("Axis 1", 1) Parameterize axes Axes can be parameterized via their XML description [} 25]. To get a sample XML description, you could add an axis manually in Twin CAT XAE and use the corresponding entry from the context menu or add the axis via Automation Interface and use the ITc Sm Tree Item [} 124]::Produce Xml() [} 158] method to get it. Code Snippet (C#): ITc Sm Tree Item axis = system Manager. Lookup Tree Item("TINC^NC-Task^Axes^Axis 1"); string xml Description = axis. Produce Xml(); Code Snippet (Powershell): $axis = $system Manager. Lookup Tree Item("TINC^NC-Task^Axes^Axis 1") $xml Description = $axis. Produce Xml() 112 Version: 1.5 Automation Interface

## Page 113

Configuration You can modify this XML description to your needs and then import it again via the method ITc Sm Tree Item [} 124]::Consume Xml() [} 159] to parameterize your axis. Code Snippet (C#): ITc Sm Tree Item axis = system Manager. Lookup Tree Item("TINC^NC-Task^Axes^Axis 1"); axis. Consume Xml(xml Description); Code Snippet (Powershell): $axis = $system Manager. Lookup Tree Item("TINC^NC-Task^Axes^Axis 1") $axis. Consume Xml($xml Description) 4.3.11 Safety 4.3.11.1 Creating and handling Safety projects This chapter explains in-depth how to create, access and handle Safety projects. The following list shows all chapters in this article: • General information about Safety projects • Opening existing Safety projects General information about Safety projects • The Twin CAT Automation Interface allows to import existing Twin CAT Safety projects into a Twin CAT configuration. For this purpose, users can either use the corresponding *.splcproj file or the container format *.tfzip as a source template. Opening existing Safety projects To open an existing Safety project via Automation Interface, you need to navigate to the Safety node and then execute the Create Child() method with the path to the corresponding, existing Safety project file file as a parameter. You can use three different values as Sub Type: • 0: Copy project to solution directory • 1: Move project to solution directory • 2: Use original project location (when used, please use "" as project name parameter) Basically, these values represent the functionalities (Yes, No, Cancel) from the following Message Box in Twin CAT XAE: You can either use the path to the Safety project (to its *.splcproj file) that needs to be added or you can also use a Safety project archive (*.tfzip). Code Snippet (C#): Automation Interface Version: 1.5 113

## Page 114

Configuration ITc Sm Tree Item safety = system Manager. Lookup Tree Item("TISC"); ITc Sm Tree Item new Project = safety. Create Child("Name Of Project", 0, null, path To Project Or Tfzip File); Code Snippet (Powershell): $safety = $system Manager. Lookup Tree Item("TISC") $new Project = $safety. Create Child("Name Of Project", 0, "", path To Project Or Tfzip File) 114 Version: 1.5 Automation Interface

## Page 115

API 5 API 5.1 Reference This chapter contains a documentation of all classes and methods of the Twin CAT Automation Interface. The provided interfaces can be divided into different "levels" in which the higher level interfaces represent the primary interfaces and therefore the basic interaction with the Automation Interface. Please note that this differentiation comes only from a logical point-of-view, to get a better understanding about which interfaces are most important and which interfaces are of secondary importance. Level 1 interfaces As mentioned in our introduction [} 10], there are only two main interfaces which are being used for navigating and referencing tree items in Twin CAT configuration. Main class Description Available since ITc Sys Manager [} 116] Base class to create and Twin CAT 2.11 parameterize a Twin CAT configuration ITc Sm Tree Item [} 124] Represents a tree item within a Twin CAT 2.11 Twin CAT configuration Level 2 interfaces These interfaces are considered as "helper classes" which are always used together with level 1 classes, for example to cast an ITc Sm Tree Item object into a more specific type of tree item, for example a POU (ITc Plc Pou) or a linked task (ITc Task Reference). Automation Interface Version: 1.5 115

## Page 116

API Helper class Description Available since ITc Plc Library Manager [} 171] Defines methods and properties for Twin CAT 3.1 PLC library management ITc Plc Pou [} 165] Defines methods and properties to Twin CAT 3.1 handle PLC POUs ITc Plc Declaration [} 166] Defines methods to read/write the Twin CAT 3.1 declaration area of a PLC POU ITc Plc Implementation [} 167] Defines methods to read/write the Twin CAT 3.1 implementation area of a PLC POU ITc Plc Project [} 164] Defines methods and properties Twin CAT 3.1 regarding a PLC project, e.g. setting the project as a boot project ITc Plc IECProject [} 168] Defines methods needed to import/ Twin CAT 3.1 export PLC projects in PLCopen XML and also install them as a PLC library ITc Plc Task Reference [} 181] Defines methods and properties to Twin CAT 3.1 link the PLC project to a task ITc Plc Library [} 177] Helper class which represents a Twin CAT 3.1 single PLC library ITc Plc Libraries [} 178] Helper class which represents a Twin CAT 3.1 collection of PLC libraries ITCPlc References [} 177] Helper class which represents a Twin CAT 3.1 collection of ITc Plc Lib Ref objects (and therefore references in a PLC project) ITc Plc Lib Ref [} 178] Helper class which represents a Twin CAT 3.1 base class for ITc Plc Library and ITc Plc Placeholder Ref objects ITc Plc Placeholder Ref [} 179] Helper class which represents a Twin CAT 3.1 single PLC placeholder ITc Plc Lib Repository [} 179] Helper class which represents a Twin CAT 3.1 single PLC library repository ITc Plc Lib Repositories [} 180] Helper class which represents a Twin CAT 3.1 collection of PLC library repositories 5.2 ITc Sys Manager 5.2.1 ITc Sys Manager ITc Sys Manager is the main interface of the Twin CAT Automation Interface. This interface allows basic operations to configure Twin CAT 3 XAE and consists of several methods for doing so. Over the years, the ITc Sys Manager interface has been extended with more functionalities to give customers a better way to access all Automation Interface features. However, due to restrictions in the COM object model, these features needed to be added as separate interfaces to the Automation Interface. Therefore, each time a new set of features was added, these features were assembled in a new interface which was named ITc Sys Manager X, where X is a number which is incremented each time a new interface was added. The following tables explain which methods are part of the ITc Sys Manager interface and which have been added to each new "feature-set" interface. 116 Version: 1.5 Automation Interface

## Page 117

API Methods ITc Sys Manager methods Description Available since New Configuration [} 118] Generates a new configuration Twin CAT 2.11 Open Configuration [} 118] Loads a prior created configuration Twin CAT 2.11 file (WSM file) Save Configuration [} 119] Saves the configuration in a file Twin CAT 2.11 with the given name or with the current name Activate Configuration [} 119] Activates the configuration (same Twin CAT 2.11 as "Save To Registry") Lookup Tree Item [} 122] Looks up to a configuration item Twin CAT 2.11 (item in the tree) by name and returns a ITc Sm Tree Item [} 124] interface Start Restart Twin CAT [} 119] Starts or Restarts the Twin CAT Twin CAT 2.11 System Is Twin CATStarted [} 119] Evaluates if the Twin CAT System Twin CAT 2.11 is running Link Variables [} 120] Links two variables given by names Twin CAT 2.11 Unlink Variables [} 120] Clears the link between two Twin CAT 2.11 variables given by names or all links from one variable. ITc Sys Manager2 methods Description Available since Set Target Net Id [} 121] Set the target Net Id of the currently Twin CAT 2.11 opened Twin CAT configuration. Get Target Net Id [} 121] Gets the target Net Id of the Twin CAT 2.11 currently opened Twin CAT configuration. Get Last Error Messages [} 121] Get the last error messages which Twin CAT 2.11 occurred in the Twin CAT subsystem. ITc Sys Manager3 methods Description Available since Lookup Tree Item By Id [} 123] Looks for a configuration tree item Twin CAT 2.11 with the specifed Item id. Produce Mapping Info [} 123] Produces a Xml-Description of the Twin CAT 3.1 actual configuration mappings. Clear Mapping Info Clears the mapping info. Twin CAT 2.11 Comments The ITc Sys Manager interface contains two methods used for navigating within Twin CAT XAE: ITc Sys Manager::Lookup Tree Item [} 122] and ITc Sys Manager3::Lookup Tree Item By Id [} 123]. A detailed explanation of browsing Twin CAT XAE can be found in the chapter Tree Item Browsing Models [} 23]. Warning: The three methods ITc Sys Manager::New Configuration [} 118], ITc Sys Manager::Open Configuration [} 118] and ITcs Sys Manager::Save Configuration [} 119] are only available in Compatiblity Mode [} 20]. Calling them in standard mode will throw an E_NOTSUPPORTED Exception. The ITc Sysmanager and the ITc Sm Tree Item [} 124] interface allows full access to a Twin CAT configuration. In the How to... section of this documentation there is a long (but incomplete) list of samples how to manipulate a Twin CAT configuration automatically. Automation Interface Version: 1.5 117

## Page 118

API Version information Requirements Required Twin CAT version This interface is supported in Twin CAT 2.11 and above 5.2.2 ITc Sys Manager::New Configuration The New Configuration() method generates a new Twin CAT configuration file. HRESULT New Configuration(); Return Values S_OK Function has returned a value. E_ACCESSDENIED The actual document is locked in the System Manager-Instance. This is if at least one reference to the system manager-object or one of the Tree Items is opened. E_FAIL Function failed. Comments Warning: The three methods ITc Sys Manager::New Configuration [} 118], ITc Sys Manager::Open Configuration [} 118] and ITcs Sys Manager::Save Configuration [} 119] are only available in Compatiblity Mode [} 20]. Calling them in standard mode will throw an E_NOTSUPPORTED Exception. 5.2.3 ITc Sys Manager::Open Configuration The Open Configuration() method loads a previously created Twin CAT configuration file. HRESULT Open Configuration(BSTRbstr File); Parameters bstr File [in, defaultvalue(L"")] contains the file path of the configuration file that should be loaded or an empty string if a new configuration should generated. The currently running configuration of a target device may also be read by using "CURRENTCONFIG". Return Values S_OK Function has returned a value. E_ACCESSDENIED The actual document is locked in the system manager-instance. This is if at least one reference tot he system manager-object or one of the Tree Items is opened. E_INVALIDARG The path doesn’t point to a valid configfile. Comments Warning: The three methods ITc Sys Manager::New Configuration [} 118], ITc Sys Manager::Open Configuration [} 118] and ITcs Sys Manager::Save Configuration [} 119] are only available in Compatiblity Mode [} 20]. Calling them in standard mode will throw an E_NOTSUPPORTED Exception. 118 Version: 1.5 Automation Interface

## Page 119

API 5.2.4 ITc Sys Manager::Save Configuration The Save Configuration() method saves a Twin CAT configuration in a file with the specified name. HRESULT Save Configuration(BSTRbstr File); Parameters bstr File [in, defaultvalue(L"")] contains the path, where the config file should be saved. When bstr File is an empty character string, the actual file name is used. Return Values S_OK Function has returned a value. E_INVALIDARG The file path is invalid. Comments Warning: The three methods ITc Sys Manager::New Configuration [} 118], ITc Sys Manager::Open Configuration [} 118] and ITcs Sys Manager::Save Configuration [} 119] are only available in Compatiblity Mode [} 20]. Calling them in standard mode will throw an E_NOTSUPPORTED Exception. 5.2.5 ITc Sys Manager::Activate Configuration The Activate Configuration() method activates the Twin CAT configuration (same as "Save To Registry"). A following start or restart of the Twin CAT system must be performed to activate the configuration physically. HRESULT Activate Configuration(); Return Values S_OK Function has returned a value. E_FAIL The function failed. 5.2.6 ITc Sys Manager::Is Twin CATStarted The Is Twin CATStarted() method evaluates if the Twin CAT System is running. HRESULT Is Twin CATStarted(VARIANT_BOOL*p Started); Parameters p Started [out, retval] points to the storage location of the boolean value, which contains the result. Return Values S_OK Function returned a value. 5.2.7 ITc Sys Manager::Start Restart Twin CAT The Start Restart Twin CAT() method starts or restarts the Twin CAT System. If Twin CAT is already started, the function performs a restart, if Twin CAT is stopped it performs a start. HRESULT Start Restart Twin CAT(); Automation Interface Version: 1.5 119

## Page 120

API Return Values Requirements S_OK Function has returned a value. E_FAIL Twin CAT couldn’t be started. 5.2.8 ITc Sys Manager::Link Variables The Link Variables() method links two variables, which are specified by their names. The two variables represented by their tree path name will be linked. The path names must have the same syntax as described in ITc Sys Manager::Lookup Tree Item [} 122]. The same shortcuts can be used. HRESULT Link Variables(BSTRbstr V1, BSTRbstr V2, longoffs1, longoffs2, longsize); Parameters bstr V1 [in] path name of the first variable. The full path name is required and each branch must be separated by a circumflex accent '^' or a tab. bstr V2 [in] path name of the second variable. The full path name is required and each branch must be separated by a circumflex accent '^' or a tab. offs1 [in, defaultvalue(0)] bit offset of the first variable (used if the two variables have different sizes or not the whole variable should be linked). offs2 [in, defaultvalue(0)] bit offset of the second variable. size [in, defaultvalue(0)] bit count how many bits should linked. If size is 0 the minimum of the variable size of variable one and two is used. Return Values S_OK function returns successfully. TSM_E_ITEMNOTFOUND (0x98510001) one or both of the path name(s) does not qualify an existing tree item. TSM_E_INVALIDITEMTYPE (0x98510002) one or both of the tree item(s) is not a variable. TSM_E_MISMATCHINGITEMS (0x98510004) the two variables cannot linked together. May be you have tried to link an output of one task with an output of another task or an output of a task with an input of a device or to variables of the same owner. E_INVALIDARG the values of offs1, offs2 and/or size does not fit to the variables. 5.2.9 ITc Sys Manager::Unlink Variables The Unlink Variables() method unlinks two variables, which are specified by their names, or clears all links from the first variable if the name bstr V2 of the second variable is empty. The two variables represented by their tree path name will be unlinked. The path names must have the same syntax as described in ITc Sys Manager::Lookup Tree Item [} 122]. The same shortcuts can be used. HRESULT Unlink Variables(BSTRbstr V1, BSTRbstr V2); 120 Version: 1.5 Automation Interface

## Page 121

API Parameters bstr V1 [in] path name of the first variable. The full path name is required and each branch must be separated by a circumflex accent '^' or a tab. bstr V2 [in, defaultvalue(L"")] path name of the second variable. If set the full path name is required and each branch must be separated by a circumflex accent '^' or a tab. Return Values S_OK function returns successfully. S_FALSE the two variables have no link between them. TSM_E_ITEMNOTFOUND (0x98510001) one or both of the path name(s) does not qualify an existing tree item. TSM_E_INVALIDITEMTYPE (0x98510002) one or both of the tree item(s) is not a variable. TSM_E_CORRUPTEDLINK (0x98510005) the two variables cannot unlinked. Comments If bstr V2 is an empty string the function clears all links of variable given by bstr V1. If bstr V2 is not empty only an existing link between both variables will be deleted. 5.2.10 ITc Sys Manager2::Get Target Net Id The Get Target Net Id() method returns the Net Id of the current Twin CAT system. HRESULT Get Target Net Id(); Parameters None Return Values STRING returns target's Net Id 5.2.11 ITc Sys Manager2::Set Target Net Id The Set Target Net Id() method sets the Net Id of the current Twin CAT system. HRESULT Set Target Net Id(STRING net Id); Parameters net Id represents the target's Net Id. Return Values S_OK function returns successfully. 5.2.12 ITc Sys Manager2::Get Last Error Messages The Get Last Error Messages() metod returns the last error messages. HRESULT Get Last Error Messages(); Automation Interface Version: 1.5 121

## Page 122

API Parameters None Return Values STRING Returns last error messages. 5.2.13 ITc Sys Manager::Lookup Tree Item The Lookup Tree Item() method returns a ITc Tree Item pointer of a tree item given by it's full path name. HRESULT Lookup Tree Item(BSTRbstr Item, ITc Sm Tree Item**pip Item); Parameters bstr Item [in] path name of the tree item looking for. The full path name is required and each branch must be separated by a circumflex accent '^' or a tab. A list of shortcuts for the main tree items is listed below. pip Item [out, retval] points to the location of a ITc Sm Tree Item [} 124] interface pointer on return. The interface pointer gives access to specific methods belonging to the tree item. Return Values S_OK function returns successfully. TSM_E_ITEMNOTFOUND (0x98510001) the path name does not qualify an existing tree item. Shortcuts The main tree items that exists in every configuration file can be accessed via shortcuts. These shortcuts are language neutral and require less memory: "TIIC": shortcut for "I/O Configuration" “TIID": shortcut for "I/O Configuration^I/O Devices" or "I/O Configuration" TAB "I/O Devices" “TIRC": shortcut for "Real-Time Configuration" “TIRR": shortcut for "Real-Time Configuration^Route Settings" “TIRT": shortcut for " Real-Time Configuration^Additional Tasks" or " Real-Time Configuration" TAB "Additional Tasks" “TIRS": shortcut for " Real-Time Configuration^Real-Time Settings" or " Real-Time Configuration" TAB "Real-Time Settings" “TIPC": shortcut for "PLC Configuration" “TINC": shortcut for "NC Configuration" “TICC": shortcut for "CNC Configuration" “TIAC": shortcut for "CAM Configuration" Sample (C++): ITc Sm Tree Item* ip Item; BSTR bstr Item = L"TIID^Device 1 (C1220)"; if ( SUCCEEDED(sp Tsm->Lookup Tree Item( bstr Item, &ip Item )) ) { // do anything with ip Item ip Item->Release(); } 122 Version: 1.5 Automation Interface

## Page 123

API Sample (VB):Dim ip Item As ITc Sm Tree Item set ip Item = sp Tsm. Lookup Tree Item("TIID^Device 1 (C1220)") ' do anything with ip Item Comments 5.2.14 ITc Sys Manager3::Lookup Tree Item By Id The Lookup Tree Item By Id() method returns a ITc Tree Item pointer of a tree item given by it's full path name. HRESULT Lookup Tree Item By Id(longitem Type, longitem Id, ITc Sm Tree Item**pip Item); Parameters item Type [in] Item type of the Tree Item to find. item Id [in] ID of the Tree Item pip Item [out, retval] points to the location of a ITc Sm Tree Item [} 124] interface pointer on return. The interface pointer gives access to specific methods belonging to the tree item. Return Values S_OK function returns successfully. TSM_E_ITEMNOTFOUND (0x98510001) the item Type item Id combination doesn't qualify a valid tree item. 5.2.15 ITc Sys Manager3::Produce Mapping Info Generates an XML output that includes all currently configured mappings, e.g. between PLC and I/O. HRESULT Produce Mapping Info(); Parameters none Return Values STRING: Returns XML structure that includes all configured mappings. The following snippet shows an example for this structure: <Var Links> <Owner A Name="TIID^Device 1 (Ether CAT)"> <Owner B Name="TIXC^Untitled2^Untitled2_Obj1 (CModule1)"> <Link Var A="Term 1 (EK1100)^Term 3 (EL1008)^Channel 5^Input" Var B="Inputs^Value" /> <Link Var A="Term 1 (EK1100)^Term 2 (EL2008)^Channel 4^Output" Var B="Outputs^Value" /> </Owner B> </Owner A> <Owner A Name="TIPC^Untitled1^Untitled1 Instance"> <Owner B Name="TIID^Device 1 (Ether CAT)^Term 1 (EK1100)^Term 2 (EL2008)"> <Link Var A="Plc Task Outputs^MAIN.b Output1" Var B="Channel 1^Output" /> <Link Var A="Plc Task Outputs^MAIN.b Output3" Var B="Channel 3^Output" /> <Link Var A="Plc Task Outputs^MAIN.b Output2" Var B="Channel 2^Output" /> </Owner B> <Owner B Name="TIID^Device 1 (Ether CAT)^Term 1 (EK1100)^Term 3 (EL1008)"> <Link Var A="Plc Task Inputs^MAIN.b Input1" Var B="Channel 1^Input" /> <Link Var A="Plc Task Inputs^MAIN.b Input3" Var B="Channel 3^Input" /> <Link Var A="Plc Task Inputs^MAIN.b Input2" Var B="Channel 2^Input" /> <Link Var A="Plc Task Inputs^MAIN.b Input4" Var B="Channel 4^Input" /> </Owner B> </Owner A> </Var Links> Automation Interface Version: 1.5 123

## Page 124

API This example shows mappings between PLC <--> I/O and Tc COM (C++) <--> I/O. 5.2.16 ITc Sys Manager3::Consume Mapping Info Consumes an XML structure that includes the mapping information for a project. HRESULT Consume Mapping Info(BSTR bstr Xml); Parameters bstr Xml [in]: String with XML structure. The XML mapping information can be acquired by using ITc Sys Manager3::Produce Mapping Info() [} 123]. 5.3 ITc Sm Tree Item 5.3.1 ITc Sm Tree Item Each tree item in a Twin CAT XAE configuration is represented by an instance of the ITc Sm Tree Item interface, which enables various interactions with the tree item. A tree item of this interface will be, for example, returned by calling the ITCat Sys Manager::Lookup Tree Item method, which is used to navigate through the tree. 124 Version: 1.5 Automation Interface

## Page 125

API Properties ITc Sm Tree Item Type Access Description Property Name BSTR RW Name of tree item Comment BSTR RW Comment. Disabled BOOL RW Get/Set state of tree item which can be one of the following enum values: • SMDS_NOT_DISABLED (item is enabled) • SMDS_DISABLED (item is disabled) • SMDS_PARENT_DISABLED (read only, set if one of its parent is disabled) Path Name BSTR R Path of tree item in Twin CAT XAE. The branches are separated by '^'. The Path Name may be used in other method calls, e.g. ITCat Sys Manager::Lookup Tree Item [} 122]. Please note that this property uniquely identifies a tree item in Twin CAT XAE. Item Type ENUM R Categorization of a tree item, e.g. Devices, Boxes, PLC, ... . As defined by item types [} 126]. Item Sub Type LONG RW Sub type [} 130] of a tree item. Parent ITc Sm Tre R Pointer to the parent tree item. e Item* Child Count LONG R Number of childs. Childs counted by this property enclose only main childs of the tree item (e.g. boxes are main childs of a device but not the device process image). To access all childs use the _New Enum property. Child(LONG n) ITc Sm Tre R ITc Sm Tree Item pointer of the n-th child e Item* Var Count((LONG x) LONG R Number of variables belonging to the tree item. x = 0 counted the input variables, x = 1 the outputs Var(LONG x, LONG ITc Sm Tre R ITc Sm Tree Item pointer of the n-th variable. x = 0 uses the input n) e Item* variables, x = 1 the outputs _New Enum IUnknown* R Returns a enum interface that enumerates all child tree items (IEnum Var of the current tree item. This property may be used, for iant*) example, by a For-Each statement. Automation Interface Version: 1.5 125

## Page 126

API Methods ITc Sm Tree Item Methods Description Available since Create Child [} 160] Creates a child tree item. Twin CAT 2.11 Delete Child [} 162] Deletes a child tree item. Twin CAT 2.11 Import Child [} 163] Imports a child item from the Twin CAT 2.11 clipboard or a previously exported file. Export Child [} 163] Exports a child item to the Twin CAT 2.11 clipboard or a file. Produce Xml [} 158] Returns a String containing the Twin CAT 2.11 XML representation of the item, with all its item-specific data and parameters. Consume Xml [} 159] Consumes a String containing the Twin CAT 2.11 XML representation of the tree item, with all its item-specific data and parameters. Get Last Xml Error [} 164] Gets the error message of the last Twin CAT 2.11 erroneous Consume Xml() call. Lookup Child [} 163] Searches for a child with the Twin CAT 2.11 specified relative path. ITc Sm Tree Item2 Methods Description Available since Resouces Count For interal use only Twin CAT 2.11 Change Child Sub Type Changes the Sub Type of the Twin CAT 2.11 ITc Sm Tree Item. Claim Resources For internal use only Twin CAT 2.11 Version information Requirements Required Twin CAT version This interface is supported in Twin CAT 2.11 and above 5.3.2 ITc Sm Tree Item Item Types Every tree item in Twin CAT System Manager / Twin CAT XAE is being categorized into various groups , e.g. devices, boxes, task, ... . You can check the item type of a tree item by manually adding it to Twin CAT System Manager or XAE and then exporting its XML description via the corresponding menu entry. • Twin CAT System Manager: Actions --> Export XML description • Twin CAT XAE: Twin CAT --> Selected item --> Export XML description In the resulting XML file, the item type is represented by the node <Item Type>. 126 Version: 1.5 Automation Interface

## Page 127

API General item types Item type Tag Description 0 TREEITEMTYPE_UNKNOWN --- 1 TREEITEMTYPE_TASK --- 9 TREEITEMTYPE_IECPRJ --- 10 TREEITEMTYPE_CNCPRJ --- 11 TREEITEMTYPE_GSDMOD Module of a Profibus GSD device 12 TREEITEMTYPE_CDL --- 13 TREEITEMTYPE_IECLZS --- 14 TREEITEMTYPE_LZSGRP --- 15 TREEITEMTYPE_IODEF --- 16 TREEITEMTYPE_ADDTASKS --- 17 TREEITEMTYPE_DEVICEGRP --- 18 TREEITEMTYPE_MAPGRP --- 30 TREEITEMTYPE_CANPDO --- 31 TREEITEMTYPE_RTIMESET --- 32 TREEITEMTYPE_BCPLC_VARS --- 33 TREEITEMTYPE_FILENAME --- 34 TREEITEMTYPE_DNETCONNEC --- T 37 TREEITEMTYPE_FLBCMD --- 43 TREEITEMTYPE_EIPCONNECTI --- ON 44 TREEITEMTYPE_PNIOAPI --- 45 TREEITEMTYPE_PNIOMOD --- 46 TREEITEMTYPE_PNIOSUBMOD --- 47 TREEITEMTYPE_ETHERNETPR --- OTOCOL 200 TREEITEMTYPE_CAMDEF --- 201 TREEITEMTYPE_CAMGROUP --- 202 TREEITEMTYPE_CAM --- 203 TREEITEMTYPE_CAMENCODER --- 204 TREEITEMTYPE_CAMTOOLGRP --- 205 TREEITEMTYPE_CAMTOOL --- 300 TREEITEMTYPE_LINEDEF --- 400 TREEITEMTYPE_ISGDEF --- 401 TREEITEMTYPE_ISGCHANNEL --- 402 TREEITEMTYPE_ISGAGROUP --- 403 TREEITEMTYPE_ISGAXIS --- 500 TREEITEMTYPE_RTSCONFIG --- 501 TREEITEMTYPE_RTSAPP --- 502 TREEITEMTYPE_RTSAPPTASK --- 503 TREEITEMTYPE_RTSADI --- 504 TREEITEMTYPE_CPPCONFIG --- 505 TREEITEMTYPE_SPLCCONFIG --- Automation Interface Version: 1.5 127

## Page 128

API I/O item types Item type Tag Description 2 TREEITEMTYPE_DEVICE I/O Device 3 TREEITEMTYPE_IMAGE Process Image 4 TREEITEMTYPE_MAPPING --- 5 TREEITEMTYPE_BOX I/O Box (e.g. "BK2000", child of I/O Devices) 6 TREEITEMTYPE_TERM I/O Terminal (child of terminal couplers (box)) 7 TREEITEMTYPE_VAR Variable 8 TREEITEMTYPE_VARGRP Variable Group (e.g. "Inputs") 35 TREEITEMTYPE_NVPUBLISHER --- VAR 36 TREEITEMTYPE_NVSUBSCRIBE --- RVAR 128 Version: 1.5 Automation Interface

## Page 129

API PLC item types Item type Tag Description 600 TREEITEMTYPE_PLCAPP PLC application (root PLC object) 1 601 TREEITEMTYPE_PLCFOLDER PLC folder 1 602 TREEITEMTYPE_PLCPOUPROG POU Program 1 603 TREEITEMTYPE_PLCPOUFUNC POU Function 1 604 TREEITEMTYPE_PLCPOUFB POU Function Block 1 605 TREEITEMTYPE_PLCDUTENUM DUT enum data type 1 606 TREEITEMTYPE_PLCDUTSTRUC DUT struct data type 1 T 607 TREEITEMTYPE_PLCDUTUNION DUT union data type 1 608 TREEITEMTYPE_PLCACTION PLC action 1 609 TREEITEMTYPE_PLCMETHOD PLC method 1 610 TREEITEMTYPE_PLCITFMETH PLC interface method 1 611 TREEITEMTYPE_PLCPROP PLC property 1 612 TREEITEMTYPE_PLCITFPROP PLC interface property 1 613 TREEITEMTYPE_PLCPROPGET PLC property getter 1 614 TREEITEMTYPE_PLCPROPSET PLC property setter 1 615 TREEITEMTYPE_PLCGVL GVL (Global variable list) 1 616 TREEITEMTYPE_PLCTRANS PLC Transition 1 617 TREEITEMTYPE_PLCLIBMAN PLC library manager 1 618 TREEITEMTYPE_PLCITF PLC interface 1 619 TREEITEMTYPE_PLCVISOBJ PLC visual object 1 620 TREEITEMTYPE_PLCVISMAN PLC visual manager 1 621 TREEITEMTYPE_PLCTASK PLC task object 1 622 TREEITEMTYPE_PLCPROGREF PLC program reference 1 623 TREEITEMTYPE_PLCDUTALIAS DUT Alias 624 TREEITEMTYPE_PLCEXTDATAT PLC external data type container 1 YPECONT 625 TREEITEMTYPE_PLCTMCDESC PLC TMC description file 1 RIPTION 654 TREEITEMTYPE_PLCITFPROPG PLC interface property getter ET 655 TREEITEMTYPE_PLCITFPROPS PLC interface property setter ET Automation Interface Version: 1.5 129

## Page 130

API NC item types Item type Tag Description 19 TREEITEMTYPE_NCDEF --- 20 TREEITEMTYPE_NCAXISES --- 21 TREEITEMTYPE_NCCHANNEL NC Channel 22 TREEITEMTYPE_NCAXIS NC Axis 23 TREEITEMTYPE_NCENCODER --- 24 TREEITEMTYPE_NCDRIVE --- 25 TREEITEMTYPE_NCCONTROLL --- ER 26 TREEITEMTYPE_NCGROUP --- 27 TREEITEMTYPE_NCINTERPRET --- ER 40 TREEITEMTYPE_NCTABLEGRP --- 41 TREEITEMTYPE_NCTABLE --- 42 TREEITEMTYPE_NCTABLESLAV --- E Requirements Notes 1 requires Twin CAT 3.1 5.3.3 Tree item sub types 5.3.3.1 ITc Sm Tree Item Item Sub Types Item sub types specify what kind of device , box or terminal is being used, for example a sub type of 2408 identifies a KL2408 digital output terminal. You can check the sub type of an item by manually adding it in Twin CAT System Manager or XAE and then export its XML description via the corresponding menu entry. • Twin CAT System Manager: Actions --> Export XML description • Twin CAT XAE: Twin CAT --> Selected item --> Export XML description In the resulting XML file, the sub type is represented by the node <Item Sub Type>. In the above example, we exported the XML description of an EL2008 terminal. The XML file shows that this terminal has a sub type of 9099. 130 Version: 1.5 Automation Interface

## Page 131

API The following tables will give you a good overview about some of the available sub types. If your devices is not listed, please perform the above steps to determine the sub type of your specific device. Shortcuts: • Devices [} 133] • Boxes [} 140] • Terminals: E-Bus [} 131] (ELxxxx) • Terminals: K-Bus digital input [} 146] (KL1xxx) • Terminals: K-Bus digital output [} 148] (KL2xxx) • Terminals: K-Bus analog input [} 151] (KL3xxx) • Terminals: K-Bus analog output [} 153] (KL4xxx) • Terminals: K-Bus position measurement [} 153] (KL5xxx) • Terminals: K-Bus communication [} 154] (KL6xxx) • Terminals: K-Bus power [} 155] (KL8xxx) • Terminals: K-Bus safety [} 157] (KLx90x) • Terminals: K-Bus system [} 156] (KL9xxx) 5.3.3.2 ITc Sm Tree Item Item Sub Types: E-Bus Due to their architecture, E-Bus boxes , terminals and modules will be handled differently than their K- Bus counterparts, e.g. during creation using the Create Child() [} 160] method. As each K-Bus terminal will be specified according to its specific sub type, E-Bus terminals are recognized via one common sub type and then specified via their "Product Revision " which will be used as the v Info parameter in the Create Child() method. Sub type Description 9099 Generic sub type for all Ether CAT terminals. In case of Create Child() [} 160], a specific terminal will be defined via v Info parameter. There are a few exceptions to this rule, e.g. for RS232 terminals. The following table gives an overview about these exceptions: Automation Interface Version: 1.5 131

## Page 132

API I/O Item Sub Type Description EP6002 9101 RS232 / RS422 / RS485 interface terminal EL6001 9101 RS232 interface terminal EL6002 9101 RS232 interface terminal (2- Channel) EL6021 9103 RS422 / RS485 interface terminal EL6022 9103 RS422 / RS485 interface terminal (2-Channel) Code Snippet (C#) ITc Sm Tree Item ek1100 = system Manager. Lookup Tree Item("TIID^Ether CAT Master^EK1100"); ek1100. Create Child("EL2002 - 1", 9099, "", "EL2002-0000-0016"); Product revision Each E-Bus box/terminal/module has its own product revision, which you can view either by exporting its XML description [} 25] or in the "Add Device" dialog in Twin CAT XAE. For example, the EL2002 digital output terminal has the product revision EL2002-0000-0016, as you can also see in its XML description: 132 Version: 1.5 Automation Interface

## Page 133

API To get the XML description of a tree item, simply do the following: • Twin CAT 2: Add the item to System Manager, select it and, from the menu, choose "Actions" --> "Export XML description" • Twin CAT 3: Add the item to XAE, select it and, from the menu, choose "Twin CAT" --> "Selected item" --> "Export XML description" 5.3.3.3 Devices 5.3.3.3.1 ITc Sm Tree Item Item Sub Types: Devices Devices: Miscellaneous Sub type Tag Description 0 IODEVICETYPE_UNKNOWN --- 6 IODEVICETYPE_BKHFPC Beckhoff Industrial-PC C2001 9 IODEVICETYPE_LPTPORT LPT Port 10 IODEVICETYPE_DPRAM Generic DPRAM 11 IODEVICETYPE_COMPORT COM Port 18 IODEVICETYPE_FCXXXX Beckhoff-Feldbus Card 32 IODEVICETYPE_SMB Motherboard System Management Bus 43 IODEVICETYPE_BKHFNCBP Beckhoff NC Rückwand 44 IODEVICETYPE_SERCANSPCI Sercos Master (SICAN/IAM PCI) 46 IODEVICETYPE_SERCONPCI Sercon 410B or 816 Chip Master or Slave (PCI) 53 IODEVICETYPE_BKHFAH2000 Beckhoff AH2000 (Hydraulik Backplane) 55 IODEVICETYPE_AH2000MC Beckhoff-AH2000 mit Profibus-MC Automation Interface Version: 1.5 133

## Page 134

API Devices: Beckhoff CX Terminal Devices Sub type Tag Description 120 IODEVICETYPE_CX5000 CX5000 Terminal Device 135 IODEVICETYPE_CX8000 CX8000 Terminal Device 105 IODEVICETYPE_CX9000_BK CX9000 Terminal Device 65 IODEVICETYPE_CX1100_BK CX1100 Terminal Device 124 IODEVICETYPE_CCAT Beckhoff CCAT Adapter Devices: Beckhoff CP Devices Sub type Tag Description 14 IODEVICETYPE_BKHFCP2030 Beckhoff CP2030 (Pannel-Link) 31 IODEVICETYPE_BKHFCP9030 Beckhoff CP9030 (Pannel-Link with UPS, ISA) 52 IODEVICETYPE_BKHFCP9040 Beckhoff CP9040 (CP-PC) 54 IODEVICETYPE_BKHFCP9035 Beckhoff CP9035 (Pannel-Link with UPS, PCI) 116 IODEVICETYPE_BKHFCP6608 Beckhoff CP6608(IXP PC) Devices: Beckhoff BC/BX Devices Sub type Tag Description 77 IODEVICETYPE_BX_BK BX Klemmenbus Interface 78 IODEVICETYPE_BX_M510 BX SSB-Master 103 IODEVICETYPE_BC8150 BCXX50 Serial Slave 104 IODEVICETYPE_BX9000 BX9000 Ethernet Slave 107 IODEVICETYPE_BC9050 BC9050 Etherent Slave 108 IODEVICETYPE_BC9120 BC9120 Etherent Slave 110 IODEVICETYPE_BC9020 BC9020 Etherent Slave Devices: Beckhoff Ether CAT Sub type Tag Description 94 IODEVICETYPE_ETHERCAT Obsolete: Ether CAT Master. Use "111" instead. 111 IODEVICETYPE_ETHERCATPRO Ether CAT Master T 130 IODEVICETYPE_ETHERCATSLV Ether CAT Slave 106 IODEVICETYPE_EL6601 Ether CAT Automation Protocol via EL6601 112 IODEVICETYPE_ETHERNETNVP Ether CAT Automation Protocol ROT (Network variables) 144 IODEVICETYPE_ETHERCATSIM Ether CAT-Simulation ULATION 134 Version: 1.5 Automation Interface

## Page 135

API Devices: Beckhoff Lightbus Master/Slave Sub type Tag Description 67 IODEVICETYPE_CX1500_M200 PC104 Lightbus-Master 68 IODEVICETYPE_CX1500_B200 PC104 Lightbus-Slave 36 IODEVICETYPE_FC200X Beckhoff-Lightbus-I/II-PCI-Card 114 IODEVICETYPE_EL6720 Beckhoff-Lightbus-Ether CAT- Klemme 1 IODEVICETYPE_C1220 Beckhoff Lightbus ISA interface card C1220 2 IODEVICETYPE_C1200 Beckhoff Lightbus ISA interface card C1200 Devices: Beckhoff Profibus Master/Slave Sub type Tag Description 69 IODEVICETYPE_CX1500_M310 PC104 Profi Bus-Master 70 IODEVICETYPE_CX1500_B310 PC104 Profi Bus-Slave 33 IODEVICETYPE_PBMON Beckhoff-PROFIBUS-Monitor 38 IODEVICETYPE_FC3100 Beckhoff-Profibus-PCI-Card 56 IODEVICETYPE_FC3100MON Beckhoff-Profibus-Monitor-PCI- Karte 60 IODEVICETYPE_FC3100SLV Beckhoff-Profibus-PCI-Karte als Slave 79 IODEVICETYPE_BX_B310 BX Profi Bus-Slave 83 IODEVICETYPE_BC3150 BCxx50 Profi Bus-Slave 86 IODEVICETYPE_EL6731 Beckhoff-Profibus-Ether CAT- Klemme 97 IODEVICETYPE_EL6731SLV Beckhoff-Profibus-Slave- Ether CAT-Klemme Devices: Beckhoff CANopen Master/Slave Sub type Tag Description 71 IODEVICETYPE_CX1500_M510 PC104 CANopen-Master 72 IODEVICETYPE_CX1500_B510 PC104 CANopen-Slave 39 IODEVICETYPE_FC5100 Beckhoff-Can Open-PCI-Card 58 IODEVICETYPE_FC5100MON Beckhoff-CANopen-Monitor-PCI- Karte 61 IODEVICETYPE_FC5100SLV Beckhoff-Can Open-PCI-Karte als Slave 81 IODEVICETYPE_BX_B510 BX CANopen-Slave 84 IODEVICETYPE_BC5150 BCxx50 CANopen-Slave 87 IODEVICETYPE_EL6751 Beckhoff-Can Open-Ether CAT- Klemme 98 IODEVICETYPE_EL6751SLV Beckhoff-Can Open-Slave- Ether CAT-Klemme Automation Interface Version: 1.5 135

## Page 136

API Devices: Beckhoff Device Net Master/Slave Sub type Tag Description 73 IODEVICETYPE_CX1500_M520 PC104 Device Net-Master 74 IODEVICETYPE_CX1500_B520 PC104 Device Net-Slave 41 IODEVICETYPE_FC5200 Beckhoff-Device Net-PCI-Card 59 IODEVICETYPE_FC5200MON Beckhoff-Device Net-Monitor-PCI- Karte 62 IODEVICETYPE_FC5200SLV Beckhoff-Device Net-PCI-Karte als Slave 82 IODEVICETYPE_BX_B520 BX Device Net-Slave 85 IODEVICETYPE_BC5250 BCxx50 Device Net-Slave 88 IODEVICETYPE_EL6752 Beckhoff-Device Net-Ether CAT- Klemme 99 IODEVICETYPE_EL6752SLV Beckhoff-Device Net-Slave- Ether CAT-Klemme Devices: Beckhoff Sercos Master/Slave Sub type Tag Description 75 IODEVICETYPE_CX1500_M750 PC104 Sercos-Master 76 IODEVICETYPE_CX1500_B750 PC104 Sercos-Slave 48 IODEVICETYPE_FC7500 Beckhoff-SERCOS-PCI-Card Devices: Ethernet Sub type Tag Description 66 IODEVICETYPE_ENETRTMP Ethernet Real Time Miniport 109 IODEVICETYPE_ENETADAPTER Real-Time Ethernet Adapter (Multiple Protocol Handler) 138 --- Real-Time Ethernet Protocol (BK90xx, AX2000-B900) 45 IODEVICETYPE_ETHERNET Virtual Ethernet Interface Devices: USB Sub type Tag Description 57 IODEVICETYPE_USB Virtual USB Interface 125 --- Virtual USB Interface (Remote) 136 Version: 1.5 Automation Interface

## Page 137

API Devices: Hilscher Automation Interface Version: 1.5 137

## Page 138

API Sub type Tag Description 4 IODEVICETYPE_CIF30DPM ISA Profi Bus-Master 2 k Byte (Hilscher Card) 5 IODEVICETYPE_CIF40IBSM ISA Interbus-S-Master 2 k Byte (Hilscher-Card) 12 IODEVICETYPE_CIF30CAN ISA CANopen-Master (Hilscher- Card) 13 IODEVICETYPE_CIF30PB ISA Profi Bus-Master 8 k Byte (Hilscher-Card) 16 IODEVICETYPE_CIF30IBM ISA Interbus-S-Master (Hilscher- Card) 17 IODEVICETYPE_CIF30DNM ISA Device Net-Master (Hilscher- Card) 19 IODEVICETYPE_CIF50PB PCI Profi Bus-Master 8 k Byte (Hilscher-Card) 20 IODEVICETYPE_CIF50IBM PCI Interbus-S-Master (Hilscher- Card) 21 IODEVICETYPE_CIF50DNM PCI Device Net-Master (Hilscher- Card) 22 IODEVICETYPE_CIF50CAN PCI CANopen-Master (Hilscher- Card) 23 IODEVICETYPE_CIF60PB PCMCIA Profi Bus-Master (Hilscher-Card) 24 IODEVICETYPE_CIF60DNM PCMCIA Device Net-Master (Hilscher-Card) 25 IODEVICETYPE_CIF60CAN PCMCIA CANopen-Master (Hilscher-Card) 26 IODEVICETYPE_CIF104DP PC104 Profi Bus-Master 2 k Byte (Hilscher-Card) 27 IODEVICETYPE_C104PB PC104 Profi Bus-Master 8 k Byte (Hilscher-Card) 28 IODEVICETYPE_C104IBM PC104 Interbus-S-Master 2 k Byte (Hilscher-Card) 29 IODEVICETYPE_C104CAN PC104 CANopen-Master (Hilscher- Card) 30 IODEVICETYPE_C104DNM PC104 Device Net-Master (Hilscher-Card) 35 IODEVICETYPE_CIF60IBM PCMCIA Interbus-S-Master (Hilscher-Card) 49 IODEVICETYPE_CIF30IBS ISA Interbus-S-Slave (Hilscher- Card) 50 IODEVICETYPE_CIF50IBS PCI Interbus-S-Slave (Hilscher- Card) 51 IODEVICETYPE_C104IBS PC104 Interbus-S-Slave (Hilscher- Card) 89 IODEVICETYPE_COMPB COM Profi Bus-Master 8 k Byte (Hilscher-Karte) 90 IODEVICETYPE_COMIBM COM Interbus-S-Master (Hilscher- Karte) 91 IODEVICETYPE_COMDNM COM Device Net-Master (Hilscher- Karte) 92 IODEVICETYPE_COMCAN COM CANopen-Master (Hilscher- Karte) 93 IODEVICETYPE_COMIBS COM CANopen-Slave (Hilscher- Karte) 138 Version: 1.5 Automation Interface

## Page 139

API Sub type Tag Description 100 IODEVICETYPE_C104PPB PC104+ Profi Bus-Master 8 k Byte (Hilscher-Karte) 101 IODEVICETYPE_C104PCAN PC104+ CANopen-Master (Hilscher-Karte) 102 IODEVICETYPE_C104PDNM PC104+ Device Net-Master (Hilscher-Karte) Devices: Profinet / Profibus Sub type Tag Description 3 IODEVICETYPE_SPC3 Profi Bus Slave (Siemens Card) 7 IODEVICETYPE_CP5412A2 Profi Bus-Master (Siemens-Card) 34 IODEVICETYPE_CP5613 PCI Profi Bus-Master (Siemens- Card) 113 IODEVICETYPE_PROFINETIOCO PROFINET Master NTROLLER 115 IODEVICETYPE_PROFINETIODE PROFINET Slave VICE Devices: Indramat Sub type Tag Description 8 IODEVICETYPE_SERCANSISA Sercos Master (Indramat) Devices: Phoenix Sub type Tag Description 15 IODEVICETYPE_IBSSCIT Interbus-S-Master (Phoenix-Card) 47 IODEVICETYPE_IBSSCRIRTLK Interbus-S-Master with Slave-Part LWL Basis (Phoenix-Card) 63 IODEVICETYPE_IBSSCITPCI PCI Interbus-S-Master (Phoenix- Karte) 64 IODEVICETYPE_IBSSCRILKPCI PCIInterbus-S-Master mit Slave- Teil auf LWL Basis (Phoenix-Karte) 80 IODEVICETYPE_IBSSCRIRTPCI PCIInterbus-S-Master mit Slave- Teil auf Kupfer Basis (Phoenix- Karte) Automation Interface Version: 1.5 139

## Page 140

API 5.3.3.4 Boxes 5.3.3.4.1 ITc Sm Tree Item Item Sub Types: Boxes 140 Version: 1.5 Automation Interface

## Page 141

API Sub type Tag Description 0 BOXTYPE_UNKNOWN --- 1 BOXTYPE_BK2000 BK2000 Lightbus coupler 2 BOXTYPE_M1400 M1400 Lightbus digital input/output module 3 BOXTYPE_M2400 M2400 Lightbus input/output module 4 BOXTYPE_M3120_1 M3120 Lightbus incremental encoder interface 5 BOXTYPE_M3120_2 M3120 Lightbus incremental encoder interface 6 BOXTYPE_M3120_3 M3120 Lightbus incremental encoder interface 7 BOXTYPE_M3120_4 M3120 Lightbus incremental encoder interface 8 BOXTYPE_M3000 M3000 absolute / incremental encoder 9 BOXTYPE_C1120 --- 10 BOXTYPE_BK2010 BK2010 Lightbus coupler 11 BOXTYPE_AX2000 --- 12 BOXTYPE_M2510 --- 20 BOXTYPE_BK2020 BK2020 Lightbus coupler 21 BOXTYPE_BC2000 --- 31 BOXTYPE_FOX20 --- 32 BOXTYPE_FOX50 --- 33 BOXTYPE_FOXRK001 --- 34 BOXTYPE_FOXRK002 --- 35 BOXTYPE_CP1001 --- 40 BOXTYPE_IPXB2 --- 41 BOXTYPE_ILXB2 --- 42 BOXTYPE_ILXC2 --- 50 BOXTYPE_TSMBOX_200 --- 51 BOXTYPE_BX2000 --- 52 BOXTYPE_CX1500_B200 --- 1001 BOXTYPE_BK3000 --- 1002 BOXTYPE_BK3100 --- 1003 BOXTYPE_PBDP_GSD --- 1004 BOXTYPE_BK3010 --- 1005 BOXTYPE_BK3110 --- 1006 BOXTYPE_BK3500 --- 1007 BOXTYPE_LC3100 --- 1008 BOXTYPE_PBDP_DRIVE --- 1009 BOXTYPE_BK3020 --- 1010 BOXTYPE_BK3120 --- 1011 BOXTYPE_BC3100 --- 1012 BOXTYPE_PBDP_DRIVE2 --- 1013 BOXTYPE_PBDP_DRIVE3 --- 1014 BOXTYPE_PBDP_DRIVE4 --- 1015 BOXTYPE_PBDP_DRIVE5 --- 1016 BOXTYPE_PBDP_DRIVE6 --- 1017 BOXTYPE_PBDP_DRIVE7 --- Automation Interface Version: 1.5 141

## Page 142

API Sub type Tag Description 1018 BOXTYPE_PBDP_DRIVE8 --- 1019 BOXTYPE_BK3150 --- 1020 BOXTYPE_BC3150 --- 1021 BOXTYPE_BK3XXX --- 1022 BOXTYPE_BC3XXX --- 1030 BOXTYPE_IPXB3 --- 1031 BOXTYPE_ILXB3 --- 1032 BOXTYPE_ILXC3 --- 1040 BOXTYPE_TSMBOX_310 --- 1041 BOXTYPE_BX3100 --- 1042 BOXTYPE_CX1500_B310 --- 1043 BOXTYPE_FC310X_SLAVE --- 1044 BOXTYPE_EL6731_SLAVE --- 1051 BOXTYPE_AX2000_B310 --- 1100 BOXTYPE_TCPBDPSLAVE --- 1101 BOXTYPE_TCFDLAGAG --- 1102 BOXTYPE_TCMPI --- 1103 BOXTYPE_TCPBMCSLAVE --- 1104 BOXTYPE_TCPBMCSLAVE2 --- 1105 BOXTYPE_TCPBMCSLAVE3 --- 1106 BOXTYPE_TCPBMCSLAVE4 --- 1107 BOXTYPE_TCPBMCSLAVE5 --- 1108 BOXTYPE_TCPBMCSLAVE6 --- 1109 BOXTYPE_TCPBMCSLAVE7 --- 1110 BOXTYPE_TCPBMCSLAVE8 --- 1111 BOXTYPE_TCPBMONSLAVE --- 2001 BOXTYPE_BK4000 --- 2002 BOXTYPE_IBS_GENERIC --- 2003 BOXTYPE_IBS_BK --- 2004 BOXTYPE_BK4010 --- 2005 BOXTYPE_BK4500 --- 2006 BOXTYPE_BK4510 --- 2007 BOXTYPE_IBS_SLAVEBOX --- 2008 BOXTYPE_BC4000 --- 2009 BOXTYPE_BK4020 --- 2020 BOXTYPE_CP2020 --- 2030 BOXTYPE_IPXB4 --- 2031 BOXTYPE_ILXB4 --- 2032 BOXTYPE_ILXC4 --- 3001 BOXTYPE_SERCOSAXIS --- 3011 BOXTYPE_BK7500 --- 3012 BOXTYPE_BK7510 --- 3013 BOXTYPE_BK7520 --- 3021 BOXTYPE_SERCOSMASTERBO --- X 3031 BOXTYPE_SERCOSSLAVEBOX --- 4001 BOXTYPE_BK8100 BK8100 bus coupler 4002 BOXTYPE_BK8110 BK8110 bus coupler 4003 BOXTYPE_BK8000 BK8000 bus coupler 142 Version: 1.5 Automation Interface

## Page 143

API Sub type Tag Description 4004 BOXTYPE_BK8010 BK8010 bus coupler 4005 BOXTYPE_CP9040 CP9040 PCB 4011 BOXTYPE_BC8000 BC8000 bus terminal controller 4012 BOXTYPE_BC8100 BC8100 bus terminal controller 4030 BOXTYPE_IPXB80 --- 4031 BOXTYPE_ILXB80 --- 4032 BOXTYPE_ILXC80 --- 4040 BOXTYPE_IPXB81 --- 4041 BOXTYPE_ILXB81 --- 4042 BOXTYPE_ILXC81 --- 4050 BOXTYPE_BC8150 BC8150 bus terminal controller 5001 BOXTYPE_BK5100 BK5100 bus coupler 5002 BOXTYPE_BK5110 BK5110 bus coupler 5003 BOXTYPE_CANNODE --- 5004 BOXTYPE_BK5120 BK5120 bus coupler 5005 BOXTYPE_LC5100 --- 5006 BOXTYPE_CANDRIVE --- 5007 BOXTYPE_AX2000_B510 --- 5008 BOXTYPE_BK5150 BK5150 bus coupler 5009 BOXTYPE_BK5151 BK5151 bus coupler 5011 BOXTYPE_BC5150 BC5150 bus terminal controller 5030 BOXTYPE_IPXB51 --- 5031 BOXTYPE_ILXB51 --- 5032 BOXTYPE_ILXC51 --- 5040 BOXTYPE_TSMBOX_510 --- 5041 BOXTYPE_BX5100 BX5100 CANopen bus terminal controller 5042 BOXTYPE_CX1500_B510 --- 5043 BOXTYPE_FC510XSLV --- 5050 BOXTYPE_TCCANSLAVE --- 5051 BOXTYPE_CANQUEUE CAN Interface 5201 BOXTYPE_BK5200 --- 5202 BOXTYPE_BK5210 --- 5203 BOXTYPE_DEVICENET --- 5204 BOXTYPE_BK5220 --- 5205 BOXTYPE_LC5200 --- 5211 BOXTYPE_BK52XX --- 5212 BOXTYPE_BC52XX --- 5230 BOXTYPE_IPXB52 --- 5231 BOXTYPE_ILXB52 --- 5232 BOXTYPE_ILXC52 --- 5250 BOXTYPE_TCDNSLAVE --- 9001 BOXTYPE_BK9000 BK9000 Ethernet TCP/IP bus coupler 9002 BOXTYPE_BK9100 BK9100 Ethernet TCP/IP bus coupler 9005 BOXTYPE_BK9050 BK9050 Ethernet TCP/IP bus coupler 9011 BOXTYPE_BC9000 BC9000 Ethernet TCP/IP bus terminal controller Automation Interface Version: 1.5 143

## Page 144

API Sub type Tag Description 9012 BOXTYPE_BC9100 BC9100 Ethernet TCP/IP bus terminal controller 9013 BOXTYPE_BX9000 BX9000 Ethernet TCP/IP bus terminal controller 9014 BOXTYPE_BX9000SLV --- 9015 BOXTYPE_BC9050 BC9050 Ethernet TCP/IP bus terminal controller 9016 BOXTYPE_BC9050SLV BC9050 Ethernet TCP/IP bus terminal controller slave 9017 BOXTYPE_BC9120 BC9120 Ethernet TCP/IP bus terminal controller 9018 BOXTYPE_BC9120SLV BC9120 Ethernet TCP/IP bus terminal controller slave 9019 BOXTYPE_BC9020 BC9020 Ethernet TCP/IP bus terminal controller 9020 BOXTYPE_BC9020SLV BC9020 Ethernet TCP/IP bus terminal controller slave 9030 BOXTYPE_IPXB9 --- 9031 BOXTYPE_ILXB9 --- 9032 BOXTYPE_ILXC9 --- 9041 BOXTYPE_REMOTETASK --- 9051 BOXTYPE_NV_PUB Network Publisher. 9052 BOXTYPE_NV_SUB Network Subscriber. 9053 BOXTYPE_NV_PUBVAR Publisher variable. 9054 BOXTYPE_NV_SUBVAR Subscriber variable. 9055 BOXTYPE_NV_PUBDATA Publisher data object. 9056 BOXTYPE_NV_SUBDATA Subscriber data object. 9061 BOXTYPE_AX2000_B900 --- 9071 BOXTYPE_FLB_FRAME --- 9081 BOXTYPE_BK1120 --- 9085 BOXTYPE_IPXB11 --- 9086 BOXTYPE_ILXB11 --- 9087 BOXTYPE_ILXC11 --- 9105 BOXTYPE_FSOESLAVE --- 9121 BOXTYPE_PNIODEVICE --- 9122 BOXTYPE_PNIOTCDEVICE --- 9123 BOXTYPE_PNIODEVICEINTF Profinet Twin CAT Device Interface 9124 BOXTYPE_PNIO_DRIVE --- 9125 BOXTYPE_PNIOBK9103 --- 9126 BOXTYPE_PNIOILB903 --- 9132 BOXTYPE_BK9053 BK9053 K-Bus coupler, PROFINET IO RT 9133 BOXTYPE_EIPSLAVEINTF --- 9143 BOXTYPE_PTPSLAVEINTF --- 9151 BOXTYPE_RAWUDPINTF --- 9500 BOXTYPE_BK9500 BK9500 9510 BOXTYPE_BK9510 BK9510 9520 BOXTYPE_BK9520 BK9520 9591 BOXTYPE_CPX8XX --- 9700 BOXTYPE_CX1102 --- 144 Version: 1.5 Automation Interface

## Page 145

API Sub type Tag Description 9701 BOXTYPE_CX1103 --- 9702 BOXTYPE_CX1190 --- Automation Interface Version: 1.5 145

## Page 146

API 5.3.3.5 Terminals 5.3.3.5.1 ITc Sm Tree Item Item Sub Types: Terminals: K-Bus digital input (KL1) 146 Version: 1.5 Automation Interface

## Page 147

API Sub type Description 1002 KL1002 2-Channel digital input terminal 1012 KL1012 2-Channel digital input terminal 1032 KL1032 2-Channel digital input terminal 1052 KL1052 2-Channel digital input terminal 1104 KL1104 4-Channel digital input terminal 1114 KL1114 4-Channel digital input terminal 1124 KL1124 4-Channel digital input terminal 1154 KL1154 4-Channel digital input terminal 1164 KL1164 4-Channel digital input terminal 1184 KL1184 4-Channel digital input terminal 1194 KL1194 4-Channel digital input terminal 1212 KL1212 2-Channel digital input terminal 1232 KL1232 2-Channel digital input terminal 1302 KL1302 2-Channel digital input terminal 1304 KL1304 4-Channel digital input terminal 1312 KL1312 2-Channel digital input terminal 1314 KL1314 4-Channel digital input terminal 1352 KL1352 2-Channel digital input terminal 1362 KL1362 2-Channel digital input terminal 1382 KL1382 2-Channel digital input terminal 1402 KL1402 2-Channel digital input terminal 1404 KL1404 4-Channel digital input terminal 1408 KL1408 8-Channel digital input terminal 1412 KL1412 2-Channel digital input terminal 1414 KL1414 4-Channel digital input terminal 1418 KL1418 8-Channel digital input terminal 1434 KL1434 4-Channel digital input terminal 1488 KL1488 8-Channel digital input terminal 1498 KL1498 8-Channel digital input terminal 1501 KL1501 1-Channel digital input terminal 1512 KL1512 2-Channel digital input terminal 1702 KL1702 2-Channel digital input terminal 1712 KL1712 2-Channel digital input terminal 16778928 KL1712-0060 2-Channel digital input terminal 1722 KL1722 2-Channel digital input terminal 1804 KL1804 4-Channel digital input terminal 1808 KL1808 8-Channel digital input terminal 1809 KL1809 16-Channel digital input terminal 1814 KL1814 4-Channel digital input terminal 1819 KL1819 16-Channel digital input terminal 1859 KL1859 8-Channel digital input terminal 1862 KL1862 16-Channel digital input terminal 16779078 KL1862-0010 16-Channel digital input terminal 1872 KL1872 16-Channel digital input terminal 1889 KL1889 16-Channel digital input terminal 1202 KL1202 2-Channel digital input terminal Automation Interface Version: 1.5 147

## Page 148

API 5.3.3.5.2 ITc Sm Tree Item Item Sub Types: Terminals: K-Bus digital output (KL2) 148 Version: 1.5 Automation Interface

## Page 149

API Sub type Description 2408 KL2408 8-Channel digital output terminal 2012 KL2012 2-Channel digital output terminal 2022 KL2022 2-Channel digital output terminal 2032 KL2032 2-Channel digital output terminal 2114 KL2114 4-Channel digital output terminal 2124 KL2124 4-Channel digital output terminal 2134 KL2134 4-Channel digital output terminal 2184 KL2184 4-Channel digital output terminal 2212 KL2212 2-Channel digital output terminal 2404 KL2404 4-Channel digital output terminal 2212 KL2212 2-Channel digital output terminal 2404 KL2404 4-Channel digital output terminal 2408 KL2408 8-Channel digital output terminal 2284 KL2284 4-Channel digital output terminal 2424 KL2424 4-Channel digital output terminal 2442 KL2442 2-Channel digital output terminal 2488 KL2488 8-Channel digital output terminal 2502 KL2502 2-Channel PWM output terminal 2512 KL2512 2-Channel PWM output terminal 2521 KL2521 1-Channel Pulse Train output terminal 2531 KL2531 1-Channel Stepper Motor terminal 16779747 KL2531-1000 1-Channel Stepper Motor terminal 2532 KL2532 2-Channel DC Motor amplifier output terminal 2535 KL2535 2-Channel PWM amplifier output terminal 2541 KL2541 1-Channel Stepper Motor terminal 16779757 KL2541-1000 1-Channel Stepper Motor terminal 2542 KL2542 2-Channel DC Motor amplifier terminal 2545 KL2545 2-Channel PWM amplifier output terminal 2552 KL2552 2-Channel DC Motor amplifier terminal 2602 KL2602 2-Channel output relay terminal 2612 KL2612 2-Channel output relay terminal 2622 KL2622 2-Channel output relay terminal 2631 KL2631 1-Channel power output relay terminal 2641 KL2641 1-Channel power output relay terminal 2652 KL2652 2-Channel power output relay terminal 2701 KL2701 1-Channel solid state load relay terminal 2702 KL2702 2-Channel output solid sate relay terminal 16779918 KL2702-0002 2-Channel output solid state relay terminal 33557134 KL2702-0020 2-Channel output solid state relay terminal 2712 KL2712 2-Channel triac output terminal 2722 KL2722 2-Channel triac output terminal 2732 KL2732 2-Channel triac output terminal 2744 KL2744 4-Channel output solid state relay 2751 KL2751 1-Channel universal dimmer terminal 33557183 KL2751-1200 1-Channel universal dimmer terminal 2761 KL2761 1-Channel universal dimmer terminal Automation Interface Version: 1.5 149

## Page 150

API Sub type Description 2784 KL2784 4-Channel output terminal 2791 KL2791 1-Channel speed controller terminal 33557223 KL2791-1200 1-Channel speed controller terminal 2794 KL2794 4-Channel output terminal 2808 KL2808 8-Channel output terminal 2809 KL2809 16-Channel output terminal 2872 KL2872 16-Channel output terminal 2889 KL2889 16-Channel output terminal 150 Version: 1.5 Automation Interface

## Page 151

API 5.3.3.5.3 ITc Sm Tree Item Item Sub Types: Terminals: K-Bus analog input (KL3) Automation Interface Version: 1.5 151

## Page 152

API Sub type Description 3001 KL3001 1-Channel analog input terminal 3002 KL3002 3-Channel analog input terminal 3011 KL3011 1-Channel analog input terminal 3012 KL3012 2-Channel analog input terminal 3021 KL3021 1-Channel analog input terminal 3022 KL3022 2-Channel analog input terminal 3041 KL3041 1-Channel analog input terminal 3042 KL3042 2-Channel analog input terminal 3044 KL3044 4-Channel analog input terminal 3051 KL3051 1-Channel analog input terminal 3052 KL3052 2-Channel analog input terminal 3054 KL3054 4-Channel analog input terminal 3061 KL3061 1-Channel analog input terminal 3062 KL3062 2-Channel analog input terminal 3064 KL3064 4-Channel analog input terminal 3102 KL3102 2-Channel analog input terminal 3112 KL3112 2-Channel analog input terminal 3122 KL3122 2-Channel analog input terminal 3132 KL3132 2-Channel analog input terminal 3142 KL3142 2-Channel analog input terminal 3152 KL3152 2-Channel analog input terminal 3158 KL3158 8-Channel analog input terminal 3162 KL3162 2-Channel analog input terminal 3172 KL3172 2-Channel analog input terminal 33557604 KL3172-0500 2-Channel analog input terminal 67112036 KL3172-1000 2-Channel analog input terminal 3182 KL3182 2-Channel analog input terminal 3201 KL3201 1-Channel analog input terminal 3202 KL3202 2-Channel analog input terminal 3204 KL3204 4-Channel analog input terminal 33557640 KL3208-0010 8-Channel analog input terminal 3222 KL3222 2-Channel analog input terminal 3228 KL3228 8-Channel analog input terminal 3302 KL3302 2-Channel analog input terminal 3311 KL3311 1-Channel analog input terminal 3312 KL3312 2-Channel analog input terminal 3314 KL3314 4-Channel analog input terminal 3351 KL3351 1-Channel resistor bridge terminal 50334999 KL3351-0001 1-Channel resistor bridge terminal 3356 KL3356 1-Channel precise resistor bridge terminal 3361 KL3361 1-Channel oscilloscope terminal 3362 KL3362 2-Channel oscilloscope terminal 3403 KL3403 3-Phase power measuring terminal 3404 KL3404 4-Channel analog input terminal 3408 KL3408 8-Channel analog input terminal 3444 KL3444 4-Channel analog input terminal 3448 KL3448 8-Channel analog input terminal 3454 KL3454 4-Channel analog input terminal 152 Version: 1.5 Automation Interface

## Page 153

API Sub type Description 3458 KL3458 8-Channel analog input terminal 3464 KL3464 4-Channel analog input terminal 3468 KL3468 8-Channel analog input terminal 5.3.3.5.4 ITc Sm Tree Item Item Sub Types: Terminals: K-Bus analog output (KL4) Sub type Description 4001 KL4001 1-Channel analog output terminal 4002 KL4002 2-Channel analog output terminal 4004 KL4004 4-Channel analog output terminal 4011 KL4011 1-Channel analog output terminal 4012 KL4012 2-Channel analog output terminal 4021 KL4021 1-Channel analog output terminal 4022 KL4022 2-Channel analog output terminal 4031 KL4031 1-Channel analog output terminal 4032 KL4032 2-Channel analog output terminal 4034 KL4034 4-Channel analog output terminal 4112 KL4112 2-Channel analog output terminal 4122 KL4122 2-Channel analog output terminal 4132 KL4132 2-Channel analog output terminal 4404 KL4404 4-Channel analog output terminal 4408 KL4408 8-Channel analog output terminal 4414 KL4414 4-Channel analog output terminal 4418 KL4418 8-Channel analog output terminal 4424 KL4424 4-Channel analog output terminal 4428 KL4428 8-Channel analog output terminal 4434 KL4434 4-Channel analog output terminal 4438 KL4438 8-Channel analog output terminal 4494 KL4494 2-Channel analog output terminal 5.3.3.5.5 ITc Sm Tree Item Item Sub Types: Terminals: K-Bus measuring (KL5) Sub type Description 5001 KL5001 1-Channel SSI encoder terminal 5051 KL5051 1-Channel Bi-SSI encoder terminal 16782267 KL5051-0010 1-Channel Bi-SSI encoder terminal 5101 KL5101 incremental encoder 5V terminal 5111 KL5111 incremental encoder 24V terminal 5121 KL5121 4-Channel line-motion-controller terminal 5151 KL5151 1-Channel incremental encoder terminal 33559583 KL5151-0021 1-Channel incremental encoder terminal 16782367 KL5151-0050 2-Channel incremental encoder terminal 5152 KL5152 2-Channel incremental encoder terminal Automation Interface Version: 1.5 153

## Page 154

API 5.3.3.5.6 ITc Sm Tree Item Item Sub Types: Terminals: K-Bus communication (KL6) Sub type Description 16783217 KL6001 interface RS232C terminal 50337649 KL6001 interface RS232 terminal 16783227 KL6011 interface TTY terminal 50337659 KL6011 interface TTY terminal 16783237 KL6021 interface RS422/485 terminal 50337669 KL6021 interface RS485 terminal 100669317 KL6021 interface RS485 terminal 100669327 KL6031 interface RS232 terminal 50337679 KL6031 interface RS232 terminal 100669337 KL6041 interface RS485 terminal 50337689 KL6041 interface RS485 terminal 16783257 KL6041-0100 interface RS485 terminal 6051 KL6051 data exchange terminal 335550521 KL6201 ASI-Master terminal 369104953 KL6201 ASI-Master terminal 402659385 KL6201 ASI-Master terminal 335550531 KL6211 ASI-Master terminal 369104963 KL6211 ASI-Master terminal 402659395 KL6211 ASI-Master terminal 6224 KL6224 I/O-Link Master terminal 16783440 KL6224 I/O-Link Master terminal 33560656 KL6224 I/O-Link Master terminal 50337872 KL6224 I/O-Link Master terminal 33560733 KL6301 EIB terminal 33560833 KL6401 LON terminal 33561013 KL6581 En Ocean terminal 33561203 KL6771 MP-Bus Master terminal 6781 KL6781 M-Bus interface terminal 6811 KL6811 DALI-Master terminal 6821 KL6821 e DALI-Master terminal 154 Version: 1.5 Automation Interface

## Page 155

API 5.3.3.5.7 ITc Sm Tree Item Item Sub Types: Terminals: K-Bus power (KL8) Sub type Description 33562433 KL8001 1-Channel power terminal 8001 KL8001 3-Channel power terminal 8519 KL8519 16 digital input terminal 8524 KL8524 2x4 digital output terminal 8528 KL8528 8 digital output terminal 8548 KL8548 8-Channel analog output terminal 8610 KL8610 1-Channel adapter terminal KL8601 16785826 KL8610 2-Channel adapter terminal KL8601 33563042 KL8610 3-Channel adapter terminal KL8601 50340258 KL8610 4-Channel adapter terminal KL8601 67117474 KL8610 5-Channel adapter terminal KL8601 83894690 KL8610 6-Channel adapter terminal KL8601 100671906 KL8610 7-Channel adapter terminal KL8601 117449122 KL8610 8-Channel adapter terminal KL8601 Automation Interface Version: 1.5 155

## Page 156

API 5.3.3.5.8 ITc Sm Tree Item Item Sub Types: Terminals: K-Bus system (KL9) Sub type Description 9010 KL9010 end terminal 9020 KL9020 bus extension end terminal 9050 KL9050 bus extension coupler terminal 9060 KL9060 adapter terminal 9070 KL9070 shield terminal 9080 KL9080 separation terminal 9100 KL9100 power supplier terminal 9110 KL9110 power supplier terminal 9150 KL9150 power supplier terminal 9160 KL9160 power supplier terminal 9180 KL9180 potential connection terminal 9181 KL9181 potential connection terminal 9182 KL9182 potential connection terminal 9183 KL9183 potential connection terminal 9184 KL9184 potential connection terminal 9185 KL9185 potential connection terminal 9186 KL9186 potential connection terminal 9187 KL9187 potential connection terminal 9188 KL9188 potential connection terminal 9189 KL9189 potential connection terminal 9190 KL9190 power feed terminal 9195 KL9195 shield terminal 9200 KL9200 power supplier terminal 9210 KL9210 power supplier terminal 9250 KL9250 power supplier terminal 9260 KL9260 power supplier terminal 9290 KL9290 power supplier terminal 9300 KL9300 4-Channel diode array terminal 9301 KL9301 7-Channel diode array terminal 9302 KL9302 7-Channel diode array terminal 9309 KL9309 interface terminal for KL85xx 9400 KL9400 K-Bus power supplier terminal 9505 KL9505 power supplier terminal 167781665 KL9505-0010 power suppler terminal 9508 KL9508 power supplier terminal 167781668 KL9508-0010 power supplier terminal 9510 KL9510 power supplier terminal 167781670 KL9510-0010 power supplier terminal 9512 KL9512 power supplier terminal 167781672 KL9512-0010 power supplier terminal 9515 KL9515 power supplier terminal 167781675 KL9515-0010 power supplier terminal 9528 KL9528 power supplier terminal 9540 KL9540 surge filter field supply terminal 9550 KL9550 surge filter system and field supply terminal 9560 KL9560 power supplier terminal 9570 KL9570 buffer capacitor terminal 156 Version: 1.5 Automation Interface

## Page 157

API 5.3.3.5.9 ITc Sm Tree Item Item Sub Types: Terminals: K-Bus safety (KLx90x) Sub type Description 1904 KL1904 4-Channel safety input terminal 1908 KL1908 8-Channel safety input terminal 2904 KL2904 4-Channel safety output terminal 6904 KL6904 safety logic (7 Twin SAFE connections) terminal 16784120 KL6904 safety logic (15 Twin SAFE connections) terminal 5.3.3.6 Modules 5.3.3.6.1 ITc Sm Tree Item Item Sub Types: Modules: K-Bus digital input (KM1) Sub type Description 838861802 KM1002 16-Channel digital input module 838861804 KM1004 32-Channel digital input module 838861808 KM1008 64-Channel digital input module 838861812 KM1012 16-Channel digital input module 838861814 KM1014 32-Channel digital input module 838861818 KM1018 64-Channel digital input module 838862444 KM1644 4-Channel digital input module 5.3.3.6.2 ITc Sm Tree Item Item Sub Types: Modules: K-Bus digital output (KM2) Sub type Description 838862802 KM2002 16-Channel digital output module 838862804 KM2004 32-Channel digital output module 838862808 KM2008 64-Channel digital output module 838862822 KM2022 16-Channel digital output module 838862842 KM2042 16-Channel digital output module 838863404 KM2604 4-Channel digital output relay module 838863414 KM2614 4-Channel digital output relay module 838863442 KM2642 2-Channel digital power output relay module 838863452 KM2652 2-Channel digital power output relay module 16779990 KM2774 4-Channel blinds control terminal 2774 KM2774-1001 4-Channel blinds control terminal 5.3.3.6.3 ITc Sm Tree Item Item Sub Types: Modules: K-Bus analog input (KM3) Sub type Description 838864501 KM3701 1-Channel differential pressure measuring 872418933 KM3701-0340 1-Channel differential pressure measuring 838864502 KM3702 2-Channel absolute pressure measuring 838864512 KM3712 2-Channel absolute pressure measuring Automation Interface Version: 1.5 157

## Page 158

API 5.3.3.6.4 ITc Sm Tree Item Item Sub Types: Modules: K-Bus analog output (KM4) Sub type Description 838865402 KM4602 2-Channel analog output terminal 5.3.3.6.5 ITc Sm Tree Item Item Sub Types: Modules: K-Bus communication (KM6) Sub type Description 6551 KM6551 IEEE802.15.4 terminal 838867463 KM6663 Ethernet changeover switch terminal 5.3.4 ITc Sm Tree Item::Produce Xml The Produce Xml() method returns a XML string with item specific information and parameter. HRESULT Produce Xml(VARIANT_BOOLb Recursive, BSTR* p XML); Parameters b Recursive [in, defaultvalue(0)] Optional parameter for future use. p XML [out, retval] Contains the XML representation of the item specific data and parameter. Return Values S_OK function returns successfully. E_POINTER p XML pointer is invalid. Comments The following XML string is an incomplete example of the resulting information if the tree item is a I/O device of the type SERCOS Master/Slave FC750x. This string can be used as input for the IXMLDOMDocument::load XML method to create a XML DOM document. 158 Version: 1.5 Automation Interface

## Page 159

API <?xml version="1.0"?> <Tree Item> <Item Name>Device 1 (FC750x)</Item Name> <Path Name>TIID^Device 1 (FC750x)</Path Name> <Item Type>2</Item Type> <Item Id>1</Item Id> <Item Sub Type>48</Item Sub Type> <Item Sub Type Name>SERCOS Master/Slave FC750x, PCI [Beckhoff FC7502 PCI]</Item Sub Type Name> <Child Count>0</Child Count> <Disabled>0</Disabled> <Device Def> <Ams Port>0</Ams Port> <Address Info> <Pci> <Bus No>0</Bus No> <Slot No>16</Slot No> <Irq No>9</Irq No> <Fc Channel>0</Fc Channel> </Pci> </Address Info> <Sercos Master> <Baudrate>0</Baudrate> <Operation Mode>0</Operation Mode> <Send Power>1</Send Power> <Access Time>200</Access Time> <Shift Time>50</Shift Time> <Startup To Phase4>1</Startup To Phase4> <Check Timing>1</Check Timing> </Sercos Master> </Device Def> </Tree Item> See also ITc Sm Tree Item::Consume XML [} 159] 5.3.5 ITc Sm Tree Item::Consume Xml ITc Sm Tree Item The Consume Xml() method consumes a BSTR containing the XML representation with item specific data and updates found parameters. This method is used to change item parameters not directly accessible by the ITc Sm Tree Item interface. HRESULT Consume Xml(BSTRbstr XML); Parameters bstr XML [in] string with the XML representation of the item specific parameter. The corresponding parameter will be updated in the System Manager database Return Values S_OK function returns successfully. E_FAIL the bstr XML string does not contain a valid xml document. Automation Interface Version: 1.5 159

## Page 160

API Comments The document can only contain the specific parameter that should be changed. The document structure has to fit to the item specific XML tree, but parameter that should not be changed can be omitted. The following document is a minimal example that can be used to change the specific parameter Check Number Boxes of the item (in this case a C1220 fieldbus card). If the parameters in the document are not known by the item, they will be ignored. <Tree Item><Device Def><Dev C1220Def><Check Number Boxes>0</Check Number Boxes></ Dev C1220Def></Device Def></Tree Item> The set of parameter of a specific tree item is defined in the xml schema document that comes with the Twin CAT System Manager. The parameter of a specific item can also evaluated by calling the ITc Sm Tree Item::Produce XML [} 158] method. The resulting xml string contains all parameters of that item, but not all of them are changeable. The xml string can contain any number and hierarchical order of xml elements that are valid in terms of the xml schema. It is allowed to change only one parameter at a time (like in the example above), change a set of parameters at once or delivers the full parameter set that ITc Sm Tree Item::Produce XML [} 158] returns (normally with same parameters changed). There are some special xml elements that are not corresponding to parameters, they will "execute" a function. An example is the <Rescan> element of a PLC project tree item. The string <Tree Item><Plc Def><Re Scan>1</Re Scan></Plc Def></Tree Item> as a parameter of Consume Xml will cause the System Manager to rescan the PLC project (like a manually rescan by pressing the "Rescan" button on a PLC project). The parameters and the functions that are available are documented in the xml schema file. See also ITc Sm Tree Item::Produce XML [} 158] 5.3.6 ITc Sm Tree Item::Create Child Creates a child item on a parent node. The child is being specified by its subtype [} 130]. HRESULT Create Child(BSTRbstr Name,long n Sub Type, BSTRbstr Before, VARIANT v Info, ITc Sm Tree Item**pip Item); The following example demonstrates this behavior in better detail. In this example, an EK1100 coupler is being added to an Ether CAT Master device (Device 1) in Twin CAT XAE. In Automation Interface, this could be done with the Create Child() method. The parent node (Device 1 Ether CAT) has the item type '2' (TREEITEMTYPE_DEVICE). The sub type specifies the child item and therefore the EK1100, which is sub type '9099' (BOXTYPE_EXXXXX). 160 Version: 1.5 Automation Interface

## Page 161

API Parameters bstr Name [in] Item name of the new child item. n Subtype: [in] S [} 130]ub type [} 130] of the new child item. The usable sub type depends on the item type [} 126] (the category)of the parent tree item. For example, a PLC Functionblock may only be added to the item type PLCFOLDER and not to a DEVICE. bstr Before [in, defaultvalue("")] If set, the parameter contains the name of another child item before that the new item should be inserted. v Info [in, optional] An optional parameter with additional creation information, which depends on the sub type [} 130]. The different dependencies are listed in the table below. pip Item [out, retval] Points to the location of a ITc Sm Tree Item [} 124] interface pointer that receives the result. Return Values S_OK function returns successfully. E_POINTER the location of the returning pointer is invalid TSM_E_INVALIDITEMSUBTYPE (0x98510003) the given sub type is invalid. TSM_E_ITEMNOTFOUND (0x98510001) The item bstr Before was not found. Optional v Info parameter Depending on theitem subtypeof the new child item,someadditional informationmay berequiredto create the child item. This information can be provided via the v Info parameter. Automation Interface Version: 1.5 161

## Page 162

API Untergeordnetes Element: Element-Subtyp v Info-Parameter E-Bus Box / Klemme / Modul (Element-Subtyp 9099) Contains the Identity Object (Co E 1018h, Vendor Id, Product Code and optional Revision No and Serial No) of the Ether CAT box. The type of the variant must be an array of LONG (VT_I4|VT_ARRAY, 2-4 elements). Alternatively contains a BSTR of the following formats (with %X = value in hex notation, e.g. "V00000002_P044c2c52_R00000000"): Especially for Beckhoff E-Bus terminals / modules, please read the corresponding E-Bus article [} 131]. Interbus-Box. (Element-Subtyp 2002) Contains the Ident Code and Length Code of the Interbus box. The type of the variant must be an unsigned short (VT_I2), the low byte contains the Ident Code the high byte the Length Code. AX2000 (Element-Subtyp 5007) Optionally contains a bool value (VT_BOOL) and if CANDrive (Element-Subtyp 5006) set an additional variable for the `Following Error`will be created. Device NET (Element-Subtyp 5203) Optionally contains the file path to an EDS file Tc DNSSlave (Element-Subtyp 5250) (VT_BSTR). CX1500 (Element-Subtyp 1042) FC520X Slave (Element-Subtyp 1043) BK3000 und alle übrigen PROFIBUS-Box-Typen Optionally contains the file path to an GSD file (VT_BSTR). Variable Optionally contains the bit address of the new variable. The type of the variant can be a SHORT or a LONG (VT_I2 or VT_I4). SPS-POU Funktionsblock (Element-Subtyp 604) Contains IEC language type as Integer, as defined by IECLANGUAGETYPES [} 166]. SPS-POU Funktion (Element-Subtyp 603) Contains a string[2] array, which hols the following values: • array[0] = IEC language type as Integer, as defined by IECLANGUAGETYPES [} 166]. • array[1] = return data type of function. May be any PLC data type, for example DINT, BOOL, ... 5.3.7 ITc Sm Tree Item::Delete Child Deletes a child item. HRESULT Delete Child(BSTRbstr Name); Parameters bstr Name [[in] Item name of the child item that should be deleted. Return Values S_OK function returns successfully. E_ACCESSDENIED it is not allowed to delete the child item. TSM_E_ITEMNOTFOUND (0x98510001) The item bstr Before was not found. 162 Version: 1.5 Automation Interface

## Page 163

API 5.3.8 ITc Sm Tree Item::Import Child Imports a child item from the clipboard or a previously exported file. HRESULT Import Child(BSTRbstr File, BSTRbstr Before, VARIANT_BOOLb Reconnect, BSTRbstr Name, ITc Sm Tree Item**pip Item); Parameters bstr File [in, defaultvalue(L"")] File name of the file from which the new child will be imported. If no file name specified (empty string) the child will be imported from the clipboard. bstr Before [in, defaultvalue(L"")] If set, the parameter contains the name of another child item in front of which the new item should be inserted. If not set, the child will be appended at the end. b Reconnect [in, defaultvalue(VARIANT_TRUE)] An optional flag that instructs the System Manager to try to reconnect the variables from the imported item to other variables in the configuration (by name). bstr Name [in, defaultvalue(L"")] If set, overrides the child item name with its name in the import file. pip Item [out, retval] Points to the location of a ITc Sm Tree Item [} 124] interface pointer that receives the result. Return Values S_OK function returns successfully. NTE_NOT_FOUND (0x80090011) the file can not be found/opened. NTE_BAD_SIGNATURE (0x80090006) the file does not contain a valid tree item. TSM_E_MISMATCHINGITEMS (0x98510004) the item in the file is not a valid child item. 5.3.9 ITc Sm Tree Item::Export Child Exports a child item to the clipboard or a file. HRESULT Export Child(BSTRbstr Name, BSTRbstr File); Parameters bstr Name [in] Name of the child being exported. bstr File [in, defaultvalue("")] File name of the file to which the child will be exported. If no file name specified (empty string) the child will be exported to the clipboard. Return Values S_OK function returns successfully. TSM_E_ITEMNOTFOUND (0x98510001) The item bstr Name was not found. 5.3.10 ITc Sm Tree Item::Lookup Child Returns a ITc Tree Item pointer of a descendant child tree item given by it's relative path name. HRESULT Lookup Child(BSTRbstr Name, ITc Sm Tree Item**pip Item); Automation Interface Version: 1.5 163

## Page 164

API Parameters bstr Name [in] relative path of the tree item you are looking for. The relative path name is required and each branch must be separated by a circumflex accent '^' or a tab. pip Item [out, retval] points to the location of a ITc Sm Tree Item [} 124] interface pointer on return. The interface pointer gives access to specific methods belonging to the tree item. Return Values S_OK function returns successfully. TSM_E_ITEMNOTFOUND (0x98510001) the path name does not qualify an existing tree item. 5.3.11 ITc Sm Tree Item::Get Last Xml Error Gets the Item path / Error message of the last erroneous Consume Xml [} 159] call. HRESULT Get Last Xml Error(BSTR *p XML); Parameters p XML [out, retval] Error message. Return Values S_OK function returns successfully. 5.4 ITc Plc Project 5.4.1 ITc Plc Project The class ITc Plc Project enables developers to set properties for a PLC project. It usually targets the root node of a PLC project, as shown in the picture below. The following C# code snippet shows an example about how this class may be used in Automation Interface code: 164 Version: 1.5 Automation Interface

## Page 165

API ITc Sm Tree Item plc Project Root Item = system Manager. Lookup Tree Item("TIPC^Plc Generated"); ITc Plc Project iec Project Root = (ITc Plc Project)plc Project Root Item; iec Project Root. Boot Project Autostart = true; iec Project Root. Generate Boot Project (true); Please note: If you would like tocompile a PLC project, please use the compiler functionalities of the Visual Studio COM object Env DTE, as shown in many of our Samples [} 182] . Methods ITc Plc Project methods Description Available since Generate Boot Project() Equals the entry "Activate Boot project" from the Twin CAT Twin CAT 3.1 XAE context menu [} 165] Properties ITc Plc Project properties Get/Set Description Available since Boot Project Auto Start Yes / Yes Equals the checkbox "Autostart Boot Project" in Twin CAT 3.1 the dialog shown above Boot Project Encryption Yes / Yes Equals the dropdown box "Encryption" in the Twin CAT 3.1 dialog shown above Tmc File Copy Yes / Yes Equals the checkbox "Copy TMC File to Target" Twin CAT 3.1 in the dialog shown above Version information Required Twin CAT version This interface is supported in Twin CAT 3.1 and above 5.4.2 ITc Plc Project::Generate Boot Project Activates or deactivates the PLC project as a boot project, depending on the bool parameter you specify. HRESULT Generate Boot Project(VARIANT_BOOL b Activate); Parameters b Activate [in, optional, defaultvalue(-1)] Specifies if the boot project should be activated 5.5 ITc Plc Pou 5.5.1 ITc Plc Pou To handle POUs and their content within a Twin CAT 3 project, the interfaces ITc Plc Pou, ITc Plc Declaration [} 166] and ITc Plc Implementation [} 167] may be used. For example, if you would like to create a new function block for a PLC project and fill it with code, you can use these interfaces to do so. For more information, please refer to our best practise article about "How to access and create PLC-Objects". Automation Interface Version: 1.5 165

## Page 166

API Properties ITc Plc Pou properties Get / Set Description Available since Document Xml Yes / Yes Gets/Sets PLC code of a Twin CAT 3.1 POU in XML format (not PLCopen XML) Return Type Yes / No Return type of the POU, Twin CAT 3.1 for example the return type of a function. May be any data type known to the PLC, for example BOOL, DINT, ... . The return type is being set when creating the POU via the Create Child() [} 160] method. Version information Requirements Required Twin CAT version This interface is supported in Twin CAT 3.1 and above 5.5.2 IECLanguage Types The enumeration IECLanguage Types defines different programming languages according to IEC standard and may be used when creating a new POU via the method ITc Sm Tree Item [} 124]::Create Child() [} 160]. Entry Value Description IECLANGUAGE_NONE 0 --- IECLANGUAGE_ST 1 Structured Text IECLANGUAGE_IL 2 Instruction List IECLANGUAGE_SFC 3 Sequential Function Chart IECLANGUAGE_FBD 4 Function Block Diagram IECLANGUAGE_CFC 5 Continous Function Chart IECLANGUAGE_LD 6 Ladder Diagram 5.6 ITc Plc Declaration The interface ITc Plc Declaration provides access to the declaration area of PLC POUs and their sub-nodes (like Actions, Methods, ...). Please also see the best practice article "Handling PLC-Objects" for more information about how to use this interface. 166 Version: 1.5 Automation Interface

## Page 167

API Properties (in Vtable- Order) ITc Plc Declaration prop- Get / Set Description Available since erties Declaration Text Yes / Yes Represents the Twin CAT 3.1 declaration area of the item and gets/sets its content in cleartext Version information Required Twin CAT version This interface is supported in Twin CAT 3.1 and above 5.7 ITc Plc Implementation The interface ITc Plc Implementation provides access to the implementation area of PLC POUs and their sub- nodes (like Actions, Methods, ...). Please also see the best practice article about "Handling PLC-Objects" for more information about how to use this interface. Automation Interface Version: 1.5 167

## Page 168

API Properties (in VTable Order ITc Plc Implementation Get / Set Description Available since properties Implementation Text Yes / Yes Represents the Twin CAT 3.1 declaration area of the item and gets/sets its content in cleartext Implementation Xml Yes / Yes Gets/Sets the content in Twin CAT 3.1 XML format (not PLCopen XML) Language Yes / No Gets the IEC language Twin CAT 3.1 used in the implementation area Version information Requirements Required Twin CAT version This interface is supported in Twin CAT 3.1 and above 5.8 ITc Plc IECProject 5.8.1 ITc Plc IECProject The interface ITc Plc IECProject provides methods for importing and exporting PLC projects according to the Plc Open XML standard or saving PLC projects as a PLC library. Compared to the Twin CAT XAE GUI, this interface represents the following four options: 168 Version: 1.5 Automation Interface

## Page 169

API Methods (in VTable Order) ITc Plc IECProject methods Description Available since Plc Open Export() [} 170] Exports the specified tree nodes Twin CAT 3.1 and their content to a Plc Open conform XML file Plc Open Import() [} 170] Imports a Plc Open conform XML Twin CAT 3.1 file and its content Save As Library() [} 171] Saves the selected PLC project as Twin CAT 3.1 a PLC library and optionally also installs it. Version information Requirements Required Twin CAT version This interface is supported in Twin CAT 3.1 and above 5.8.2 Plc Import Options This enum contains the following options and is being used when importing a Plc Open conform XML file via method ITc Plc IECProject [} 168]::Plc Open Import() [} 170]. Automation Interface Version: 1.5 169

## Page 170

API Element Description Supported By PLCIMPORTOPTIONS_NONE --- Twin CAT 3.1 PLCIMPORTOPTIONS_RENAME In case the imported item already Twin CAT 3.1 exists in the PLC project, it is automatically renamed PLCIMPORTOPTIONS_REPLACE In case the imported item already Twin CAT 3.1 exists in the PLC project, the existing project is being replaced PLCIMPORTOPTIONS_SKIP In case the imported item already Twin CAT 3.1 exists in the PLC project, skip it 5.8.3 ITc Plc IECProject::Plc Open Export Exports the specified tree nodes and their content to a Plc Open conform XML file. A path to the XML file and the tree nodes will be specified in a parameter of this method. HRESULT Plc Open Export(BSTR bstr File, BSTR bstr Selection); Parameters b Str File [in] : Path to the XML file bstr Selection [in] : Selection of tree items which should be exported. The items are separated by a semicolon, e.g. z. B. "POUs. FBItem1;POUs. FBItem2" Return Values S_OK Items successfully exported into Plc Open XML file. 5.8.4 ITc Plc IECProject::Plc Open Import Imports a Plc Open conform XML file and its content. A path to the XML file will be passed to the method via a parameter. HRESULT Plc Open Import(BSTR bstr File, int options, BSTR bstr Selection, VARIANT_BOOL b Folder Structure); Parameters bstr File [in] : Path to the XML file. options [in, optional, defaultvalue(0)] : Options for import, according to enum PLCIMPORTOPTIONS [} 169]. bstr Selection [in, optional, defaultvalue("")] : Selects which items from the XML structure should be imported b Folder Structure [in, optional, defaultvalue(-1)] : If set to true (-1), the folder structure of the imported objects remains the same, if this information is available in the XML file 170 Version: 1.5 Automation Interface

## Page 171

API Return Values S_OK Plc Open XML file successfully imported. 5.8.5 ITc Plc IECProject::Save As Library Saves the PLC project as a PLC library and optionally installs it. HRESULT Save As Library(BSTR bstr Library Path, VARIANT_BOOL binstall); Parameters b Str Library Path [in] : Path to the location where the PLC library should be saved to binstall [in] : set to "true" if PLC library should also be installed Return Values S_OK PLC project successfully saved as a PLC library. 5.9 ITc Plc Library Manager 5.9.1 ITc Plc Library Manager The ITc Plc Library Manager interface extends the Automation Interface by enabling access to PLC libraries of a Twin CAT 3 PLC project or PLC repositories of a Twin CAT system. Automation Interface Version: 1.5 171

## Page 172

API Methods (in VTable Order) ITc Plc Library Manager methods Description Available since Add Library() [} 173] Adds a library to a PLC project. Twin CAT 3.1 Add Placeholder() [} 173] Adds a placeholder to a PLC Twin CAT 3.1 project Insert Repository() [} 174] Creates a repository, which Twin CAT 3.1 represents a logical container for several libraries. Install Library() [} 174] Installs a library into a repository. Twin CAT 3.1 Move Repository() [} 174] Changes the position of the Twin CAT 3.1 repository in the repository location list. Remove Reference() [} 174] Removes library from the PLC Twin CAT 3.1 project. Remove Repository() [} 175] Removes a repository. Twin CAT 3.1 Scan Libraries() [} 175] Returns a list of all libraries found Twin CAT 3.1 in the system. The returned object is of type ITc Plc Libraries [} 178], which is a collection of ITc Plc Library [} 177] objects. Set Effective Resolution() [} 176] Sets the Effective Resolution of a Twin CAT 3.1 placeholder Uninstall Library() [} 176] Uninstalls a library from a Twin CAT 3.1 repository. Properties (in VTable Order) ITc Plc Library Manager Get / Set Description Available since properties References Yes / No Gets an object of type Twin CAT 3.1 ITc Plc References [} 177], which is a collection of ITc Plc Library [} 177] or ITc Plc Placeholder Ref objects. Represents a list of all references added to the PLC project. Repositories Yes / No Gets an object of type Twin CAT 3.1 ITc Plc Lib Repositories [} 180], which is a collection of ITc Plc Lib Repository [} 179] objects. Represents a list of all currently configured repositories. Version information Requirements Required Twin CAT version This interface is supported in Twin CAT 3.1 and above 172 Version: 1.5 Automation Interface

## Page 173

API 5.9.2 ITc Plc Library Manager::Add Library Adds a library to the PLC project. A library can either be added by its attributes (Name, Version, Company) or by its display text. HRESULT Add Library( BSTR bstr Lib Name, BSTR bstr Version, BSTR bstr Company ); HRESULT Add Library(BSTR bstr Lib Name, BSTR bstr Version, BSTR bstr Company); Parameters bstr Lib Name [in] Library name. bstr Version [in, optional, defaultvalue("")] Library version. bstr Company [in, optional, defaultvalue("")] Company which created the library. Return Values S_OK Library successfully added.. Comments Two common ways to add a PLC library are: • library Manager. Add Library("Tc2_MDP", "3.2.0.0", "Beckhoff Automation Gmb H"); // Adding library via its attributes • library Manager. Add Library("Tc2_MDP, 3.2.0.0 (Beckhoff Automation Gmb H)"); // Adding library via its display name Where libray Manager is an object of type ITc Plc Library Manager. 5.9.3 ITc Plc Library Manager::Add Placeholder Adds a placeholder to the PLC project. A placeholder can either be added by its attributes (Placeholder name, library name, library version, library distributor) or by its name if the placeholder already exists. HRESULT Add Placeholder(BSTR bstr Placeholder Name, BSTR bstr Default Lib Name, BSTR bstr Default Version, BSTR bstr Default Distributor); Parameters bstr Placeholder Name [in] Placeholder name. bstr Default Lib Name [in] Default library name which the placeholder points to. bstr Version [in, optional, defaultvalue("")] Default library version. bstr Company [in, optional, defaultvalue("")] Company which created the library. Return Values S_OK Placeholder successfully added.. Automation Interface Version: 1.5 173

## Page 174

API 5.9.4 ITc Plc Library Manager::Insert Repository Adds a new library repository at the specified position. The position represents the index at which the repositories is located in the repository list in Twin CAT 3. In addition to the index, a repository is identified via its name and path to a directory in the file system. HRESULT Insert Repository(BSTR bstr Name, BSTR root Folder, int i Index); Parameters bstr Name [in] Repository name. root Folder [in] Path to repository (file system). i Index [in] Indicates on which position the repository is located in the list of repositories. Return Values S_OK Repository successfully inserted 5.9.5 ITc Plc Library Manager::Install Library Installs a library into an existing library repository. HRESULT Install Library(BSTR bstr Repository Name, BSTR bstr Lib Path, VARIANT_BOOL b Overwrite); Parameters bstr Repository Name [in] : Name of repository, where the library should be inserted bstr Lib Path [in] : Path to the library b Overwrite [in] : If another library already exists, set this parameter to overwrite it Return Values S_OK Library installation successful. 5.9.6 ITc Plc Library Manager::Move Repository Moves the repository to a new position in the list of repositories. The position is marked by its index, which starts at 0. HRESULT Move Repository(BSTR bstr Repository Name, int i New Index); Parameters bstr Repository Name [in] : Name of the repository i New Index [in] : Index of the repository 5.9.7 ITc Plc Library Manager::Remove Reference Removes a reference from the actual PLC project. A reference can either be a library or a placeholder. Please note: In case of a library, this only removes the reference, not the actual library file from the repository. For this, the method Uninstall Library [} 176]() needs to be used. 174 Version: 1.5 Automation Interface

## Page 175

API Similar to the method Add Library [} 173](), a library can be removed either by specifying its attributes (Name, Version, Company) or display text. HRESULT Remove Reference(BSTR bstr Lib Name, BSTR bstr Version, BSTR bstr Company); Parameters bstr Lib Name [in] : Name of library bstr Version [in, optional, defaultvalue("")] : bstr Company [in, optional, defaultvalue("")] Comments Two common ways to remove a PLC library are: • library Manager. Remove Reference("Tc2_MDP", "3.2.0.0", "Beckhoff Automation Gmb H"); // Removing library via its attributes • library Manager. Remove Reference("Tc2_MDP, 3.2.0.0 (Beckhoff Automation Gmb H)"); // Removing library via its display name Where libray Manager is an object of type ITc Plc Library Manager. 5.9.8 ITc Plc Library Manager::Remove Repository Removes a library repository. A repository is specified by its unique name. HRESULT Remove Repository(BSTR bstr Name); Parameters bstr Name [in] Name of repository. 5.9.9 ITc Plc Library Manager::Scan Libraries Returns a collection of all registered libraries in all repositories. HRESULT Scan Libraries(ITc Plc Libraries** pp Enum Libraries); Parameters pp Enum Libraries [out, retval] Returns object of type ITc Plc Libraries [} 178], which is a collection of ITc Plc Library [} 177] objects. Comments This method provides the same functionality as importing the following XML structure via Consume Xml() [} 159] on the tree node "Library Manager": <Tree Item> <Plc Lib Def> <Scan Libraries> <Active>true</Active> </Scan Libraries> </Plc Lib Def> </Tree Item> Automation Interface Version: 1.5 175

## Page 176

API 5.9.10 ITc Plc Library Manager::Set Effective Resolution Sets the Effective Resolution, meaning the effective library, of a placeholder. HRESULT Set Effective Resolution(BSTR bstr Placeholder Name, BSTR str Lib Name, BSTR bstr Version, BSTR bstr Distributor); In Twin CAT XAE, the Effective Resolution can be set via the Placeholder configuration window. Please note: The Default Resolution of a placeholder is set when the placeholder is added via ITc Plc Library Manager [} 171]::Add Placeholder() [} 173]. Parameters bstr Placeholder Name [in] Placeholder name for which the Effective Resolution should be set. bstr Lib Name [in] Library name for Effective Resolution. bstr Version [in, optional, defaultvalue("")] Library version. bstr Distributor [in, optional, defaultvalue("")] Company which created the library. Return Values S_OK Effective Resolution successfully set. 5.9.11 ITc Plc Library Manager::Uninstall Library Uninstalls a library from a repository. HRESULT Uninstall Library(BSTR bstr Repository Name, BSTR bstr Library Name, BSTR bstr Version, BSTR bstr Distributor); 176 Version: 1.5 Automation Interface

## Page 177

API Parameters bstr Repository Name [in] : Name of repository bstr Library Name [in] : Name of library bstr Version [in, optional] : Version of library bstr Distributor [in, optional] : Distributor of library 5.10 ITc Plc References ITc Plc References represents a collection of ITc Plc Lib Ref [} 178] objects, which is returned for example when using the property ITc Plc Library Manager [} 171]::References. Methods (in VTable Order) Requirements ITc Plc Lib Repositories methods Description Available since get_Item() [} 180] Returns an item of type Twin CAT 3.1 ITc Plc Lib Ref [} 178] which is located on a specified position. Properties (in VTable Order) ITc Plc Lib Repositories Get / Set Description Available since properties Count Yes / No Returns the amount of Twin CAT 3.1 ITc Plc Lib Ref [} 178] objects in the collection Version information Required Twin CAT version This interface is supported in Twin CAT 3.1 and above 5.11 ITc Plc Library Represents a single PLC library when used with collection ITc Plc Libraries [} 178] and method ITc Plc Library Manager [} 171]::Scan Libraries() [} 175] or property ITc Plc Library Manager [} 171]::References. Properties (in VTable Order) ITc Plc Library properties Get / Set Description Available since Display Name Yes / No Display name to identify Twin CAT 3.1 library in library list Distributor Yes / No Library creator Twin CAT 3.1 Name Yes / No Library name Twin CAT 3.1 Version Yes / No Library version Twin CAT 3.1 Automation Interface Version: 1.5 177

## Page 178

API Version information Requirements Required Twin CAT version This interface is supported in Twin CAT 3.1 and above 5.12 ITc Plc Libraries 5.12.1 ITc Plc Libraries ITc Plc Libraries represents a collection of ITc Plc Library [} 177] objects, for example when using method ITc Plc Library Manager [} 171]::Scan Libraries() [} 175] or property ITc Plc Library Manager [} 171]::Libraries. Methods (in VTable Order) Requirements ITc Plc Libraries methods Description Available since get_Item() [} 178] Returns item of type ITc Plc Library Twin CAT 3.1 [} 177] which is located on a specified position. Properties (in VTable Order) ITc Plc Libraries proper- Get / Set Description Available since ties Count Yes / No Returns the amount of Twin CAT 3.1 ITc Plc Library [} 177] objects in the collection Version information Required Twin CAT version This interface is supported in Twin CAT 3.1 and above 5.12.2 ITc Plc Libraries::get_Item Returns ITc Plc Library object on specified position. HRESULT Add Library(long n, ITc Plc Library** pip Type); Parameters n [in] Position of item in list. pip Type [out, retval] Returns object of type ITc Plc Library 5.13 ITc Plc Lib Ref ITc Plc Lib Ref represents a base class for either ITc Plc Library [} 177] or ITc Plc Placeholder Ref [} 179] objects. 178 Version: 1.5 Automation Interface

## Page 179

API Properties (in VTable Order) Requirements ITc Plc Lib Repositories Get / Set Description Available since properties Name Yes / No Returns the name of the Twin CAT 3.1 ITc Plc Lib Ref object Version information Required Twin CAT version This interface is supported in Twin CAT 3.1 and above 5.14 ITc Plc Placeholder Ref Represents a single PLC placeholder when used with collection ITc Plc References [} 177] and method ITc Plc Library Manager [} 171]::Scan Libraries() [} 175] or property ITc Plc Library Manager [} 171]::References. Properties (in VTable Order) ITc Plc Library properties Get / Set Description Available since Display Name Yes / No Display name to identify Twin CAT 3.1 library in library list Distributor Yes / No Library creator Twin CAT 3.1 Name Yes / No Library name Twin CAT 3.1 Version Yes / No Library version Twin CAT 3.1 Version information Requirements Required Twin CAT version This interface is supported in Twin CAT 3.1 and above 5.15 ITc Plc Lib Repository The ITc Plc Lib Repository interface represents a single repository, for example when used with collection ITc Plc Lib Repositories [} 180] and property ITc Plc Library Manager [} 171]::Repositories. Properties ITc Plc Lib Repository Get / Set Description Available since properties Folder Yes / No Path to repository (file Twin CAT 3.1 system) Name Yes / No Repository name. Twin CAT 3.1 Automation Interface Version: 1.5 179

## Page 180

API Version information Requirements Required Twin CAT version This interface is supported in Twin CAT 3.1 and above 5.16 ITc Plc Lib Repositories 5.16.1 ITc Plc Lib Repositories ITc Plc Libraries represents a collection of ITc Plc Lib Repository [} 179] objects, for example when using property ITc Plc Library Manager [} 171]::Repositories. Methods (in VTable Order) Requirements ITc Plc Lib Repositories methods Description Available since get_Item() [} 180] Returns item of type Twin CAT 3.1 ITc Plc Lib Repository [} 179] which is located on a specified position. Properties (in VTable Order) ITc Plc Lib Repositories Get / Set Description Available since properties Count Yes / No Returns the amount of Twin CAT 3.1 ITc Plc Lib Repository [} 179] objects in the collection Version information Required Twin CAT version This interface is supported in Twin CAT 3.1 and above 5.16.2 ITc Plc Lib Repositories::get_Item Returns ITc Plc Lib Repository object on specified position. HRESULT Add Library(long n, ITc Plc Lib Repository** pp Repo); Parameters n [in] Position of item in list. pip Type [out, retval] Returns object of type ITc Plc Lib Repository 180 Version: 1.5 Automation Interface

## Page 181

API 5.17 ITc Plc Task Reference The ITc Plc Task Reference interface enables programmers to get or set the currently linked task of a PLC project. This matches the following Twin CAT XAE entry: Properties (in VTable Order) Requirements ITc Plc Task Reference Get / Set Description Available since properties Linked Task Yes / Yes Gets or sets the linked Twin CAT 3.1 task of a PLC project. When setting a new linked task, the task will be specified as a string which represents the path to the task in the Twin CAT XAE tree. Automation Interface Version: 1.5 181

## Page 182

Samples 6 Samples 6.1 Sample downloads Most of the samples and How To’s are available as code snippets in our “Best Practice” section to allow an easy re-usability. However, this download section also provides ready-to-use samples as either binary or source code. Important notes: • All C# samples are based on a Visual Studio project with at least . NET 4.0 • All C# samples include a reference to the "Twin CAT XAE Base" type library in version 2.1. Depending on the installed Twin CAT version, the reference to this library may need to be updated, see Installation article [} 17] • Please note that all Visual Studio Plugin samples are only operable under Visual Studio 2010 and 2012. To develop Add-Ins for Visual Studio 2013, Microsoft recommends to use the VSPackage Extension, as described on the corresponding MSDN website about Creating Add-ins and Wizards. Sample No. Description Programming / Minimum Download Scripting lan- Twin CAT ver- guage sion 1 Scripting C# Depends on Scripting Container Binaries only script Container Scripting Container Source [} 182] 2 Code Generatio C# 3.1 Build Code Generation Demo Binaries only 4014.0 n Demo [} 186] Code Generation Demo Source 3 Visual Studio C# 3.1 Build Plugin Sample_Plc Version Info.zip 4016.6 Plugin Plc Version Info [} 188] 6.2 Scripting Container 6.2.1 Scripting Container The Scripting Contrainer (download here [} 182]) is a C# WPF application which represents a collection of all available Automation Interface samples. Most of these samples are also available as a standalone sample download - however, as new samples become available, they will be first published in the Scripting Container before creating a separate sample. Threfore we recommend to become familiar with this application and to check periodically for new samples. This article describes the general structure of the Scripting Container application and consists of the following topics: • Basic structure • First time setup Basic structure As mentioned above the Scripting Container consists of a collection of Automation Interface samples, which are represented by different projects (each with an own UI) within the Scripting Container. The following table gives an overview about all available projects and links to the corresponding documentation article. 182 Version: 1.5 Automation Interface

## Page 183

Samples Project name Description Code Generation Demo [} 186] Implements AI code that reads three different Twin CAT configurations from a XML file. Copy Project Demo Copies I/Os and Axis configuration from an existing Twin CAT configuration to a new configuration. Scripting Test Container [} 183] Provides a collection of available Automation Interface samples, which can be executed from a graphical user interface. First time When opening the Scripting Container for the first time, please set the Start Up Project to the desired user interface, e.g. "Scripting Test Container" by right-clicking this project and selecting "Set as Start Up Project". This ensures that the correct GUI will be loaded upon application start-up. You can now start the application by going to the menu "Debug" and clicking on "Start Debugging". By starting the application this way, you can set breakpoints or step through code execution to easily evaluate the executed script. 6.2.2 Projects 6.2.2.1 Scripting Container: Scripting Test Container This article describes the basic structure of the Scripting Test Container project and consists of the following topics: • The Graphical User Interface (GUI) • Early and late bound script samples • Location of sample scripts ("Where's the Automation Interface code???" ) • Behind the scenes: Class structure • Behind the scenes: Method structure Automation Interface Version: 1.5 183

## Page 184

Samples • Behind the scenes: Implementing own samples The Graphical User Interface (GUI) After you have started the Scripting Container application, its GUI will look as follows: The dropdown box at the top of the window lets you choose the version of Visual Studio [} 30] that you would like to use to create the Twin CAT configuration. There are a variety of sample scripts available, which can be selected in the table at the center of the window. To execute a script, simply select it from the table and click on "Execute". During code execution, the script displays status information in the message logging window below the script table. To change the visibility behavior of Visual Studio, you can switch the checkboxes in the upper right corner of the window. By default, Visual Studio is shown during script execution and not closed after the script finishes. Early and late bound script samples This application contains both - early and late bound - script samples. Late bound samples make use of the . NET data type "dynamic" and therefore determine an objects data type during runtime whereas early bound scripts use the corresponding data type of an object during the creation of an object. Both ways have their advantages and disadvantages and it depends on the developer and project which type handling is to be prefered. 184 Version: 1.5 Automation Interface

## Page 185

Samples Location of sample scripts ("Where's the Automation Interface code???") All script samples - early and late bound - are located in an own project container within the Visual Studio solution: Scripting. CSharp. Scripts for early bound and Scripting. CSharp. Scripts Late Bound for late bound sample code. Each script file implements a method On Execute() in which the Twin CAT Automation Interface script code is implemented. Behind the scenes: Class structure Each code sample is represented by an own class which derives either from the abstract class "Script Early Bound" or "Script Late Bound" - depending on the data type handling used in the sample. The difference between these two classes is that the Script Early Bound class uses static typing for the DTE and Solution objects. The Script Late Bound class uses dynamic typing instead. The following UML diagram explains the class hierarchy in more detail. The grey classes represent the actual sample scripts, which either derive from class Script Early Bound (when static typing should be used) or from class Script Late Bound (when dynamic typing should be used). The abstract class "Script" defines methods and attributes which are common for both the Script Early Bound and Script Late Bound classes. Automation Interface Version: 1.5 185

## Page 186

Samples Behind the scenes: Method structure Each sample class contains three methods which are used in the Scripting Container to execute the Automation Interface code. The following table shows their meaning. Signature of derived method Description On Initialize (dynamic dte, dynamic solution, IWorker The On Initialize() method is usually used for worker) Automation Interface code which opens or prepares a new Twin CAT XAE configuration. On Clean Up (IWorker worker) The On Clean Up() method may be used to clean-up the Twin CAT XAE configuration after code execution. On Execute (IWorker worker) This method is executing the actual Automation Interface script code. Please also compare the implementation of existing sample scripts to get a better understanding about how each method works. Behind the scenes: Implementing own samples It is easily possible to implement own Automation Interface samples into the Scripting Container. To implement own Automation Interface code, a developer only needs to decide which binding he would like to use and then implement a new class which derives from one of the main classes (Script Early Bound or Script Late Bound) and then implement the derived methods. 6.3 Code Generation Demo The Scripting Container (download here [} 182]) is a C# WPF application which represents a collection of all available Automation Interface samples. Most of these samples are also available as a standalone sample download - however, as new samples become available, they will be first published in the Scripting Container before creating a separate sample. Therefore we recommend to become familiar with this application and to check periodically for new samples. This article describes the general structure of the Scripting Container application and consists of the following topics: • The Graphical User Interface (GUI) • Location of sample scripts ("Where's the Automation Interface code???") • Location of data ("Where does all the data come from?") The Graphical User Interface (GUI) After you have started the Code Generation Demo application, its GUI will look as follows: 186 Version: 1.5 Automation Interface

## Page 187

Samples On the left hand side you can select from three different Twin CAT configuration, each with its own I/O, Axis and PLC configuration. The dropdown box on the top right side lets you choose which Visual Studio version the script code should use to create the configuration - in case you have different Visual Studio versions installed on your system. To start the configuration creation, simply select a configuration and press "Generate". Location of sample scripts ("Where's the Automation Interface code???" ) The actual Automation Interface code can be found within the following classes: • Code Generation Script.cs • Configuration Script A.cs • Configuration Script B.cs • Configuration Script C.cs Depending on the selected configuration, the Code Generation Demo application instantiates one of the three Configuration Script X.cs classes, which all derive from Code Generation Script.cs. Each class provides corresponding methods for creating the PLC, Axis or I/O configuration. Location of data ("Where does all the data come from?") Each configuration has its own I/O, Axis and PLC settings. As you may have already noticed, this configuration is not hard-coded into the Automation Interface code (like in other AI samples). In this demo, these settings are stored in an XML file that can be found under "Code Generation Demo\Data\Orders.xml". This XML file specifies two important XML sub-structures which are used to store Twin CAT settings. Main description of a configuration: <Machine Orders> <Order id="1"> ... </Order> </Machine Orders> Automation Interface Version: 1.5 187

## Page 188

Samples This structure defines a configuration and sets its global descriptive properties, e.g. Name, Description, ... . These properties will be shown on the GUI below the configuration selection. Actual configuration with a reference to its description: <Available Configurations> <Configuration id="..." name="..."> ... </Configuration> </Available Configurations> This structure specifies the I/Os, Axis, PLC libraries and linking. 6.4 Visual Studio Plugin - Plc Version Info The Plc Version Info sample demonstrates how to use the Twin CAT Automation Interface from within a Visual Studio Plugin. Its main purpose is to show how to create a simple tool that extends the PLC engineering with more functionalities. The small user interface allows to enter version and author information for PLC function blocks. When executing the sample, this information is placed in a VAR_CONSTANT area in all functionblocks within a PLC projeect. Although this might seem a pretty simple example, it clearly shows how powerfull Visual Studio Plugins can be and how they might greatly enhance the users engineering experience. For more information about Visual Studio Plugins, please consult the MSDN webpage. Basic concept As previously noted, the tool starts an iteration over all PLC tree items of a PLC project. If the current tree item is either a functionblock, function or program, then the declaration text of the tree item is determined and extended with a VAR_CONSTANT block. Notes about executing and debugging Visual Studio Plugins Visual Studio Plugins may be located in different folders so that Visual Studio recognizes them. This documentation assumes that the Plugin should only be made available for a specific user account which is why the Plugin will be placed in a directory within the user profile. For more information, please consult the MSDN webpage about Add-In Registration. To execute the Plugin without debugging, please copy the compiled DLL and the . Add In file to the directory c:\Users\username\Documents\Visual Studio 201x\Addins\ and restart Visual Studio. To execute the Plugin with debugging, simply execute the debugger from within the Plugin solution. If this causes you issues, you may also copy the . Add In file the Addins directory (mentioned above) and edit the file with a text editor of your choice to change the <Assembly> node to the path of the compiled debug DLL. Then start a Visual Studio instance and attach your debugger to this instance/process. 188 Version: 1.5 Automation Interface

## Page 189

Samples The Visual Studio Plugin will be made available in the Twin CAT menu in Visual Studio. Automation Interface Version: 1.5 189

## Page 190

Appendix 7 Appendix 7.1 Miscallaneous error codes The following error codes represent the HRESULT values of Automation Interface methods, as explained in the API reference [} 115]. typedefenum TCSYSMANAGERHRESULTS { [helpstring("ITc Sm Tree Item not found!" (ITc Sm Tree Item nicht gefunden!))] TSM_E_ITEMNOTFOUND = 0x98510001, [helpstring("Invalid Item Type!" (Ungültiger Elementtyp!))] TSM_E_INVALIDITEMTYPE = 0x98510002, [helpstring("Invalid Sub Item Type!" (Ungültiger Unterelementtyp!))] TSM_E_INVALIDITEMSUBTYPE = 0x98510003, [helpstring("Mismatching Items!" (Nicht übereinstimmende Elemente!))] TSM_E_MISMATCHINGITEMS = 0x98510004, [helpstring("Corrupted Link" (Fehlerhafte Verknüpfung))] TSM_E_CORRUPTEDLINK = 0x98510005, [helpstring("Item still referenced!" (Element immer noch referenziert!))] TSM_E_ITEMREFERENCED = 0x98510006, [helpstring("Item already deleted!" (Element bereits gelöscht!))] TSM_E_ITEMDELETED = 0x98510007, [helpstring("XML Error" (XML-Fehler))] TSM_E_XMLERROR = 0x98510008, } TCSYSMANAGERHRESULTS; Please note that the following list of COM error codes is just a snippet and not complete: Error Description RPC_E_CALL_REJECTED The COM-Server has rejected the call. Please read our article about how to implement an own Message Filter [} 26] to circumvent this error. Return value of method One cause of this error could be that the COM message filter has been Co Register Message Filter() <> 0 applied to a MTA apartment. Message filters can only be applied to STA-Threads. Please view our Message Filter [} 26] article for more information about message filters, including STA and MTA. Error message "A reference to The type library is not correctly registered. Please re-register the type Beckhoff Twin CAT XAE Base 2.0 library by executing the following command: Type Library could not be added" C:\Windows\Microsoft . NET\Framework\v4.0.xxxxx\regtlibv12.exe C: when referencing the type library in \Twin CAT3\Components\Base\TCat Sys Manager.tlb Visual Studio. xxxxxx is the version of the currently installed version of the . NET Framework 4.0. 190 Version: 1.5 Automation Interface

## Page 192

More Information: www.beckhoff.com/te1000/ Beckhoff Automation Gmb H & Co. KG Hülshorstweg 20 33415 Verl Germany Phone: +49 5246 9630 info@beckhoff.com www.beckhoff.com
